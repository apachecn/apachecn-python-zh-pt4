第十章

![image](img/frontdot.jpg)

超文本传输协议服务器

Python 程序如何作为响应 HTTP 请求的服务器运行？在第 7 章中，你学习了几种编写基于 TCP 的网络服务器的基本套接字和并发模式。使用 HTTP，您不太可能需要编写那么低级的东西，因为该协议的流行已经为您可能需要的所有主要服务器模式提供了现成的解决方案。

虽然本章将关注第三方工具，但标准库确实有一个内置的 HTTP 服务器实现。它甚至可以从命令行调用。

```py
$ python3 -m http.server
Serving HTTP on 0.0.0.0 port 8000 ...
```

该服务器遵循 20 世纪 90 年代建立的从文件系统提供文件的旧惯例。HTTP 请求中的路径被转换成在本地文件系统中搜索的路径。服务器被设计为仅在其当前工作目录下提供文件。文件正常送达。当命名一个目录时，服务器要么返回其`index.html`文件的内容(如果存在的话),要么返回其中文件的动态生成列表。

这些年来，当我需要在机器之间传输文件并且没有更具体的文件传输协议可用时，在安装 Python 的任何地方都有一个可用的小型 web 服务器使我摆脱了不止一次的尴尬。但是，如果您需要更多的东西——如果您需要让自己的软件负责响应 HTTP 请求，该采取什么步骤呢？

这本书用两个独立的章节来解决这个问题。本章将着眼于服务器架构和部署，回答需要解决的问题，无论您的代码是返回文档还是面向程序员的 API。第 11 章将描述万维网，它将研究返回 HTML 页面和与用户浏览器交互的工具。

WSGI(消歧义)

在 HTTP 编程的早期，许多 Python 服务被写成简单的 CGI 脚本,每个传入请求调用一次。服务器将 HTTP 请求分成几部分，并在其环境变量中提供给 CGI 脚本。Python 程序员可以直接检查这些并打印一个 HTTP 响应到标准输出，或者从标准库中的`cgi`模块获得帮助。

为每个传入的 HTTP 请求启动一个新的进程对服务器性能造成了很大的限制，因此语言运行库开始实现自己的 HTTP 服务器。Python 获得了其`http.server`标准库模块，该模块邀请程序员通过将`do_GET()` 和`do_POST()`方法 添加到他们自己的`BaseHTTPRequestHandler`子类中来实现他们的服务。

其他程序员希望从 web 服务器提供动态页面，该服务器也可以提供静态内容，如图像和样式表。因此，`mod_python`被写成了:一个 Apache 模块，它允许正确注册的 Python 函数提供定制的 Apache 处理程序，这些处理程序可以提供认证、日志和内容。这个 API 是 Apache 独有的。用 Python 编写的处理程序接收一个特殊的 Apache `request`对象作为参数，并可以调用`apache`模块中的特殊函数来与 web 服务器交互。使用`mod_python`的应用程序与那些用 CGI 或`http.server`编写的程序几乎没有相似之处。

这种情况意味着用 Python 编写的每个 HTTP 应用程序都倾向于锚定到一个特定的机制上，以便与 web 服务器进行交互。为 CGI 编写的服务至少需要部分重写才能与`http.server`一起工作，并且两者都需要修改才能在 Apache 下运行。这使得 Python web 服务很难移植到新的平台上。

社区回应了 PEP 333，Web 服务器网关接口(WSGI) 。

正如 David Wheeler 的名言，“计算机科学中的所有问题都可以通过另一个间接层来解决”，WSGI 标准创建了额外的间接层，这是 Python HTTP 服务与任何 web 服务器进行互操作所必需的。它规定了一个调用约定，如果在所有主要的 web 服务器上实现，将允许低级服务和完整的 web 框架插入到他们想要使用的任何 web 服务器中。到处实现 WSGI 的努力很快成功了，它现在是 Python 讲 HTTP 的标准方式。

该标准将 WSGI 应用程序定义为带有两个参数的可调用程序。 清单 10-1 中显示了一个例子，其中可调用的是一个简单的 Python 函数。(其他可能是 Python 类，它是另一种可调用的类型，或者甚至是带有`__call__()`方法的类实例。)第一个参数`environ`接收一个字典，该字典提供了我们熟悉的 CGI 环境变量集的扩展版本。第二个参数本身是可调用的，通常命名为`start_response()`，WSGI 应用程序应该用它来声明它的响应头。在被调用后，应用程序或者可以开始产生字节字符串(如果它本身是一个生成器)，或者可以返回一个迭代时产生字节字符串的 iterable(例如，返回一个简单的 Python 列表就足够了)。

[***清单 10-1***](#_list1) 。作为 WSGI 客户端 编写的简单 HTTP 服务

```py
#!/usr/bin/env python3
# Foundations of Python Network Programming, Third Edition
# https://github.com/brandon-rhodes/fopnp/blob/m/py3/chapter10/wsgi_env.py
# A simple HTTP service built directly against the low-level WSGI spec.

from pprint import pformat
from wsgiref.simple_server import make_server

def app(environ, start_response):
    headers = {'Content-Type': 'text/plain; charset=utf-8'}
    start_response('200 OK', list(headers.items()))
    yield 'Here is the WSGI environment:\r\n\r\n'.encode('utf-8')
    yield pformat(environ).encode('utf-8')

if __name__ == '__main__':
    httpd = make_server('', 8000, app)
    host, port = httpd.socket.getsockname()
    print('Serving on', host, 'port', port)
    httpd.serve_forever()
```

清单 10-1 可能让 WSGI 看起来简单，但那只是因为清单选择以简单的方式运行，而不是充分利用规范。当实现规范的服务器端时，复杂程度更高，因为在这种情况下，必须为充分利用标准中描述的许多警告和边缘情况的应用程序准备代码。如果您想了解其中的内容，可以阅读 PEP 3333，它是 WSGI 的现代 Python 3 版本。

在 WSGI 首次亮相之后，WSGI 中间件的想法达到了全盛时期 Python HTTP 服务将来可能会从一系列同心的 WSGI 包装器中设计出来。 一个包装器可能提供认证。另一个可能在返回 500 内部服务器错误页面之前捕获异常并记录下来。还有一种可能是将遗留的 URL 反向代理到一个仍在组织中运行的旧 CMS，并使用 Diazo(一个延续至今的项目)来重新主题化它，以匹配该组织更现代的页面。

尽管仍然有开发人员编写和使用 WSGI 中间件，但今天大多数 Python 程序员使用 WSGI 只是为了它在应用程序或框架与监听传入 HTTP 请求的 web 服务器之间提供的可插入性。

异步服务器框架

然而，有一种应用程序模式还没有被 WSGI 革命所触及，那就是异步服务器，它支持协程或绿色线程。

WSGI callable 的设计目标是传统的多线程或多进程服务器，因此该 callable 在需要执行任何 I/O 时都会被阻塞。WSGI 没有提供一种机制，通过这种机制，可调用程序可以将控制权交还给主服务器线程，以便其他可调用程序可以轮流取得进展。(参见[第 7 章](07.html)中关于异步的讨论，了解异步服务如何将其逻辑分割成小的、非阻塞的代码片段。)

因此，每个异步服务器框架都必须为编写 web 服务提供自己的约定。虽然这些模式在简洁性和便利性方面有所不同，但它们通常负责解析传入的 HTTP 请求，并且它们有时为自动进行 URL 分派和提交数据库连接提供便利(参见第 11 章)。

这就是为什么本节的标题包括“服务器框架”在 Python 中探索异步的项目必须在它们特定的引擎上产生一个 HTTP web 服务器，然后发明一个调用约定，通过它它们已经解析的请求信息可以传递给你自己的代码。与 WSGI 生态系统不同，您不能单独选择异步 HTTP 服务器和 web 框架。两者很可能会出现在同一个包中。

Twisted server 支持许多不同的协议处理程序，十多年来一直为编写 web 服务提供自己的约定。最近，脸书开发并开源了其 Tornado 引擎，该引擎不支持许多协议，而是专门关注 HTTP 的性能。它支持一组与 Twisted 不同的回调约定。Eventlet 项目的绿色线程是隐式异步的，而不是在每个 I/O 操作期间显式地将控制权交还，它允许您编写看起来像普通 WSGI 的可调用程序，但当它们试图阻塞操作时，会悄悄地交出控制权。

展望未来，Python 的发明者吉多·范·罗苏姆支持 Python 3.4 (见[第 7 章](07.html))中的新`asyncio`引擎，因为它提供了一个统一的接口，不同的事件循环实现可以通过这个接口插入不同的异步协议框架。虽然这可能有助于统一低级事件循环的多样化世界，但它似乎不会对想要编写异步 HTTP 服务的作者产生任何直接影响，因为它没有指定专门讲述 HTTP 请求和响应语言的 API。

要记住的限制是，如果您计划使用特定的异步引擎(如`asyncio`或 Tornado 或 Twisted)编写 HTTP 服务，您需要选择 HTTP 服务器和帮助您解析请求和编写响应的框架。您将无法混合搭配服务器和框架。

正向和反向代理

HTTP 代理(无论是正向还是反向)是一个 HTTP 服务器，它接收传入的请求，并且至少对于某些路径来说，返回并成为一个客户端，向它后面的服务器发出 HTTP 请求，最后将该服务器的响应传递回原始客户端。阅读 RFC 7230 第 2.3 节，了解代理的介绍以及 HTTP 的设计如何预测它们的需求:`https://tools.ietf.org/html/rfc7230#section-2.3`。

早期对网络的描述似乎认为*转发代理* 将是最常见的代理模式。例如，一个雇主可能会提供一个 HTTP 代理，供其员工的 web 浏览器请求，而不是直接与远程服务器对话。一大早，一百名员工的 web 浏览器首先请求 Google 徽标，这可能会导致代理服务器只向 Google 发送一个请求，然后就可以缓存该请求并用于满足所有后续员工的请求。如果谷歌在过期和缓存控制头上足够慷慨，那么雇主将花费更少的带宽，员工将体验更快的网络。

但是随着 TLS 作为保护用户隐私和凭证的通用最佳实践的出现，转发代理变得不可能。代理不能检查或缓存它不能读取的请求。

另一方面，反向代理现在在大型 HTTP 服务中无处不在。一个*反向* *代理* 作为 web 服务本身的一部分运行，对于 HTTP 客户端是不可见的。当客户认为他们正在连接到`python.org`时，他们实际上是在和一个反向代理说话。如果核心`python.org`服务器小心翼翼地包含 Expires 或 Cache-Control 头，代理可以直接从其缓存中为许多资源提供服务，包括静态和动态资源。反向代理通常可以承担运行服务的大部分负载，因为只有当资源不可缓存或已从代理的缓存中过期时，HTTP 请求才需要转发到核心服务器。

反向代理必须执行 TLS 终止，并且它必须是持有其代理的服务的证书和私钥的服务。除非代理可以检查每个传入的 HTTP 请求，否则它不能执行缓存或转发。

如果您采用反向代理的使用，无论是以 Apache 或 nginx 这样的前端 web 服务器的形式，还是以 Varnish 这样的专用守护进程的形式，与缓存相关的头比如 Expires 和 Cache-Control 变得比正常情况下更加重要。它们不再仅仅与最终用户的浏览器相关，而是成为您自己的服务架构的各层之间的重要信号。

反向代理甚至可以帮助处理您可能认为不应该缓存的数据，比如需要精确到秒的标题页面或事件日志，只要您能够容忍结果至少存在几秒钟。毕竟，无论如何，客户端检索一个资源通常需要几分之一秒的时间。如果资源多存在一秒钟，真的会有损失吗？想象一下，在一个每秒接收一百个请求的关键提要或事件日志的缓存控制头中放置一秒钟的最大年龄。您的反向代理将开始工作，并有可能将您的服务器负载降低 100 倍:它只需要在每秒开始时获取一次资源，然后它可以为所有其他请求的客户端重用缓存的结果。

如果您将在一个代理后面设计和部署一个大型的 HTTP 服务，那么您将需要参考 RFC 7234 及其对 HTTP 缓存设计及其预期好处的扩展讨论。您会发现专门针对中间缓存(如 Varnish)的选项和设置，而不是针对最终用户的 HTTP 客户端的选项和设置，如 proxy-revidate 和 s-maxage，当您接近服务设计时，您应该在工具箱中有这些选项和设置。

![Image](img/sq.jpg)仔细阅读 RFC 7231 第 7.1.4 节中的`Vary`标题描述，以及第 9 章中的[标题描述。值`Vary: Cookie`通常是确保正确行为所必需的，原因将变得清楚。](09.html)

四种架构

虽然架构师似乎有能力从更小的部分产生无限数量的复杂方案来组装 HTTP 服务，但是有四种主要的设计已经成为 Python 社区中的习惯(参见[图 10-1](#Fig1) )。如果您已经编写了 Python 代码来生成动态内容，并且选择了可以使用 WSGI 的 API 或框架，那么将 HTTP 服务放到网上有什么选择呢？

*   运行一个本身用 Python 编写的服务器，它可以从自己的代码中直接调用您的 WSGI 端点。绿色独角兽(“gunicorn”)服务器 是目前最受欢迎的，但也有其他生产就绪的纯 Python 服务器。例如，久经考验的 CherryPy 服务器至今仍在项目中使用，Flup 仍然吸引着用户。(最好避免使用原型服务器，如`wsgiref`，除非您的服务负载较轻，并且位于组织内部。)如果你使用一个异步服务器引擎，那么服务器和框架将必然存在于同一个进程中。
*   运行 Apache，将`mod_wsgi`配置为在单独的`WSGIDaemonProcess`中运行 Python 代码，产生一种混合方法:两种不同的语言在工作，但是在一个服务器中。静态资源可以直接从 Apache 的 C 语言引擎获得，而动态路径被提交给`mod_wsgi`，以便它可以调用 Python 解释器来运行您的应用程序代码。(该选项对于异步 web 框架不可用，因为 WSGI 没有提供一种机制，应用程序可以通过这种机制暂时放弃控制权，然后再完成工作。)
*   在 web 服务器后面运行像 Gunicorn 这样的 Python HTTP 服务器(或者由您选择的异步框架指定的任何服务器),它可以直接提供静态文件，但也可以充当您用 Python 编写的动态资源的反向代理。Apache 和 nginx 都是这个任务的流行前端服务器。如果您的 Python 应用程序超出了一个单独的机器，它们还可以在几个后端服务器之间对请求进行负载平衡。
*   在 Apache 或 nginx 后面运行一个 Python HTTP 服务器，它本身位于 Varnish 这样的纯反向代理后面，创建一个面向现实世界的第三层。这些反向代理可以在地理上分布，以便从靠近客户机的位置提供缓存的资源，而不是从同一个大陆提供。*Fastly 等内容交付网络*通过在各大洲的机房部署大批 Varnish 服务器，然后使用它们为您提供全套服务，既终止您面向外部的 TLS 证书，又将请求转发到您的中央服务器。

![9781430258544_Fig10-01.jpg](img/9781430258544_Fig10-01.jpg)

[图 10-1](#_Fig1) 。独立部署 Python 代码或在反向 HTTP 代理后部署 Python 代码的四种常用技术

在这四种架构之间的选择在历史上是由 C Python 运行时的三个特性驱动的:解释器很大，很慢，并且它的全局解释锁防止一次有多个线程执行 Python 字节码。

解释器锁的局限性鼓励使用独立的 Python 进程，而不是多个 Python 线程共享同一个进程。但是解释器的大小反过来了:只有一定数量的 Python 实例可以轻松放入 RAM，这限制了进程的数量。

在 Apache 下运行 Python

如果您想象一个使用旧的`mod_python`在 Apache 下运行的早期 Python 支持的 web 站点，您就能最好地理解前面描述的问题。对一个典型网站的大多数请求(见[第 11 章](11.html))都是针对静态资源的:对于每一个要求 Python 动态生成页面的请求，可能会有十几个对附带的 CSS、JavaScript 和图像的请求。然而`mod_python`让每个 Apache 工人都负担起自己的 Python 解释器运行时副本，其中大部分处于闲置状态。每十几个工人中可能只有一个在给定的时刻运行 Python，而其他人使用 Apache 的核心 C 代码假脱机输出文件。

如果 Python 解释器与将静态内容从磁盘转移到等待套接字的 web 服务器工作器独立运行，这种僵局就会被打破。这产生了两种相互竞争的方法。

避免用 Python 解释器加重每个 Apache 线程负担的第一种方法是使用现代的`mod_wsgi`模块，激活其“守护进程”特性。在这种模式下，Apache 的工作人员——无论是线程还是进程——都省去了加载或执行 Python 的费用，只产生了动态链接到`mod_wsgi`本身的成本。相反，`mod_wsgi`创建并管理一个单独的 Python 工作进程池，它可以向该池转发请求，并且 WSGI 应用程序将在该池中被实际调用。几十个小的 Apache 工人可以忙着为每个大的 Python 解释器输出静态文件，这些解释器慢慢地构建动态页面。

纯 Python HTTP 服务器的兴起

然而，一旦您接受了这样一个事实，即 Python 不会存在于主服务器进程本身中，而是 HTTP 请求必须被序列化并从 Apache 进程转发到 Python 进程中，为什么不直接使用 HTTP 呢？为什么不将 Apache 配置为将每个动态请求反向代理到 Gunicorn，并在其中运行您的服务呢？

的确，您现在必须启动和管理两个不同的守护进程——Apache 和 guni corn——而在此之前，您只需启动 Apache 并让`mod_wsgi`负责生成您的 Python 解释器。但是作为回报，你获得了很大的灵活性。首先，Apache 和 Gunicorn 不再有任何理由需要生活在同一个盒子上；您可以在针对大量并发连接和无序文件系统访问进行优化的服务器上运行 Apache，在针对动态语言运行时对数据库进行后端请求进行优化的单独服务器上运行 Gunicorn。

一旦 Apache 从您的应用程序容器变成了一个具有反向代理功能的静态文件服务器，您可以选择替换它。毕竟，nginx 也可以在反向代理其他路径的同时提供文件服务，就像许多其他现代 web 服务器一样。

最后,`mod_wsgi`选项变成了真正的反向代理的一个有限的专有版本:您在必须运行在同一台机器上的进程之间使用自己的内部协议，而您可以使用真正的 HTTP，并且可以根据您的需要选择在同一台机器上或不同的机器上运行 Python。

反向代理的好处

如果 HTTP 应用程序只提供由 Python 代码生成的动态内容，而不涉及静态资源，该怎么办？在这种情况下，Apache 或 nginx 似乎没什么事可做，您可能会试图忽略它们，而将 Gunicorn 或另一个纯 Python web 服务器直接公开。

在这种情况下，一定要考虑反向代理提供的安全性。要让你的 web 服务暂停，所有人需要做的就是用 *n* 个套接字连接到你的 *n* -worker 服务，提供一些请求数据的初始杂乱字节，然后冻结。您的所有工作人员现在都将忙于等待一个可能永远也不会到达的完整请求。相比之下，有了 Apache 或 nginx 在您的服务前面，那些需要很长时间才能到达的请求——无论是出于恶意，还是因为您的一些客户端运行在移动设备上，或者带宽很低——都会被反向代理的缓冲区缓慢收集，反向代理通常不会将请求转发给您，直到请求被完整接收。

当然，在转发请求之前收集完整请求的代理并不能抵御真正的拒绝服务攻击——唉，什么都不是——但是它确实可以防止动态语言运行时在来自客户端的数据尚未到来时停止工作。它还将 Python 与许多其他类型的病态输入隔离开来，从兆字节长的头名称到完全畸形的请求，因为 Apache 或 nginx 会直接拒绝这些带有 4 个 *xx* 错误的请求，而您的后端应用程序代码甚至不会怀疑。

在前面的列表中，我目前倾向于架构的三个最佳点。

我的默认设置是 nginx 后面的 Gunicorn，或者如果系统管理员喜欢的话，是 Apache。

如果我正在运行一个真正的纯 API 服务，并且不涉及任何静态组件，那么我有时会尝试单独运行 Gunicorn，或者直接在 Varnish 后面运行，如果我想让我的动态资源受益于它的一流缓存逻辑的话。

只有在设计大型 web 服务时，我才会全力以赴地使用三个层次:我的 Python 在 Gunicorn 中运行，在 nginx 或 Apache 之后，在本地或地理上分布的 Varnish 集群之后。

当然，许多其他配置也是可能的，我希望前面的讨论包含了足够多的注意事项和权衡，这样当问题出现在您自己的项目和组织中时，您将能够明智地做出选择。

即将出现的一个重要问题是像 PyPy 这样可以以机器速度运行的 Python 运行时的出现。一旦 Python 代码可以像 Apache 一样快速运行，为什么不让 Python 同时服务静态和动态内容呢？看看由快速 Python 运行时支持的服务器是否会对 Apache 和 nginx 等旧的可靠解决方案造成任何竞争，这将是一件有趣的事情。当行业的最爱被系统管理员很好地记录、理解和喜爱时，Python 服务器能为迁移提供什么激励呢？

当然，任何先前的模式都可能有变化。Gunicorn 可以直接运行在 Varnish 之后，例如，如果不需要提供静态文件，或者如果您愿意让 Python 将它们从磁盘中取出来。另一种选择是使用 nginx 或 Apache，打开它们的反向缓存选项，这样它们就可以提供基本的类似 Varnish 的缓存，而不需要第三层。一些网站试验了前端服务器和 Python 之间对话的替代协议，如 Flup 和 uwsgi 项目支持的协议。本节介绍的四种模式只是最常见的几种。还有许多其他可能的设计，其中大部分在今天的某个地方使用。

平台即服务

上一节中提到的许多主题——负载平衡、多层代理服务器和应用程序部署——开始转向系统管理和操作规划。诸如选择前端负载平衡器或使 HTTP 服务在物理上和地理上冗余所涉及的选择等问题并不是 Python 所独有的。如果包含在本章中，它们将带您远离 Python 网络编程的主题。

当您将 Python 作为提供网络服务策略的一部分时，我鼓励您也阅读自动化部署、持续集成和高性能扩展，以了解可能适用于您自己的服务和组织的技术。这里没有足够的空间来覆盖它们。

但是有一个话题值得一提:平台即服务(PaaS)提供商 的出现，以及如何打包您的应用程序以部署在此类服务上的问题。

有了 PaaS，建立和运行 HTTP 服务的许多繁琐工作都被自动化了——或者，至少，移交给了 PaaS 提供商，而不是您自己。您无需租用服务器，为其提供存储和 IP 地址，配置管理和重启服务器的 root 访问权限，安装正确版本的 Python，将应用程序复制到每台服务器，以及在重启或断电后自动启动服务所需的系统脚本。

相反，这些负担由 PaaS 提供商承担，他们可能会安装或租用数千台机器、数百台数据库服务器和数十台负载平衡器，以便为其客户群提供服务。自动化了所有这些步骤之后，提供商需要的只是您提供的配置文件。然后，提供商可以将您的域名添加到它的 DNS 中，将其指向它的一个负载平衡器，在操作系统映像中安装正确版本的 Python 和您的所有 Python 依赖项，并启动和运行您的应用程序。该过程可以使向他们推送新的源代码变得容易，并且当面对真实用户时，如果应用程序的新版本似乎会产生错误，也可以使回滚变得容易。您不必创建一个单独的`/etc/init.d`文件或重启一台机器。

Heroku 是 PaaS 领域目前最受欢迎的产品，它为 Python 应用程序提供一流的支持，作为其生态系统的一部分。Heroku 和它的竞争对手对于那些缺乏专业知识或内部时间来设置和管理负载平衡器等工具的小型组织来说尤其有价值。

新兴的 Docker 生态系统是 Heroku 的潜在竞争对手，因为它让你可以在自己的 Linux 机器上创建和运行 Heroku 风格的容器，这比你想要调整的每一行配置都需要在 Heroku 上进行漫长而缓慢的推送和重建要容易得多。

如果您对 PaaS 不太熟悉，那么您可能会期望这样一个服务能够让您的 WSGI-ready Python 应用程序运行起来，而无需任何额外的工作。

事实证明并非如此。在 Heroku 下或 Docker 实例中，您仍然有责任选择 web 服务器。

其原因是，虽然 PaaS 提供商提供了负载平衡、容器化、版本控制配置、容器映像缓存和数据库管理，但他们仍然希望您的应用程序提供 HTTP 互操作性方面的黄金标准:一个开放端口，PaaS 负载平衡器可以连接到该端口并发出 HTTP 请求。为了将您的 WSGI 应用程序或框架转变成一个监听网络端口，您显然需要一个服务器。

一些开发人员对 PaaS 服务将为他们进行负载平衡感到满意，他们选择了一个简单的单线程服务器，并让 PaaS 服务负责根据他们的需要启动尽可能多的应用程序实例。

但是许多开发人员选择 Gunicorn 或它的竞争对手，这样他们的每个容器可以同时运行几个工人。这使得单个容器能够接受多个请求，以防 PaaS 负载平衡器的循环逻辑在其第一个请求完成之前将其返回到同一个容器，如果您的服务提供的一些资源可能需要几秒钟才能呈现，并导致后续请求排队等待，直到第一个请求完成，这将是一个特别的问题。

请注意，大多数 PaaS 提供商并没有为提供静态内容做任何准备，除非您从 Python 提供静态内容，或者将 Apache 或 nginx 添加到您的容器中。虽然您可以设计 URL 空间，使静态资源来自与动态页面完全不同的主机名，并在其他地方托管这些静态资源，但许多架构师更喜欢能够在单个名称空间中混合静态和动态资源。

GET 和 POST 模式以及 REST 问题

Roy Fielding 博士是当前 HTTP 标准的主要作者之一，他的博士论文是关于其设计的。他创造了表述性状态转移(REST) 这个术语来命名当像 HTTP 这样的超文本系统的所有功能都全速运行时出现的架构。他的论文在网上，如果你想查阅的话。[第 5 章](05.html)是他从一系列更简单的概念中建立 REST 概念 的地方。

```py
www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm
```

Fielding 博士明确指出“REST 是由四个接口约束定义的”，他在论文的第 5.1.5 节末尾简要列举了这些约束。

*   资源的识别
*   通过表示操纵资源
*   自我描述的消息
*   作为应用程序状态引擎的超媒体

许多服务设计者希望他们的设计与 HTTP 的设计一致，而不是相反，他们渴望创建能够赢得“RESTful”这一荣誉的服务。菲尔丁博士竭力反对他们中的大多数人不这样做。他们错在哪里？

第一个约束，“资源的标识”，排除了几乎所有传统形式的 RPC。JSON-RPC 和 XML-RPC(参见[第 18 章](18.html))都没有在 HTTP 协议本身的层次上公开资源标识。假设一个客户端想要获取一篇博客文章，更新其标题，然后再次获取该文章以查看差异。如果这些步骤是作为 RPC 方法调用实现的，那么 HTTP 可见的方法和路径如下所示:

```py
POST /rpc-endpoint/ ® 200 OK
POST /rpc-endpoint/ ® 200 OK
POST /rpc-endpoint/ ® 200 OK
```

大概在每个帖子的正文中的某个地方， 每个请求都将类似“post 1022”的内容命名为客户端想要获取或编辑的特定资源。但是 RPC 使得这对于 HTTP 协议来说是不透明的。一个渴望 REST 的接口将使用资源路径来指定哪个 post 被操纵，也许可以命名为`/post/1022/`。

第二个约束，“通过表示操纵资源 ”，禁止设计者指定特定于他们的服务的特定机制，通过该机制标题必须被更新。毕竟，这将要求客户作者每次想了解如何执行更新时都要费力地阅读特定于服务的文档。在 REST 中，不需要学习改变文章标题的特殊技巧，因为文章的表示——不管是使用 HTML、JSON、XML 还是其他格式——是可以表达读或写的唯一形式。要更新一篇博客文章的标题，客户机只需获取当前的表示，更改标题，并将新的表示提交回服务。

```py
GET /post/1022/ ® 200 OK
PUT /post/1022/ ® 200 OK
GET /post/1022/ ® 200 OK
```

获取或更新一打资源必须需要一打往返服务的想法是许多设计者的痛处，也是对架构做出务实例外的强烈诱惑。但是 REST 的优点是读写资源的操作和在 HTTP 协议中暴露有意义的语义之间的对称性。该协议现在可以看出哪些请求是读，哪些是写，如果 GET 响应包括正确的头，那么即使程序在没有浏览器参与的情况下相互通信，缓存和条件请求也变得可能。

显式缓存头将我们带到了第三个约束，“自描述性消息”， ，因为这样的头使得消息是自描述性的。编写客户端的程序员不需要查阅 API 文档来了解，例如，`/post/1022/`是 JSON 格式，或者只有在使用条件请求来确保缓存的副本是最新的情况下才能缓存，而像`/post/?q=news`这样的搜索可以在检索后的 60 秒内直接从缓存中提供。相反，这种知识在传输的每个 HTTP 响应的头中重新声明。

如果实现了 REST 的前三个约束，那么服务对于 HTTP 协议就变得完全透明了，因此对于所有的代理、缓存和客户机都是透明的，它们都是为了利用它的语义而编写的。此外，他们可以这样做，无论服务是为人类消费设计的，提供充斥着表单和 JavaScript 的 HTML 页面(见[第 11 章](11.html))，还是为机器消费设计的，使用简洁的 URL 指向 JSON 或 XML 表示。

但是最后一个限制很少实现。

“作为应用程序状态引擎的超媒体”已经变得足够有争议，需要一个缩写！虽然在菲尔丁博士的论文中没有被单独提出来特别关注，但在随后的文献和辩论中，它已被缩写为“hate OAS”。他通过一篇博客文章“REST API 必须是超文本驱动的”引起了人们对这一约束的注意，这篇文章抱怨了一个所谓的 REST API 的发布，事实上，它没有通过这最后一个约束。

```py
http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven
```

在那里，他将 HATEOAS 约束分解成不少于六个独立的要点，其中最后一点可能是最全面的。它是这样开始的，“除了最初的 URI(书签)和一组适合目标受众的标准化媒体类型之外，REST API 应该在没有任何先验知识的情况下输入。”

这将使几乎所有熟悉的 HTTP 驱动的 API 失去资格。无论是由 Google 还是 GitHub 提供，他们的文档似乎总是以“每个帖子位于一个类似于`/post/1022/`的 URL 中，该 URL 命名了帖子的唯一 ID”来开始对每个资源类型的讨论。通过这种策略，API 已经脱离了完全的 RESTfulness，进入了一个模糊的领域，文档中嵌入的特殊规则，而不是超文本链接，正在引导客户找到正确的资源。

相比之下，完全 RESTful 的 API 只有一个入口点。返回的媒体可能包括一系列表单，其中一个表单可以用来提交一个博客文章 ID 以获取其 URL。然后，服务本身，而不是人类可读的文档，会动态地将“ID 为 1022 的帖子”与特定的路径链接起来。

对 Fielding 博士来说，超文本的这种包含性概念是对旨在使用几十年的服务的一个关键限制，这种服务将能够支持许多代的 HTTP 客户机，以及以后当旧服务的原始用户都早已不在时的数据考古。但是，由于 HTTP 的大多数优势——无状态、冗余和缓存加速——可以通过前三个要素单独获得，因此似乎很少有服务能够应对完全 REST 合规性的挑战。

没有框架的 WSGI

第 7 章展示了几种编写网络服务的模式，其中任何一种都可以用来响应 HTTP 请求。但是很少需要编写自己的低级套接字代码 来讲协议。许多协议细节可以委托给 web 服务器，如果您选择使用 web 服务器，也可以委托给 web 框架。两者有什么区别？

web *服务器*是保存监听套接字、运行`accept()`接收新连接并解析每个传入 HTTP 请求的代码。甚至不需要调用您的代码，服务器就可以处理这样的情况，比如一个客户端连接但从不完成它的请求，以及一个客户端的请求不能被解析为 HTTP。一些服务器还会超时并关闭空闲的客户端套接字，并拒绝路径或报头过长的请求。通过调用已经向服务器注册的 WSGI callable，只有格式良好的完整请求才会被传递到您的框架或代码中。服务器通常会根据自己的权限生成 HTTP 响应代码 (参见第 9 章[)，如下所示:](09.html)

*   `400 Bad Request`:如果传入的 HTTP 请求难以理解或超出您指定的大小限制
*   `500 Server Error`:如果您的 WSGI callable 引发了一个异常，而不是成功运行完成

有两种方法可以构建 WSGI callable，您的 web 服务器将为成功到达并解析的 HTTP 请求调用它。您可以自己构建 callable，也可以编写代码，插入到提供自己的 WSGI callable 的 web 框架中。有什么区别？

一个 web 框架的基本任务是承担*分派*的责任。每个 HTTP 请求在可能的方法、主机名和路径空间中命名一个坐标。您可能只在一个或几个主机名上运行服务， 不是所有可能的主机名。您可能准备好处理 GET 或 POST，但是请求可以命名它想要的任何方法，甚至是一个发明的方法。也许有许多途径 能让你做出有用的回应，但可能更多的途径你做不到。该框架将允许您声明您支持哪些路径和方法，因此该框架可以承担自动回复那些不支持的路径和方法的责任，其状态代码如下:

*   `404 Not Found`
*   `405 Method Not Allowed`
*   `501 Not Implemented`

第 11 章探讨了传统和异步框架如何承担分派的责任，并调查了它们为程序员提供的其他主要特性。但是如果没有它们，您的代码会是什么样子呢？如果您自己的代码直接与 WSGI 接口并负责执行分派，会怎么样？

有两种方法可以构建这样的应用程序:要么阅读 WSGI 规范并自己学习阅读其环境字典，要么使用类似于竞争对手 WebOb 和 Werkzeug 工具包(可从 Python 包索引中获得)所提供的包装器。[清单 10-2](#list2) 展示了在原始 WSGI 环境中工作所必需的冗长编码风格 。

[***清单 10-2***](#_list2) 。用于返回当前时间的原始 WSGI 可调用

```py
#!/usr/bin/env python3
# Foundations of Python Network Programming, Third Edition
# https://github.com/brandon-rhodes/fopnp/blob/m/py3/chapter10/timeapp_raw.py
# A simple HTTP service built directly against the low-level WSGI spec.

import time

def app(environ, start_response):
    host = environ.get('HTTP_HOST', '127.0.0.1')
    path = environ.get('PATH_INFO', '/')
    if ':' in host:
        host, port = host.split(':', 1)
    if '?' in path:
        path, query = path.split('?', 1)
    headers = [('Content-Type', 'text/plain; charset=utf-8')]
    if environ['REQUEST_METHOD'] != 'GET':
        start_response('501 Not Implemented', headers)
        yield b'501 Not Implemented'
    elif host != '127.0.0.1' or path != '/':
        start_response('404 Not Found', headers)
        yield b'404 Not Found'
    else:
        start_response('200 OK', headers)
        yield time.ctime().encode('ascii')
```

在缺乏框架的情况下，您的代码必须做所有的负面工作，确定哪些主机名、路径和方法与您打算提供的服务不匹配。为了在主机名`127.0.0.1`处提供路径`/`的 GET，您必须为您能够检测到的请求参数组合的每个偏差返回一个错误。当然，对于像这样的小服务来说，不简单地接受任何主机名似乎是愚蠢的。但我们假装我们可能会成长为一个大型服务，在几十个不同的主机名上提供不同的内容，所以我们小心翼翼地关注它们。

请注意，如果客户端提供类似于`127.0.0.1:8000`的主机头，您需要负责拆分主机名和端口。此外，您必须在字符`?`上拆分路径，以防 URL 的末尾出现类似`/?name=value`的查询字符串。(按照惯例，清单假设您希望忽略无关的查询字符串，而不是返回`404 Not Found`。)

接下来的两个清单演示了如何通过第三方库使这些原始的 WSGI 模式变得更容易，这些库可以用标准的“pip”安装工具 (参见[第 1 章](01.html))。

```py
$ pip install WebOb
$ pip install Werkzeug
```

最初由 Ian Bicking 编写的 WebOb“Web Object”库 ，是一个轻量级的对象接口，它包装了一个标准的 WSGI 字典，以提供对其信息的更方便的访问。[清单 10-3](#list3) 展示了它是如何从前面的例子中删除几个常见模式的。

[***清单 10-3***](#_list3) 。用 WebOb 编写的 WSGI Callable，用于返回当前时间

```py
#!/usr/bin/env python3
# Foundations of Python Network Programming, Third Edition
# https://github.com/brandon-rhodes/fopnp/blob/m/py3/chapter10/timeapp_webob.py
# A WSGI callable built using webob.

import time, webob

def app(environ, start_response):
    request = webob.Request(environ)
    if environ['REQUEST_METHOD'] != 'GET':
        response = webob.Response('501 Not Implemented', status=501)
    elif request.domain != '127.0.0.1' or request.path != '/':
        response = webob.Response('404 Not Found', status=404)
    else:
        response = webob.Response(time.ctime())
    return response(environ, start_response)
```

WebOb 已经实现了两种常见的模式，一种是从主机头中单独检查主机名，而不检查任何可能附加的可选端口号，另一种是查看没有尾随查询字符串的路径。它还提供了一个了解所有内容类型和编码的`Response`对象——默认为纯文本——因此您只需要为响应体提供一个字符串，WebOb 会处理所有其他事情。

![Image](img/sq.jpg) **注意** WebOb 有一个特性使它在众多 Python HTTP 响应对象实现中几乎是独一无二的。WebOb `Response`类允许您将像`text/plain; charset=utf-8`这样的内容类型头的两部分视为两个独立的值，并将其公开为独立的属性`content_type`和`charset`。

就纯 WSGI 编码而言，没有 WebOb 受欢迎，但也受到忠实粉丝的支持的是阿明·罗纳彻的 Werkzeug 库，这也是他的 Flask 框架的基础(在第 11 章中讨论)。它的请求和响应对象是不可变的，而不是允许底层的 WSGI 环境被改变。[清单 10-4](#list4) 展示了在这种情况下它与 WebOb 的不同之处。

[***清单 10-4***](#_list4) 。用 Werkzeug 编写的 WSGI Callable，用于返回当前时间

```py
#!/usr/bin/env python3
# Foundations of Python Network Programming, Third Edition
# https://github.com/brandon-rhodes/fopnp/blob/m/py3/chapter10/timeapp_werkz.py
# A WSGI callable built using Werkzeug.

import time
from werkzeug.wrappers import Request, Response

@Request.application
def app(request):
    host = request.host
    if ':' in host:
        host, port = host.split(':', 1)
    if request.method != 'GET':
        return Response('501 Not Implemented', status=501)
    elif host != '127.0.0.1' or request.path != '/':
        return Response('404 Not Found', status=404)
    else:
        return Response(time.ctime())
```

Werkzeug 甚至没有让您记住 WSGI callable 的正确签名，而是给了您一个装饰器，将您的函数切换到一个简单得多的调用约定。您自动接收一个 Werkzeug `Request`对象作为您唯一的参数，并被赋予简单地返回一个`Response`对象的特权——库将为您处理所有其他事情。

用 WebOb 编写的代码中唯一轻微的倒退是，您必须自己将主机名(如`127.0.0.1:8000`)一分为二，而不是用一个方便的方法将它们拆分出来。尽管如此，有了这个小小的区别，这两个库正在做相同的工作，让您在比 WSGI 约定更高的层次上谈论 HTTP 请求和响应。

通常，作为一名开发人员，不值得花时间在这种低水平上操作，而不是使用 web 框架。但是，如果您想在将传入的 HTTP 请求交给 web 框架进行处理之前对它们进行一些转换，那么用原始的 WSGI 进行编写确实很方便。如果您正在用 Python 语言编写定制的反向代理或另一个纯 HTTP 服务，那么直接的 WSGI 应用程序也可能是合适的。

可以认为原始的 WSGI 调用在 Python 编程中的地位与正向代理和反向代理在整个 HTTP 生态系统中的地位相同。它们更适合于过滤、规范化和调度请求等低级任务，而不是在特定的主机名和路径上提供资源(您希望以 HTTP 服务的形式提供)。关于 WSGI callable 如何在将请求传递给下一个 callable 之前修改请求的详细信息，请阅读规范或参考 WebOb 或 Werkzeug 文档中给出的编写中间件的模式。

摘要

Python 内置了一个`http.server`模块，当从命令行启动时，它提供当前工作目录下的文件。虽然在紧急情况下或检查直接存储在磁盘上的网站时很方便，但该模块很少再用于创建新的 HTTP 服务。

Python 中正常的同步 HTTP 通常由 WSGI 标准来协调。服务器解析传入的请求以产生一个充满信息的字典，应用程序在返回 HTTP 头和可选的响应体之前检查字典。这使您可以将任何 web 服务器用于任何标准的 Python web 框架。

异步 web 服务器是 WSGI 生态系统的一个例外。因为 WSGI 可调用程序不是完整的协同例程，所以每个异步 HTTP 服务器都必须采用自己的约定，以便在自定义框架中编写服务。在这种情况下，服务器和框架是捆绑在一起的，通常不可能有更广泛的互操作性。

从 Python 提供 HTTP 服务有四种流行的架构。独立服务器可以使用 Gunicorn 或其他纯 Python 服务器实现(如 CherryPy)来运行。其他架构师选择通过`mod_wsgi`在 Apache 的控制下运行他们的 Python。然而，现在反向代理的概念是所有类型的 web 服务的首选模式，许多架构师发现将 Gunicorn 或另一个纯 Python 服务器直接放在 nginx 或 Apache 后面作为一个单独的 HTTP 服务更简单，他们可以将资源动态生成的路径请求转发给该服务。

然后，这些模式中的任何一个都可以在前面放置清漆或另一个反向代理，以提供缓存层。缓存实例可以位于同一机房(甚至同一台机器)的本地，但是它们通常在地理上是分散的，以便更接近特定的 HTTP 客户端群体。

在 PaaS 提供商上安装您的服务通常会提供缓存、反向代理和负载平衡作为服务的一部分。您的应用程序所要负责的就是响应 HTTP 请求，通常使用一个简单的容器，比如 Gunicorn。

关于服务的一个常见问题是它们是否是 RESTful 的:它们是否具有标准作者 Roy Fielding 博士所描述的 HTTP 设计意图的特性。虽然今天的许多服务已经远离了隐藏服务正在做什么的不透明的方法和路径选择，但很少有人采纳 Fielding 的完整愿景，即通过超文本而不是程序员指导的文档来支持语义。

小型服务，尤其是那些过滤或转换 HTTP 请求的服务，可以写成 WSGI callable。WebOb 或 Werkzeug 这两种竞争解决方案都可以将原始的 WSGI 环境简化为更容易使用的`Request`对象，并且它们还可以通过它们的`Response`类帮助您构建答案。

在下一章中，通过学习万维网——使互联网闻名于世的大量互连文档，您将超越一般 HTTP 服务和低级 WSGI 编程。您将学习如何获取和处理超文本文档，并使用流行的 web 框架自己实现网站。