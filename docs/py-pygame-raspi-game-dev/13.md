# 13.文件输入和输出

能够从磁盘上保存和加载文件是游戏开发的一个重要部分。等级、玩家精灵等资产。，是从存储在磁盘上的文件中加载的。进度会保存到磁盘上，以便玩家可以从上次玩的地方继续游戏。

在这一节中，我们将了解文件输入和输出的基础知识，并介绍一种存储有序数据的方法，如我们在第 [7](07.html) 章中介绍的字典容器。

要保存和加载数据，您的脚本必须导入“os”(操作系统的缩写)模块来访问磁盘上的文件。

## 从磁盘读取文件

该程序从磁盘读取程序的源代码，并将内容显示在屏幕上:

```
import os

f = open('readmyself.py', 'r')
for line in f:
    print(line)

f.close() # ALWAYS close a file that you open

```

open 关键字的第一个参数是我们想要访问的文件。第二个参数是我们希望访问文件的模式:

*   r '–读取文件的内容

*   w '–将数据写入文件

*   ' a '–将数据追加(添加到现有文件的末尾)到文件中

对于 read，缺省值是“r ”,因此我们可以在这个实例中省略这个参数。最后，这仅适用于文本模式。这意味着如果我们传递一个' \n '，它将被转换为平台特定的行尾。在 UNIX 和 Raspbian 上是' \n '，但在 Windows 上是' \r\n '。

您可以将“b”添加到访问模式参数中(例如，“rb”或“wb”)，以指定二进制模式。这种模式通常用于图像或复杂的保存数据。

open 关键字返回一个文件对象。我们可以用它从文件中读取信息，或者写出数据，这取决于我们想做什么。

> 不要忘记在你打开的任何文件上调用 close()。

在“pygamebook”文件夹中的“ch13”文件夹中，将程序保存为“readmyself.py ”,然后运行它。程序将显示内容，但它会在每行代码之间添加空行:

```
import os

f = open('readmyself.py', 'r')

for line in f:

    print(line)

f.close()

```

它们不在文件中，那么它们来自哪里呢？嗯，在磁盘上，每一行都以一个换行符' \n '结束，print 关键字添加了自己的换行符，使得这些空行。

要解决这个问题，您可以添加。rstrip('\n ')到每个打印，就像这样:

```
print(line.rstrip('\n'))

```

函数的作用是:返回一个字符串的副本，其中所有指定的字符都已从字符串的末尾删除。默认情况下，这都是空白字符，但在这种情况下，我们只想去掉'换行'字符。

## 将数据写入文件

将文本写入文件使用 file 对象的 write 方法。下一个程序获取一个高分列表，并将其写入一个文本文件。

```
players = ['Anna,10000', 'Barney,9000', 'Jane,8000', 'Fred,7000']

```

该列表包含以逗号分隔的运动员姓名及其分数。

```
f = open('highscores.txt', 'w')

```

该文件以“写入”模式打开，因为我们正在向该文件发送数据。该文件的名称可以是您想要的任何名称，但它应该是有意义的名称。甚至不一定要以. txt 结尾。

```
for p in players:
    f.write(p + '\n')

```

列表中的所有值都被循环，并且 File 对象的 write 方法被调用，列表项后跟一个“\n”。如果我们不包括这一点，文件将把所有的名字和分数混杂在一行中。

```
f.close()

```

你一定要记得在用完文件后把它关上。当我写一个读/写文件时，我总是先写开始和结束行，然后写我想对文件做什么。这意味着我永远不会忘记关闭文件。

在磁盘上找到“highscores.txt”文件，并输入以下命令:

```
$ more highscores.txt

```

您应该会看到以下输出:

```
Anna,10000
Barney,9000
Jane,8000
Fred,7000

```

虽然这是我们想要的，但是数据的内部结构是错误的。我们通常不会将玩家的名字和他们的分数存储为一个字符串。相反，我们使用某种容器。

## 向文件中读写容器

有两种方法可以将复杂数据读写到文件中。将举例说明的第一种方法是手动编写自己的格式。第二个是使用 JSON 格式来组织我们的数据，以便在文件中维护结构。

将内存中的数据写入文件称为序列化，将数据从文件读回内存称为反序列化。将数据写入磁盘的代码称为序列化程序，从磁盘读取数据的代码称为反序列化程序。我们将研究如何编写我们自己的序列化器和反序列化器，然后使用 Python 提供的 JSON 库来简化复杂数据的读写。

> 将数据从内存写入文件称为串行化

> 从文件中读取数据到内存被称为反序列化

通常，当您拥有专有的数据结构或格式时，或者如果您想要混淆(扰乱和混淆)您正在存储的内容以掩饰您正在做的事情，防止潜在的黑客攻击您的游戏时，您将编写自己的序列化方法。

### 编写自己的序列化程序

玩家和他们的分数是相关的，但是不应该一起存储在一个字符串中。相反，高分表将是一个字典，包含玩家的姓名(键)和他们的分数(值):

```
players = { 'Anna': 10000, 'Barney': 9000, 'Jane': 8000, 'Fred': 7000 }

```

我们可以使用“for”关键字遍历字典中的值，并依次获得每个元素的键。有了密钥，我们可以像这样解锁值:

```
for p in players:
    print(p, players[p])

```

这将显示以下(几乎熟悉的)输出:

```
Anna 10000
Barney 9000
Jane 8000
Fred 7000

```

创建一个名为“serializer.py”的新程序，并输入以下代码:

```
def serialize(fileName, players):
    f = open(fileName, 'w')

    for p in players:
        f.write(p + ',' + str(players[p]) + '\n')

    f.close()

```

序列化方法有两个参数。第一个是高分表将被写入的文件的名称，第二个是包含球员姓名和分数的字典。将分数包装在 str()函数中会将值转换为字符串，这样我们就可以使用字符串串联(将两个或更多的字符串加在一起)。

```
players = { 'Anna': 10000, 'Barney': 9000, 'Jane': 8000, 'Fred': 7000 }
serialize('highscores.txt', players)

```

“玩家”字典是在调用 serialize 函数的上面创建的——也不需要在函数中添加“global ”,因为代码不会改变“玩家”字典，我们将它作为参数传递。

这为我们提供了之前的格式，因为相同的信息被写入文件:

```
Anna,10000
Barney,9000
Jane,8000
Fred,7000

```

现在，我们如何从文件中将数据读回内存呢？

### 编写自己的反序列化程序

反序列化有一个转折，因为数据是字符串格式的——我们毕竟是在写入字符串文件——并且名称和分数由逗号(，)分隔。逗号分隔的值非常常见，有一个名为“split()”的函数可以更容易地分隔字符串值。拆分字符串会返回字符串数组:

*‘我的，弦，这里’*会分裂成*[‘我的’，‘弦’，‘这里’]*

为了确保我们的分数存储在正确的数据类型中，使用了“int()”函数。将所有这些放在一起，我们的反序列化函数如下所示:

```
def deserialize(fileName, players):
    f = open(fileName, 'r')

    for entry in f:
        split = entry.split(',')
        name = split[0]
        score = int(split[1])

        players[name] = score

```

该函数有两个参数；第一个是包含高分数据的文件名，第二个是玩家的字典。

从文件中读入每一行，并使用逗号(，)作为分隔符调用 split()函数。这将把数值分成球员姓名和分数。向字典中添加一个条目，其中名称是键，整数版本的分数是值。

```
players = { }
deserialize('highscores.txt', players)
print(players)

```

“玩家”变量被设置为空白字典。调用函数并显示内容:

```
{'Anna': 10000, 'Barney': 9000, 'Jane': 8000, 'Fred': 7000}

```

## 数据

JSON 代表 JavaScript 对象符号，是系统序列化和反序列化数据以便存储或通过网络传输的常用方法。JSON 对象的格式非常类似于 Python 字典的格式。事实上，它们几乎完全相同。这是格式化为 JSON 字符串的高分表:

```
{"Anna": 10000, "Barney": 9000, "Jane": 8000, "Fred": 7000}

```

怪异，对吧！？

Python 提供了“json”模块，通过“json”对象的“dump()”和“load()”方法使读取和写入 JSON 对象变得更加容易。

要使用 JSON，您必须将下面一行添加到程序的顶部，同时导入其余的内容:

```
import json

```

### JSON 序列化

JSON 序列化在一行中完成。回顾一下之前的 high score 序列化程序，我们可以重写“serialize()”函数:

```
import json

def serialize(fileName, players):
    f = open(fileName, 'w')
    json.dump(players, f)
    f.close()

```

我们不必写出自己的格式，而是让“json”对象来完成繁重的工作。“dump()”方法将对象作为 JSON 格式的字符串写出到文件“f”中，不管它是什么。

```
players = { 'Anna': 10000, 'Barney': 9000, 'Jane': 8000, 'Fred': 7000 }
serialize('jsonhiscore.txt', players)

```

调用“serialize()”方法的部分不会更改；它仍然传入两个值，但是这次我改变了文件的位置。方便的东西功能！

要查看文件的内容:

```
$ more jsonhiscore.txt

```

这将显示以下内容:

```
{"Anna": 10000, "Barney": 9000, "Jane": 8000, "Fred": 7000}

```

### JSON 反串行化器

' deserialize()'函数将略有变化，因为我们将返回' player '字典，所以我们不需要将它作为参数传入。“deserialize()”方法程序如下所示:

```
import json

def deserialize(fileName):
    f = open(fileName, 'r')
    players = json.load(f)
    f.close()

    return players

```

“json”对象上的“load()”方法在文件句柄中被调用。该函数获取文件的字符串内容，并构建适当的 Python 数据结构。这个函数的输出存储在变量“players”中，并返回给调用者。

```
players = deserialize('jsonhiscore.txt')
print (players)

```

在函数调用站点，我们可以看到“deserialize()”方法丢失了一个参数，但获得了一个返回值。返回值是一个字典，由“print()”的输出来演示:

```
{'Anna': 10000, 'Barney': 9000, 'Jane': 8000, 'Fred': 7000}

```

## 处理错误

文件访问有时可能是一个棘手的行为，因为文件可能会被系统锁定(病毒检查程序)，或者您期望的文件可能不存在。为了解决这个问题，你可以使用结构化错误处理(简称 SEH)。你的程序不会崩溃，但是你应该优雅地处理这个事件。

在“ch13”文件夹中创建一个名为“filenotfound.py”的新程序。它演示了一个可以用来确定文件是否存在的函数。该函数尝试读取文件。如果成功，函数返回 True，否则返回 False:

```
import os

def fileExists(fileName):
    try:
        f = open(fileName, 'r')
        f.close()
        return True
    except IOError:
        return False

```

我们想要“尝试”执行的代码被放在“try”块中。如果出现问题，就会运行“except”中的代码。“try”块中的代码一旦遇到问题就会停止，因此，如果您有大量的处理，其中一些代码可能无法执行，因此最好使“try”块尽可能短。

```
print (fileExists('filenotfound.py'))
print (fileExists('this-does-not-exist.txt'))

```

这个程序的输出是

```
True
False

```

## 结论

现在，您应该了解如何读取和写入文件。完成后记得关闭文件。不要让文件打开超过必要的时间；打开它，做你需要做的，然后尽快关闭它。

序列化是将内存中变量的内容写入磁盘上文件的过程。写入磁盘的代码被称为*串行化器*。反序列化是读取磁盘上文件的内容并从中构造内存中对象的过程。从磁盘读取数据的代码被称为*解串器*。

您可以编写自己的序列化/反序列化方法，但是使用像 JSON 这样的预定格式来执行这些操作通常更容易。

磁盘访问有时容易出错，因为您调用的是操作系统。有时文件可能正在使用中，您将无法访问它。确保使用*结构化错误处理*或简称 SEH 来安全地访问文件。