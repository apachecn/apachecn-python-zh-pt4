# 18.Python 网络自动化实验室:Cisco IOS 升级迷你工具开发

这一章是这本书的倒数第二章，你将完成十个应用程序。在下一章中，您将把它们变成一个单一的、功能性的 IOS 升级应用程序。本章中开发的工具包括以下内容:连接性验证工具、用户名和密码交互式收集工具、文件信息读取工具、用于 Linux 服务器上文件完整性的 MD5 检查工具、网络设备的配置备份工具、IOS 文件上传工具、路由器闪存 IOS MD5 检查工具、用于更改应用程序流的用户输入工具以及带有后检查工具的路由器重新加载工具。在本章中，您还将测试这些工具并验证它们的功能。

![../images/492721_1_En_18_Chapter/492721_1_En_18_Figa_HTML.jpg](../images/492721_1_En_18_Chapter/492721_1_En_18_Figa_HTML.jpg)

## 思科 IOS 升级应用开发

现在是时候开发一系列小的 Python 工具(应用程序)来使用了，就像小的乐高积木一样，在下一章中，创建一个更复杂和完整的网络自动化应用程序。

为了开始开发第一个应用程序(工具)，让我们讨论一下如何将信息输入到脚本中，以便转换成 Python 变量和参数。有三种方法可以将用户和设备信息输入到我们的 Cisco IOS XE 升级应用程序中。首先，我们可以创建一个交互式信息收集器工具，从用户那里交互式地收集用户和设备信息。其次，我们可以交互地收集用户登录信息，但从文本文件、Excel 文件、CSV 文件或数据库等文件中读取设备信息。第三，我们可以从文件(文本、Excel 或 CSV)或数据库中获取所有信息。从不安全的文本文件中读取用户名和密码的最大问题是，它可能是生产环境中的一个重大安全威胁。您必须考虑使用加密的密码库，这将保护您在网络上的凭证。这个话题超出了本书的主题，留给你去研究；我们将用一个更简单的用户交互工具来代替它。

为了利用我们在第 [1](01.html) 到 [17](17.html) 章节中学到的一切，让我们使用第二种方法向应用程序提供信息。在本例中，我们将从交互式用户会话中获取用户凭证，并使用`pandas`模块从 CSV 文件中获取设备信息。

## A 部分:预检查工具开发连通性验证工具

网络工程师不断努力保持各种 IP 设备、应用程序和用户连接到他们的网络，尽可能避免或减少网络中断。甚至在网络可编程性这个词出现之前，每个人都在谈论代码基础设施或网络自动化。每个组织都希望其托管网络安全稳定。当我们编写脚本化的网络自动化应用程序时，我们必须将网络稳定性和安全性放在第一位。我们总是需要参考网络和安全方面的最佳实践。当你接触到网络和编程方面的最佳实践时，你就可以编写良好的网络自动化应用程序。

我们在这里要开发的第一个迷你工具是网络连接工具。在前面的章节中已经介绍了一个类似的工具，但是我们将重构代码并使它变得更好。在编写了一个独立的网络连通性检查工具后，您将能够测试服务器(`ubuntu20s1`)和两台路由器(`csr1000v-1`和`csr1000v-2`)之间的通信。每个网络工程师都在工作中使用 ICMP (ping)和 socket (port)扫描，您的应用程序将使用 Python 代码行代替终端控制台上的手动任务。这里，我们将通过一遍又一遍地重复(代码重构)相同的代码来开发 ICMP 应用程序。本章中开发的所有应用程序将直接整合到最后一章中的最终 Cisco IOS 升级应用程序中。

![../images/492721_1_En_18_Chapter/492721_1_En_18_Figb_HTML.gif](../images/492721_1_En_18_Chapter/492721_1_En_18_Figb_HTML.gif)请注意，在现实世界中没有人会为你写这段代码，所以你必须习惯于准确快捷地自己写每一行代码。与本书中的其他代码一样，对重要代码行的解释出现在每一行的`#`标记之后。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 使用 PuTTY SSH 到您的 Python automation server ( `ubuntu20s1`)服务器，并编写以下代码。您将编写一个 ICMP 脚本，然后编写一个套接字脚本来测试服务器和路由器之间的网络连通性。然后运行并验证脚本，并修改它们以改变脚本的流程。这里我们将只使用本地的`os`和`socket`模块；虽然`scapy`模块是一个优秀的外部工具，但是本地工具可以实现我们想要的，所以您将使用开箱即用的东西。 |
|   | `pynetauto@ubuntu20s1:~$` `mkdir my_tools` |
|   | `pynetauto@ubuntu20s1:~$` `cd my_tools` |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `mkdir tool1_ping` |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `cd tool1_ping` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `nano ping_tool1.py` |
|   | `ping_tool1.py` |
|   | `import os` |
|   | `device_list = ['192.168.183.111', '192.168.183.222']` |
|   | `for ip in device_list:` `# for loop for IP address` |
|   | `if len(ip) != 0:` `# Only run this part of script if the list is not empty` |
|   | `print(f'Sending icmp packets to {ip}')` `# Informational` |
|   | `resp = os.system(f'ping -c 3 {ip}')` `# send ICMP packets 4 times` |
|   | `if resp == 0:` `# If on the network (pingable), run this script` |
|   | `print(f'{ip} is on the network.')` `# Informational` |
|   | `print('-'*80)` `# Line divider` |
|   | `else:` |
|   | `print(f'{ip} is unreachable.')` `# Informational` |
|   | `print('-'*80)` `# Line divider` |
|   | `else:` |
|   | `exit()` `# If not on the network, exit application` |
| **2** | 如果您的服务器可以与两台路由器通信并运行前面的脚本，您应该在 SSH 控制台上看到类似的结果。运行`python3 ping_tool1.py`，结果将如下所示: |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `python3 ping_tool1.py` |
|   | `Sending icmp packets to 192.168.183.111` |
|   | `PING 192.168.183.111 (192.168.183.111) 56(84) bytes of data.` |
|   | `64 bytes from 192.168.183.111: icmp_seq=2 ttl=255 time=1.63 ms` |
|   | `64 bytes from 192.168.183.111: icmp_seq=3 ttl=255 time=1.60 ms` |
|   | `64 bytes from 192.168.183.111: icmp_seq=4 ttl=255 time=1.58 ms` |
|   | `--- 192.168.183.111 ping statistics ---` |
|   | `4 packets transmitted, 3 received, 25% packet loss, time 3032ms` |
|   | `rtt min/avg/max/mdev = 1.581/1.603/1.628/0.019 ms` |
|   | `192.168.183.111 is on the network.` |
|   | `--------------------------------------------------------------------------------` |
|   | `[...omitted for brevity]` |
| **3** | 现在，让我们将`device_list = ['192.168.183.111', '192.168.183.222']`修改为`device_list = ['10.10.10.1',  '192.168.183.111', '192.172.1.33',  '192.168.183.222']`。添加到列表中的两个虚拟 IP 地址并不存在，您将使用这个新列表来迭代和开发您的脚本。我们将添加一个特性，所以如果设备是可达的(pingable)，脚本将把 IP 地址附加到一个新的`reachable_ips`列表中。如果 IP 地址不可达，则将 IP 地址添加到一个名为`unreachable_ips`的新列表中。生产网络中正在发生许多事情，我们必须应对这些情况。假设您一次只在一台设备上工作。在这种情况下，您只关心一台设备，因此如果无法远程访问该设备，您就无法将该设备升级到较新的 IOS 版本，直到您对连接问题进行故障排除。但是，当您同时处理许多设备时，如果一个或两个设备离线，您会想知道哪些设备不可访问，但同时您会想继续对其余设备进行 IOS 升级。我们将使用 ICMP 工具来区分可到达的 IP 地址和不可到达的 IP 地址，并将它们保存到两个单独的列表中。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `cp ping_tool1.py ping_tool2.py` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `nano ping_tool2.py` |
|   | 修改代码: |
|   | `ping_tool2.py` |
|   | `import os` |
|   | `device_list = ['10.10.10.1',  '192.168.183.111', '192.172.1.33',  '192.168.183.222']` |
|   | `reachable_ips = []` `# Define a blank list for on the network ips` |
|   | `unreachable_ips = []` `# Define a blank list for off the network ips` |
|   | `for ip in device_list:` |
|   | `if len(ip) != 0:` |
|   | `print(f'Sending icmp packets to {ip}')` |
|   | `resp = os.system(f'ping -c 3 {ip}')` |
|   | `if resp == 0:` |
|   | `reachable_ips.append(ip)` `# Append ip to reachable_ips list` |
|   | `print('-'*80)` |
|   | `else:` |
|   | `unreachable_ips.append(ip)` `# Append ip to unreachable_ips list` |
|   | `print('-'*80)` |
|   | `else:` |
|   | `exit()` |
|   | `print("Reachable IPs: ", reachable_ips)` `# Print result 1` |
|   | `print("Unreachable IPs: ", unreachable_ips)` `# Print result 2` |
| **4** | 现在运行`python3 ping_tool2.py`命令，您应该会得到与此类似的结果: |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `python3 ping_tool2.py` |
|   | `Sending icmp packets to 10.10.10.1` |
|   | `PING 10.10.10.1 (10.10.10.1) 56(84) bytes of data.` |
|   | `--- 10.10.10.1 ping statistics ---` |
|   | `3 packets transmitted, 0 received, 100% packet loss, time 2035ms` |
|   | `--------------------------------------------------------------------------------` |
|   | `Sending icmp packets to 192.168.183.111` |
|   | `PING 192.168.183.111 (192.168.183.111) 56(84) bytes of data.` |
|   | `64 bytes from 192.168.183.111: icmp_seq=1 ttl=255 time=1.85 ms` |
|   | `64 bytes from 192.168.183.111: icmp_seq=2 ttl=255 time=1.58 ms` |
|   | `64 bytes from 192.168.183.111: icmp_seq=3 ttl=255 time=1.66 ms` |
|   | `--- 192.168.183.111 ping statistics ---` |
|   | `3 packets transmitted, 3 received, 0% packet loss, time 2004ms` |
|   | `rtt min/avg/max/mdev = 1.583/1.694/1.845/0.110 ms` |
|   | `--------------------------------------------------------------------------------` |
|   | `[...omitted for brevity]` |
|   | `--------------------------------------------------------------------------------` |
|   | `Reachable IPs:  ['192.168.183.111', '192.168.183.222']` |
|   | `Unreachable IPs:  ['10.10.10.1', '192.172.1.33']` |
|   | 因此，正如所料，可到达的 IP 地址是 192.168.183.111 和 192.168.183.222。该列表可用于继续运行脚本的其余部分。此外，无法到达的 IP 地址是 10.10.10.1 和 192.172.1.33。这是一个预期的结果。但是，在生产中，如果这些设备应该在网络上，那么您将需要排除连接问题，并在连接问题解决后执行更改。 |
| **5** | 作为变量的列表是有用的，但是这些信息只有在脚本运行并且您坐在控制台前观看这些信息时才会显示。注意，服务器的随机访问内存只是临时的，Python 的`print`语句只是为了方便用户使用。实际的 Python 脚本并不使用屏幕上显示的内容。如果我们想在任务调度器(如`cron`)成功运行脚本时访问这些信息，您必须将这些信息写入并保存到一个文件中。让我们将两个列表写入两个单独的文件中，以备后用。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `cp ping_tool2.py ping_tool3.py` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `nano ping_tool3.py` |
|   | `ping_tool3.py` |
|   | `import os` |
|   | `device_list = ['10.10.10.1',  '192.168.183.111', '192.172.1.33',  '192.168.183.222']` |
|   | `# reachable_ips = []` `# Add '#' to make this line inactive` |
|   | `f1 = open('reachable_ips.txt',  'w+')` `# Create and open reachable_ips.txt file to write on` |
|   | `# unreachable_ips = []` `# Add '#' to make this line inactive` |
|   | `f2 = open('unreachable_ips.txt', 'w+')` `# Create and open unreachable_ips.txt file to write on` |
|   | `for ip in device_list:` |
|   | `if len(ip) != 0:` |
|   | `print(f'Sending icmp packets to {ip}')` |
|   | `resp = os.system('ping -c 3 ' + ip)` |
|   | `if resp == 0:` |
|   | `#reachable_ips.append(ip)` `# Add '#' to make this line inactive` |
|   | `f1.write(f'{ip}\n')` `# write ip address to each line of reachable_ips.txt file` |
|   | `print('-'*80)` |
|   | `else:` |
|   | `#unreachable_ips.append(ip)` `# Add '#' to make this line inactive` |
|   | `f2.write(f'{ip}\n')` `# write ip address to each line of unreachable_ips.txt file` |
|   | `print('-'*80)` |
|   | `else:` |
|   | `exit()` |
|   | `f1.close()` `# Close f1 file` |
|   | `f2.close()` `# Close f2 file` |
| **6** | 运行原始代码的第三次迭代，应该会产生两个文本文件，一个包含可到达的 IP 地址，另一个包含不可到达的 IP 地址。注意，为了节省空间，省略了输出。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `ls` |
|   | `ping_tool1.py  ping_tool2.py  ping_tool3.py` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `python3 _ping_tool3.py` |
|   | `[... output omitted for brevity]` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `ls` |
|   | `ping_tool1.py  ping_tool2.py  ping_tool3.py  reachable_ips.txt  unreachable_ips.txt` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `more reachable_ips.txt` |
|   | `192.168.183.111` |
|   | `192.168.183.222` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `more unreachable_ips.txt` |
|   | `10.10.10.1` |
|   | `192.172.1.33` |
|   | 因此，您的工具可以测试网络连接，并在此阶段对在线和离线设备之间的 IP 地址进行分类。此外，IP 地址可以保存(记录)在各自的文件中。 |
| **7** | 我们现在将把前面脚本中使用的 IP 地址列表转换成一个文件`ip_addresses.txt`。这将允许您更有效地添加和管理大量 IP 地址，而不是读取和输入列表中的每个 IP 地址。我们从文本文件中读取 IP 地址，但我们也可以直接从 Excel 或 CSV 文件中读取 IP 地址。当我们从 Excel 或 CSV 中读取信息时，我们可以将数据转换为二维数据。信息同时变得更有意义和更有力量。 |
|   | 注意最后一个 IP 地址 192.168.183.133 是 GNS3 `R1`的路由器 IP 地址，所以你需要从 GNS3 的`cmllab-devops`项目启动`R1`。 |
| **8** | 给 GNS3 加电，启动 IOS 路由器，`R1`。创建一个访问列表来阻止任何到此设备的入站 SSH 流量。创建一个访问列表，并将其应用于`R1`的 FastEthernet 0/0。另外，您可以在`vty 0 15`线上启用 Telnet 和 SSH。 |
|   | `R1#` `ping 192.168.183.132` |
|   | `R1#` `configure terminal` |
|   | `R1(config)#` `access-list 100 deny tcp any any eq 22` |
|   | `R1(config)#` `access-list 100 permit ip any any` |
|   | `R1(config)#` `interface f0/0` |
|   | `R1(config-if)#` `ip access-group 100 in` |
|   | `R1(config)#` `line vty 0 15` |
|   | `R1(config-line)#` `transport input telnet ssh` |
|   | `R1(config-line)#` `do write memory` |
| **9** | 现在创建并编写一个套接字工具，如下所示，并运行脚本。结果应该类似于这里显示的内容。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `nano socket_tool.py` |
|   | `socket_tool.py` |
|   | `import socket` |
|   | `device_list = ['10.10.10.1', '192.168.183.111', '192.172.1.33', '192.168.183.222', '192.168.183.133']` |
|   | `for ip in device_list:` |
|   | `print("-"*80)` |
|   | `for port in range (22, 24):` |
|   | `destination = (ip, port)` |
|   | `try:` |
|   | `with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:` |
|   | `s.settimeout(3)` |
|   | `connection = s.connect(destination)` |
|   | `print(f"On {ip}, SSH port {port} is open!")` |
|   | `except:` |
|   | `print(f"On {ip}, SSH port {port} is closed.")` |
|   | 当您运行前面的脚本时，您应该会得到与这里所示类似的响应。如果是的话，那么是时候将这个脚本集成到`ping_tool3.py`脚本中了。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `python3 socket_tool.py` |
|   | `--------------------------------------------------------------------------------` |
|   | `On 10.10.10.1, SSH port 22 is closed.` |
|   | `On 10.10.10.1, SSH port 23 is closed.` |
|   | `--------------------------------------------------------------------------------` |
|   | `On 192.168.183.111, SSH port 22 is open!` |
|   | `On 192.168.183.111, SSH port 23 is closed.` |
|   | `--------------------------------------------------------------------------------` |
|   | `On 192.172.1.33, SSH port 22 is closed.` |
|   | `On 192.172.1.33, SSH port 23 is closed.` |
|   | `--------------------------------------------------------------------------------` |
|   | `On 192.168.183.222, SSH port 22 is open!` |
|   | `On 192.168.183.222, SSH port 23 is closed.` |
|   | `--------------------------------------------------------------------------------` |
|   | `On 192.168.183.133, SSH port 22 is closed.` |
|   | `On 192.168.183.133, SSH port 23 is open!` |
| **10** | 现在让我们将这两个工具结合起来，增强`ping`工具来发送 ICMP 消息，然后检查 Telnet 或 SSH 连接的开放端口。完成此工具后，您可以将其用作独立工具来检查连接和端口状态。 |
|   | 我们首选的连接方法是 SSH 连接。当脚本运行时，它将创建三个文件，第一个包含 SSH 连接的 IP 地址，第二个包含 Telnet 连接的 IP 地址，第三个包含无法到达的 IP 地址和关闭端口的日志。 |
|   | 我们将使用从`ip_addresses.txt`文件中读取的信息替换`device_list`，因此继续使用 IP 地址创建文件。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `nano ip_addresses.txt` |
|   | `ip_addresses.txt` |
|   | `10.10.10.1` |
|   | `192.168.183.111` |
|   | `192.172.1.33` |
|   | `192.168.183.222` |
|   | `192.168.183.133` |
|   | 复制`ping_tool3.py`，保存为`ping_tool4.py`，然后将上一步的`socket_tool.py`合并为`ping_tool4.py`。一旦你将两个脚本合并成一个文件，它应该看起来像`ping_tool4.py`。这里，我们打破了编写更多 Pythonic 代码的规则，因为我们的代码使用了多个`for`循环，缩进由八个空格组成。为了代码的可读性，推荐的缩进是 4；我们很快就会看到这一点。注意，如果在这个脚本中打开了端口 22，它不会检查端口 23，因为我们感兴趣的只是端口 22 是否打开。还要注意，我们添加了`time`模块来检查运行应用程序的时间；第 [2](02.html) 和第 [14](14.html) 章介绍了`time`模块。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `cp ping_tool3.py ping_tool4.py` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `nano ping_tool4.py` |
|   | `ping_tool4.py` |
|   | `import os` |
|   | `import socket` |
|   | `import time` |
|   | `t = time.mktime(time.localtime())` `# Timer start to measure script running time` |
|   | `# device_list = ['10.10.10.1',  '192.168.183.111', '192.172.1.33',  '192.168.183.222']` `# Hashed out line` |
|   | `ip_add_file = './ip_addresses.txt'` `# IP address location variable, "./" denotes pwd` |
|   | `# reachable_ips = []` |
|   | `f1 = open('reachable_ips_ssh.txt',  'w+'` `) # Open f1 file` |
|   | `f2 = open('reachable_ips_telnet.txt', 'w+')` `# Open f2 file` |
|   | `# unreachable_ips = []` |
|   | `f3 = open('unreachable_ips.txt', 'w+')` `# Open f3 file` |
|   | `with open(ip_add_file, 'r') as ip_addresses` `: # Use with file open method` |
|   | `for ip in ip_addresses` `: # Loop through and read IP address from each line` |
|   | `ip = ip.strip()` `# Remove any white spaces` |
|   | `resp = os.system('ping -c 3 ' + ip)` `# Send four ICMP packets` |
|   | `if resp == 0` `: # If 0, in other words, the device is on the network` |
|   | `for port in range (22, 23):` `# Check port 22 (SSH)` |
|   | `destination = (ip, port)` `# Create arrayed tuple variable with ip and port as items` |
|   | `try:` `# First try` |
|   | `with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:` `# socket command` |
|   | `s.settimeout(3)` `# Set socket timeout to 3 seconds` |
|   | `connection = s.connect(destination)` `# Send socket connection using destination variable` |
|   | `print(f"{ip} {port} opened")` `#Informational, all print statements are informational` |
|   | `f1.write(f"{ip}\n")` `# write the IP to reachable_ips_ssh.txt` |
|   | `except:` |
|   | `print(f"{ip} {port} closed")` |
|   | `f3.write(f"{ip} {port} closed\n")` `# write the IP to unreachable_ips.txt` |
|   | `for port in range (23, 24)` `: # Check port 23 (telnet)` |
|   | `destination = (ip, port)` |
|   | `try:` |
|   | `with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:` |
|   | `s.settimeout(3)` |
|   | `connection = s.connect(destination)` |
|   | `print(f"{ip} {port} opened")` |
|   | `f2.write(f"{ip}\n")` `# write the IP to reachable_ips_telnet.txt` |
|   | `except:` |
|   | `print(f"{ip} {port} closed")` |
|   | `f3.write(f"{ip} {port} closed\n")` `# write the IP to unreachable_ips.txt` |
|   | `else:` |
|   | `print(f"{ip} unreachable")` |
|   | `f3.write(f"{ip} unreachable\n")` `# write the IP to unreachable_ips.txt` |
|   | `f1.close()` `# Close f1 file` |
|   | `f2.close()` `# Close f2 file` |
|   | `f3.close()` `# Close f3 file` |
|   | `tt = time.mktime(time.localtime()) - t` `# Timer finish to measure script running time` |
|   | `print("Total wait time : {0} seconds".format(tt))` `#Informational` |
| **11** | 运行组合脚本，它应该创建三个文件，根据 ICMP 和端口验证对 IP 地址进行排序。想象一下，在成百上千的设备上运行这样的连通性检查，以便进行故障排除或进行更改；这种类型的工具可以为您节省大量时间，并且可以从另一个应用程序中读取这里创建的文件，以执行进一步的编程任务。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `python3 ping_tool4.py` |
|   | `[... output omitted for brevity]` |
|   | `--- 192.168.183.133 ping statistics ---` |
|   | `3 packets transmitted, 3 received, 0% packet loss, time 2004ms` |
|   | `rtt min/avg/max/mdev = 4.046/7.700/12.147/3.354 ms` |
|   | `192.168.183.133 22 closed` |
|   | `192.168.183.133 23 opened` |
|   | `Total wait time : 31.0 seconds` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `ls` |
|   | `ip_addresses.txt  ping_tool4.py             socket_tool.py` |
|   | `ping_tool1.py     reachable_ips_ssh.txt     unreachable_ips.txt` |
|   | `ping_tool2.py     reachable_ips_telnet.txt` |
|   | `ping_tool3.py     reachable_ips.txt` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `more reachable_ips_ssh.txt` |
|   | `192.168.183.111` |
|   | `192.168.183.222` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `more reachable_ips_telnet.txt` |
|   | `192.168.183.133` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `more unreachable_ips.txt` |
|   | `10.10.10.1 unreachable` |
|   | `192.172.1.33 unreachable` |
|   | `192.168.183.133 22 closed` |
| **12** | 现在创建一个`check_port()`函数，并使这个工作函数成为一个单独的函数。当您运行下面的代码时，它将以一种更 Pythonic 化的方式产生相同的结果。最佳实践是分离函数，以另一个文件名保存为模块，然后作为工具导入，这样主脚本就不那么拥挤，更容易理解。但目前来看，这应该是可以接受的。重写`ping_tool4.py`中的代码，使其看起来像`ping_tool5.py`。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$ cp ping_tool4.py ping_tool5.py` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `nano ping_tool5.py` |
|   | `ping_tool5.py` |
|   | `import os` |
|   | `import socket` |
|   | `import time` |
|   | `t = time.mktime(time.localtime())` |
|   | `def check_port(ip):` |
|   | `for port in range (22, 23):` |
|   | `destination = (ip, port)` |
|   | `try:` |
|   | `with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:` |
|   | `s.settimeout(3)` |
|   | `connection = s.connect(destination)` |
|   | `print(f"{ip} {port} opened")` |
|   | `f1.write(f"{ip}\n")` |
|   | `except:` |
|   | `print(f"{ip} {port} closed")` |
|   | `f3.write(f"{ip} {port} closed\n")` |
|   | `for port in range (23, 24):` |
|   | `destination = (ip, port)` |
|   | `try:` |
|   | `with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:` |
|   | `s.settimeout(3)` |
|   | `connection = s.connect(destination)` |
|   | `print(f"{ip} {port} opened")` |
|   | `f2.write(f"{ip}\n")` |
|   | `except:` |
|   | `print(f"{ip} {port} closed")` |
|   | `f3.write(f"{ip} {port} closed\n")` |
|   | `ip_add_file = './ip_addresses.txt'` |
|   | `f1 = open('reachable_ips_ssh.txt',  'w+')` |
|   | `f2 = open('reachable_ips_telnet.txt', 'w+')` |
|   | `f3 = open('unreachable_ips.txt', 'w+')` |
|   | `with open(ip_add_file, 'r') as ip_addresses:` |
|   | `for ip in ip_addresses:` |
|   | `ip = ip.strip()` |
|   | `resp = os.system('ping -c 3 ' + ip)` `# there is a whitespace after the digit 3, be careful.` |
|   | `if resp == 0:` |
|   | `check_port(ip)` |
|   | `else:` |
|   | `print(f"{ip} unreachable")` |
|   | `f3.write(f"{ip} unreachable\n")` |
|   | `f1.close()` |
|   | `f2.close()` |
|   | `f3.close()` |
|   | `tt = time.mktime(time.localtime()) - t` |
|   | `print("Total wait time : {0} seconds".format(tt))` |
|   | 现在运行应用程序并检查结果。我们期待看到与`ping_tool4.py`相同的结果。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `python3 ping_tool5.py` |
|   | `[... output omitted for brevity]` |
|   | `64 bytes from 192.168.183.133: icmp_seq=2 ttl=255 time=2.43 ms` |
|   | `64 bytes from 192.168.183.133: icmp_seq=3 ttl=255 time=12.7 ms` |
|   | `--- 192.168.183.133 ping statistics ---` |
|   | `3 packets transmitted, 3 received, 0% packet loss, time 2002ms` |
|   | `rtt min/avg/max/mdev = 2.429/6.314/12.670/4.531 ms` |
|   | `192.168.183.133 22 closed` |
|   | `192.168.183.133 23 opened` |
|   | `Total wait time : 30.0 seconds` |
| **13** | 让我们通过将端口检查工具分离到一个单独的模块(一个单独的文件)来简化主脚本。当你运行`ping_tool6.py`时，你会得到同样的结果，但是我们可以说我们的代码更 Pythonic 化一点。 |
|   | 将`check_port`函数作为一个单独的工具分离出来，所以创建并保存为`ping_tool6_tools.py`。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `nano ping_tool6_tools.py` |
|   | `ping_tool6_tools.py` |
|   | `# ping_tool6_tools.py for ping_tool6.py` |
|   | `import socket` |
|   | `def check_port(ip, f1, f2, f3):` |
|   | `for port in range (22, 23):` |
|   | `destination = (ip, port)` |
|   | `try:` |
|   | `with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:` |
|   | `s.settimeout(3)` |
|   | `connection = s.connect(destination)` |
|   | `print(f"{ip} {port} open")` |
|   | `f1.write(f"{ip}\n")` |
|   | `except:` |
|   | `print(f"{ip} {port} closed")` |
|   | `f3.write(f"{ip} {port} closed\n")` |
|   | `for port in range (23, 24):` |
|   | `destination = (ip, port)` |
|   | `try:` |
|   | `with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:` |
|   | `s.settimeout(3)` |
|   | `connection = s.connect(destination)` |
|   | `print(f"{ip} {port} open")` |
|   | `f2.write(f"{ip}\n")` |
|   | `except:` |
|   | `print(f"{ip} {port} closed")` |
|   | `f3.write(f"{ip} {port} closed\n")` |
|   | 复制`ping_tool5.py`并创建`ping_tool6.py`；然后创建如下所示的主脚本: |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `cp ping_tool5.py ping_tool6.py` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `nano ping_tool6.py` |
|   | 确保您移除了`check_port()`功能，并修改了文件，如下所示: |
|   | `ping_tool6.py` |
|   | `import os` |
|   | `import time` |
|   | `from ping_tool6_tools import check_port` `# importing check_port tool from ping_tool6_tools.py` |
|   | `t = time.mktime(time.localtime())` |
|   | `ip_add_file = './ip_addresses.txt'` |
|   | `f1 = open('reachable_ips_ssh.txt',  'w+')` |
|   | `f2 = open('reachable_ips_telnet.txt', 'w+')` |
|   | `f3 = open('unreachable_ips.txt', 'w+')` |
|   | `with open(ip_add_file, 'r') as ip_addresses:` |
|   | `for ip in ip_addresses:` |
|   | `ip = ip.strip()` |
|   | `resp = os.system('ping -c 3 ' + ip)` |
|   | `if resp == 0:` |
|   | `check_port(ip, f1, f2, f3)` `# parsing arguments ip, f1, f2, f3` |
|   | `else:` |
|   | `print(f"{ip} unreachable")` |
|   | `f3.write(f"{ip} unreachable\n")` |
|   | `f1.close()` |
|   | `f2.close()` |
|   | `f3.close()` |
|   | `tt = time.mktime(time.localtime()) - t` |
|   | `print("Total wait time : {0} seconds".format(tt))` |
|   | 现在，运行最后一个工具`ping_tool6.py`，你应该会看到与`ping_tool5.py`和`ping_tool4.py`迭代相同的结果。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool1_ping$` `python3 ping_tool6.py` |
|   | `[... output omitted for brevity]` |
|   | `64 bytes from 192.168.183.133: icmp_seq=3 ttl=255 time=13.8 ms` |
|   | `--- 192.168.183.133 ping statistics ---` |
|   | `3 packets transmitted, 3 received, 0% packet loss, time 2004ms` |
|   | `rtt min/avg/max/mdev = 5.775/9.237/13.752/3.340 ms` |
|   | `192.168.183.133 22 closed` |
|   | `192.168.183.133 23 open` |
|   | `Total wait time : 30.0 seconds` |

我们的 ping 工具的最后一次迭代已准备就绪，可以立即用于生产，并且足够好地集成到我们的 Cisco IOS 升级应用程序中。这是第一个工具开发的结束；现在让我们看看第二个工具。

## 收集用户的登录凭据和用户输入

当网络工程师在 Cisco 路由器和交换机上执行 IOS 升级时，他必须输入具有正确用户权限的网络管理员凭据:15 级管理员用户 ID 和密码。设备访问级别和安全性可能使用本地配置的用户凭证，也可能位于 TACACS 服务器上。在本书中，我们使用本地登录来简化事情。成功认证和登录后，网络管理员必须手动运行一些命令来检查设备的可升级性。也就是说，设备需要有足够的闪存(存储)来保存新的 IOS 映像。然后，网络管理员必须使用新的 IOS 映像文件名和 FTP/TFTP 服务器信息运行命令。在 TFTP 的情况下，不需要管理员用户名或密码。不过，在大多数情况下，您必须提供另一个用户名和密码组合，以便对 FTP 服务器进行进一步的身份验证。一些信息是一次一条一行地输入的。但是通过脚本，我们可以简化并在脚本开始运行时使用一种数据收集方法收集管理员的数据。最简单的方法是使用一个文件一次性收集所有需要的信息。最麻烦的方法是让用户一次一条地手工输入信息。出于演示的目的，我们可以编写一些代码，使用这两者来获取用户 ID、密码和秘密密码。我们将使用交互式数据收集工具来收集 IOS 名称和 MD5 值。该信息将从 CSV 文件中读取。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 要开发一个获取凭证工具，您将从`input`函数和`getpass`模块开始；`getpass`模块隐藏输入控制台的密码。由于我们正在开发该工具，为了方便起见，我们将使用`print`语句打印密码。 |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `mkdir tool2_login` |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `cd tool2_login` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool2_login$` `nano get_cred1.py` |
|   | 要收集用户 ID 和网络密码并启用加密密码，最基本的工具如下所示: |
|   | `get_cred1.py` |
|   | `from getpass import getpass` |
|   | `uid = input("Enter Network Admin ID : ")` |
|   | `pwd = getpass("Enter Network Admin PWD : ")` |
|   | `secret = getpass("Enter secret password : ")` |
|   | `print(uid, pwd, secret)` |
|   | 运行初始脚本进行快速测试。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool2_login$` `python3 get_cred1.py` |
|   | `Enter Network Admin ID :` `pynetauto` |
|   | `Enter Network Admin PWD : ********` |
|   | `Enter secret password : *********` |
|   | `pynetauto cisco123 secret123` |
|   | 对于前面显示的简单用户 ID 和密码收集工具，有两个问题。首先，您可以输入任何信息或不输入任何信息，然后继续下一步，因此脚本至少需要在继续下一步之前从用户那里获得一个有效的输入。第二，对于`getpass`模块，它不显示输入的密码，因此在 SSH 或 Telnet 认证过程中脚本运行并出错之前，您无法判断是否输入了正确的密码。因此，我们必须通过添加验证步骤来改进这个脚本。 |
| **2** | 让我们对这个工具做一些改进，使它达到可接受的标准。在这个迭代中，我们将通过添加密码和秘密的验证脚本来解决第二个问题，即`getpass`模块。您必须输入密码和秘密两次，以确保输入的密码匹配且正确。我们还会提示用户密码和密码是否与生产环境中的相同。密码和秘密都是一样的，因此通过回答`y`或`yes`，用户不必再次键入秘密。在第一次迭代之后，您的代码将类似于下一次编写的代码。请注意，我已经将秘密集合移到了一个单独的函数中，以使这个脚本更加简洁，此外，如果用户回答了除`y`、`yes`、`n`或`no`之外的问题，将会提示用户提供正确的答案。该功能使用户只提供期望的响应:任何一个`y`、`yes`、`n,`或`no`响应。 |
|   | 参考`get_cred1.py`，开始拼起来吧。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool2_login$` `nano get_cred2.py` |
|   | `get_cred2.py` |
|   | `from getpass import getpass` |
|   | `def get_secret():` |
|   | `global secret` |
|   | `resp = input("Is secret the same as password? (y/n) : ")` |
|   | `resp = resp.lower()` |
|   | `if resp == "yes" or resp == "y":` |
|   | `secret = pwd` |
|   | `elif resp == "no" or resp == "n":` |
|   | `secret = None` |
|   | `while not secret:` |
|   | `secret = getpass("Enter the secret : ")` |
|   | `secret_verify = getpass("Confirm the secret : ")` |
|   | `if secret != secret_verify:` |
|   | `print("! Secrets do not match. Please try again.")` |
|   | `secret = None` |
|   | `else:` |
|   | `get_secret()` |
|   | `def get_credentials():` |
|   | `global uid` |
|   | `uid = input("Enter Network Admin ID : ")` |
|   | `global pwd` |
|   | `pwd = None` |
|   | `while not pwd:` |
|   | `pwd = getpass("Enter Network Admin PWD : ")` |
|   | `pwd_verify = getpass("Confirm Network Admin PWD : ")` |
|   | `if pwd != pwd_verify:` |
|   | `print("! Network Admin Passwords do not match. Please try again.")` |
|   | `pwd = None` |
|   | `get_secret()` |
|   | `return uid, pwd, secret` |
|   | `get_credentials()` |
|   | `print(uid, pwd,secret)` |
|   | 一旦您完成了前面脚本的编写，请测试您的应用程序。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool2_login$` `python3 get_cred2.py` |
|   | `Enter Network Admin ID :` `pynetauto` |
|   | `Enter Network Admin PWD : ********` |
|   | `Confirm Network Admin PWD : ******* # Enter mismatched password` |
|   | `! Network Admin Passwords do not match. Please try again.` |
|   | `Enter Network Admin PWD : ********` |
|   | `Confirm Network Admin PWD : ********` |
|   | `Is secret the same as password? (y/n) :` `n` |
|   | `Enter the secret : ********` |
|   | `Confirm the secret : ******** # Enter mismatched password` |
|   | `! secret do not match. Please try again.` |
|   | `Enter the secret : ********` |
|   | `Confirm the secret : ********` |
|   | `pynetauto cisco123 secret123` |
|   | 之前的用户 ID、密码和秘密收集工具看起来比任务 1 中的原始工具好得多。尽管如此，如前所述，它还有另一个缺陷，用户可以输入任意长度的用户名、密码或秘密，所以这是我们必须解决的另一个问题，以使该工具更加真实。请看下面的例子，了解这意味着什么: |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool2_login$` `python3 get_cred_b_test.py` |
|   | `Enter Network Admin ID :` `a` |
|   | `Enter Network Admin PWD : *` |
|   | `Confirm Network Admin PWD : *` |
|   | `Is secret the same as password? (y/n) :` `n` |
|   | `Enter the secret : *` |
|   | `Confirm the secret : *` |
| **3** | 我们可以使用几个正则表达式来控制用户输入，这将解决前面的问题。在管理良好的 IT 环境中，管理员总是对用户名和密码执行约定。因此，对于我们的脚本，我们将遵循相同的实践，只允许可接受的输入到我们的标准中。对于用户名，惯例是它需要 5 到 30 个字符长，必须以字母开头，并且在用户名中除了`_`和`-`之外不能使用任何特殊字符。对于密码约定，密码必须以小写或大写字母开头，并且密码必须超过 8 个字符，但等于或少于 50 个字符。第 2 个和第 50 个之间的字符可以包含特殊字符。让我们看看如何在用户名和密码上实施这些约定。在编写 Python 代码时，您必须灵活并创造性地使用您的正则表达式，以使您的代码做您想要的事情，这就是其中的一个例子。 |
|   | 参考`get_cred2.py`，开始组合代码。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool2_login$` `nano get_cred3.py` |
|   | `get_cred3.py` |
|   | `import re` |
|   | `from getpass import getpass` |
|   | `p1 = re.compile(r'^[a-zA-Z0-9][a-zA-Z0-9_-]{3,28}[a-zA-Z0-9]$') # You must comprehend Chapter 9!` |
|   | `p2 = re.compile(r'^[a-zA-Z].{7,49}') # You must read through and complete all exercise in Chapter 9.` |
|   | `def get_secret():` |
|   | `global secret` |
|   | `resp = input("Is secret the same as password? (y/n) : ")` |
|   | `resp = resp.lower()` |
|   | `if resp == "yes" or resp == "y":` |
|   | `secret = pwd` |
|   | `elif resp == "no" or resp == "n":` |
|   | `secret = None` |
|   | `while not secret:` |
|   | `secret = getpass("Enter the secret : ")` |
|   | `while not p2.match(secret): # apply the re pattern 2 secret` |
|   | `secret = getpass(r"*Enter the secret : ")` |
|   | `secret_verify = getpass("Confirm the secret : ")` |
|   | `if secret != secret_verify:` |
|   | `print("!!! secret do not match. Please try again.")` |
|   | `secret = None` |
|   | `else:` |
|   | `get_secret()` |
|   | `def get_credentials():` |
|   | `global uid` |
|   | `uid = input("Enter Network Admin ID : ")` |
|   | `while not p1.match(uid): # apply the re pattern 1 to uid` |
|   | `uid = input(r"*Enter Network Admin ID : ")` |
|   | `global pwd` |
|   | `pwd = None` |
|   | `while not pwd:` |
|   | `pwd = getpass("Enter Network Admin PWD : ")` |
|   | `while not p2.match(pwd): # apply the re pattern 2 password` |
|   | `pwd = getpass(r"*Enter Network Admin PWD : ")` |
|   | `pwd_verify = getpass("Confirm Network Admin PWD : ")` |
|   | `if pwd != pwd_verify:` |
|   | `print("!!! Network Admin Passwords do not match. Please try again.")` |
|   | `pwd = None` |
|   | `get_secret()` |
|   | `return uid, pwd, secret` |
|   | `get_credentials()` |
|   | `print(uid, pwd,secret)` |
|   | 运行最终应用程序并验证功能；您的测试运行应该类似于下面的结果。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool2_login$` `python3 get_cred3.py` |
|   | `Enter Network Admin ID : jdoe # Entered only four characters. Minimum of five characters required` |
|   | `*Enter Network Admin ID :` `pynetauto` |
|   | `Enter Network Admin PWD : ******* # Entered only seven characters. Minimum eight characters long` |
|   | `*Enter Network Admin PWD : ********` |
|   | `Confirm Network Admin PWD : ********` |
|   | `Is secret the same as password? (y/n) :` `n` |
|   | `Enter the secret : ******* # Entered only seven characters, minimum of 8 characters long` |
|   | `*Enter the secret : *********` |
|   | `Confirm the secret : *********` |
|   | `pynetauto cisco123 secret123` |
|   | 在三次重复原始代码之后，它看起来几乎已经完成，可以在升级脚本中使用了。接下来，让我们看看如何从 CSV 文件中读取 IOS 名称和 MD5 值，并将它们转换为 Python 变量。 |

现在，您已经从应用程序用户那里收集了用户 ID 和密码，让我们看看如何通过读取文件来收集新的 IOS 文件名和 MD5 值。如果您有多个设备和多个值，通过命令行输入这些信息将会非常麻烦。它也容易出错，所以理想情况下，这些值以二维数组形式输入，如 Excel 或 CSV 文件，让您的 Python 脚本读取这些信息。我们希望在命令行控制台的剪切和粘贴操作中节省时间并减少人为错误。

## 从 CSV 文件中收集新的 IOS 文件名和 MD5 值

收集用户 ID 和密码后，我们希望收集 Cisco IOS 升级所需的更多信息，但这次是通过读取 CSV 文件的内容。额外的信息包括新的 IOS 名称及其各自的 MD5 值。我们还可以包括主机名、设备类型、IP 地址和其他信息，以便为我们的脚本提供二维数据。

如果您有有效的服务合同或为思科合作伙伴工作，可以从思科下载网站下载 IOS 以升级到最新的 IOS 版本。执行 IOS 升级的工程师通常会下载文件，并从供应商的下载网站获取 MD5 值。将 IOS 下载到工程师的计算机后，工程师会确认该 IOS 副本的 MD5 值，这样他们就知道所有软件在下载过程中都是完整的，没有损坏。这是 IOS 升级准备过程中的第一批验证步骤之一。想象一下，不检查 MD5 值并使用该文件来升级 Cisco 设备的 IOS 软件！这可能会变成一个糟糕的情况，而不是简单的 IOS 升级。

当我们升级任何供应商产品上的 IOS 或任何操作系统时，您必须确保供应商下载的软件版本是正确的。您需要确保下载过程没有由于糟糕的互联网连接或其他问题而损坏 IOS。在 IOS 升级工具中有两个地方可以验证新的 IOS MD5 值。首先，用户提供的新 IOS 的 MD5 值将根据服务器检查的 MD5 值进行验证。其次，根据 Cisco 路由器检查的 MD5 值验证服务器检查的 MD5 值。在路由器检查新 IOS 文件的 MD5 之前，必须使用 TFTP/FTP/SFTP/SCP 协议将新 IOS 传输到路由器的闪存中。当然，我们希望每次都检查所有的 MD5 测试，以避免不可思议的事情。在我们将 Cisco 网站上的 MD5 值与服务器端的 MD5 值进行比较之前，我们必须为我们的脚本输入正确的 MD5 值。提供这些信息的一个很好的方法是通过 Excel 或 CSV 文件。与使用文本文件不同，我们可以在 Python 脚本中使用二维值(带有一个头)，它们可以由`pandas`模块处理。

让我们看看如何从一个文件(如`.xlsx`或`.csv`文件)中导入新的 IOS 名称和 MD5 值。虽然从基于 Windows 的计算机创建二维文件更方便，但将文件保存为`.csv`文件更有利。它为您在 Linux 服务器的命令行文本编辑器中修改内容提供了更多的灵活性。在本例中，您将使用 Excel 处理文件，然后将其保存为 CSV 文件。一旦`pandas`模块将二维值读入我们的脚本，您就可以访问它们并将其转换成您想要的任何变量形式。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 让我们打开一个新的 Excel 文件，输入以下详细信息，标题在第一行，路由器信息在第二和第三行。在这个阶段，您必须从 Cisco 下载站点获得新 IOS `.bin`文件的副本和正确的 MD5 值。此时，我们可以输入每个设备的更多信息，如`devicename`(路由器名称)、`device`(类型)、`devicetype`(用于`netmiko`字典)、`host` (IP 地址或 DNS 主机名)、`newios`和`newiosmd5`值，如图 [18-1](#Fig1) 所示。 |
|   | If you are using another IOS version, then you will have to update the information accordingly.![../images/492721_1_En_18_Chapter/492721_1_En_18_Fig1_HTML.jpg](../images/492721_1_En_18_Chapter/492721_1_En_18_Fig1_HTML.jpg)图 18-1。在 Microsoft Excel 中创建 CSV 文件 |
|   | If you don’t have Microsoft Excel on your host computer, then you can work in any text editor using commas as separators, as shown in Figure [18-2](#Fig2). Alternatively, if you have a couple of devices like our example, you can directly enter this information in the Linux server’s vi or nano text editor. If you have hundreds of devices, use a spreadsheet program such as Microsoft Excel or Google Sheets.![../images/492721_1_En_18_Chapter/492721_1_En_18_Fig2_HTML.jpg](../images/492721_1_En_18_Chapter/492721_1_En_18_Fig2_HTML.jpg)图 18-2。使用文本编辑器创建 CSV 文件 |
| **2** | Once you have finished entering the information in Microsoft Excel, save the file as `device_info.csv`. Make sure you select “Save as type” and select “CSV (Comma delimited).” See Figure [18-3](#Fig3).![../images/492721_1_En_18_Chapter/492721_1_En_18_Fig3_HTML.jpg](../images/492721_1_En_18_Chapter/492721_1_En_18_Fig3_HTML.jpg)图 18-3。在 Microsoft Excel 中将文件保存为 CSV 文件 |
| **3** | 在前面的章节中，您使用 WinSCP 将文件上传到 Python 自动化服务器。如果您想将文件上传到您的 Linux 服务器的工作目录，您现在就可以这样做。由于您试图在此上传的 CSV 文件是一个具有不同文件扩展名(`.csv`)的文本(`.txt`)文件，因此可以在 Linux 的 vi 或 nano 文本编辑器中将信息复制并粘贴到一个新文件中，然后将该文件另存为`.csv`文件。 |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `mkdir tool3_read_csv` |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `cd tool3_read_csv` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `pwd` |
|   | `/home/pynetauto/my_tools/tool3_read_csv` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `nano devices_info.csv` |
|   | `devices_info.csv` |
|   | `devices_info.csv` |
|   | `devicename,device,devicetype,host,newios,newiosmd5` |
|   | `csr1000v-1,RT,cisco_xe,192.168.183.111,csr1000v-universalk9.16.09.06.SPA.bin,77878ae6db8e34de90e2e3e83741bf39` |
|   | `csr1000v-2,RT,cisco_xe,192.168.183.222,csr1000v-universalk9.16.09.06.SPA.bin,77878ae6db8e34de90e2e3e83741bf39` |
|   | 编写基本脚本来读取您的 CSV 文件。如果您使用的是`.xlsx`文件，用`.xlsx`替换文件扩展名类型，`pandas`将以与`.csv`文件相同的方式读取该文件。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `nano read_info1.py` |
|   | `read_info1.py` |
|   | `import pandas as pd` |
|   | `df = pd.read_csv(r'./devices_info.csv')` |
|   | `print(df)` |
|   | 运行脚本并打印出数据帧(`df`)。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `python3 read_info1.py` |
|   | `devicename device  ...           newios                         newiosmd5` |
|   | `0  csr1000v-1     RT  ...  csr1000v-universalk9.16.09.06.SPA.bin  77878ae6db8e34de90e2e3e83741bf39` |
|   | `1  csr1000v-2     RT  ...  csr1000v-universalk9.16.09.06.SPA.bin  77878ae6db8e34de90e2e3e83741bf39` |
|   | `[2 rows x 6 columns]` |
|   | 现在重复脚本并添加两行代码来读取行数；行数也可以用作变量来控制我们的应用程序的流程。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `cp read_info1.py read_info2.py` |
|   | `ynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `nano read_info2.py` |
|   | `read_info2.py` |
|   | `import pandas as pd` |
|   | `df = pd.read_csv(r'./devices_info.csv')` |
|   | `print(df)` |
|   | `number_of_rows = len(df.index)` |
|   | `print(number_of_rows)` |
|   | 运行前面的脚本以获取行数；我们期望 2，因为默认情况下`pandas`将第一行作为标题行读取。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `python3 read_info2.py` |
|   | `devicename device  ...               newios                         newiosmd5` |
|   | `0  csr1000v-1     RT  ...  csr1000v-universalk9.16.09.06.SPA.bin  77878ae6db8e34de90e2e3e83741bf39` |
|   | `1  csr1000v-2     RT  ...  csr1000v-universalk9.16.09.06.SPA.bin  77878ae6db8e34de90e2e3e83741bf39` |
|   | `[2 rows x 6 columns]` |
|   | `2` |
| **4** | 我们试图读取每个值并将它们用作变量，所以我们在脚本中使用特定的信息。我们希望读取每一行，并将其转换为一种类型的数组，如列表或元组。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `nano read_info3.py` |
|   | `read_info3.py` |
|   | `import pandas as pd` |
|   | `df = pd.read_csv(r'./devices_info.csv')` |
|   | `number_of_rows = len(df.index)` |
|   | `# Read the values and save as a list, read column as df and save it as a list` |
|   | `devicename = list(df['devicename'])` |
|   | `device = list(df['device'])` |
|   | `devicetype = list(df['devicetype'])` |
|   | `ip = list(df['host'])` |
|   | `newios = list(df['newios'])` |
|   | `newiosmd5 = list(df['newiosmd5'])` |
|   | `print(devicename)` |
|   | `print(device)` |
|   | `print(devicetype)` |
|   | `print(ip)` |
|   | `print(newios)` |
|   | `print(newiosmd5)` |
|   | 当您运行前面的脚本时，现在可以轻松地访问数据，并以 Python 列表的形式进行检索。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `python3 read_info3.py` |
|   | `['csr1000v-1', 'csr1000v-2']` |
|   | `['RT', 'RT']` |
|   | `['cisco_xe', 'cisco_xe']` |
|   | `['192.168.183.111', '192.168.183.222']` |
|   | `['csr1000v-universalk9.16.09.06.SPA.bin', 'csr1000v-universalk9.16.09.06.SPA.bin']` |
|   | `['77878ae6db8e34de90e2e3e83741bf39', '77878ae6db8e34de90e2e3e83741bf39']` |
| **5** | 让我们稍微处理一下数据，并将其放入包含列表项的单个列表中。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `nano read_info4.py` |
|   | `read_info4.py` |
|   | `import pandas as pd` |
|   | `df = pd.read_csv(r'./devices_info.csv')` |
|   | `number_of_rows = len(df.index)` |
|   | `# Read the values and save as a list, read column as df and save it as a list` |
|   | `devicename = list(df['devicename'])` |
|   | `device = list(df['device'])` |
|   | `devicetype = list(df['devicetype'])` |
|   | `ip = list(df['host'])` |
|   | `newios = list(df['newios'])` |
|   | `newiosmd5 = list(df['newiosmd5'])` |
|   | `# Convert the list into a device_list` |
|   | `device_list = []` |
|   | `for index, rows in df.iterrows():` |
|   | `device_append = [rows.devicename, rows.device, \` |
|   | `rows.devicetype, rows.host, rows.newios, rows.newiosmd5]` |
|   | `device_list.append(device_append)` |
|   | `print(device_list)` |
|   | 运行脚本，您会注意到读取的设备信息现在已经变成了一个列表列表。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `python3 read_info4.py` |
|   | `[['csr1000v-1', 'RT', 'cisco_xe', '192.168.183.111', 'csr1000v-universalk9.16.09.06.SPA.bin', '77878ae6db8e34de90e2e3e83741bf39'], ['csr1000v-2', 'RT', 'cisco_xe', '192.168.183.222', 'csr1000v-universalk9.16.09.06.SPA.bin', '77878ae6db8e34de90e2e3e83741bf39']]` |
| **6** | 如果我们只需要通过读取 CSV 文件创建的来自`device_list`的特定信息，比如`newios`和`newiosmd5`，我们可以使用一个简单的循环来调用这些数字。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `cp read_info4.py read_info5.py` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `nano read_info5.py` |
|   | `read_info5.py` |
|   | `import pandas as pd` |
|   | `df = pd.read_csv(r'./devices_info.csv')` |
|   | `number_of_rows = len(df.index)` |
|   | `# Read the values and save as a list, read column as df and save it as a list` |
|   | `devicename = list(df['devicename'])` |
|   | `device = list(df['device'])` |
|   | `devicetype = list(df['devicetype'])` |
|   | `ip = list(df['host'])` |
|   | `newios = list(df['newios'])` |
|   | `newiosmd5 = list(df['newiosmd5'])` |
|   | `# Convert the list into a device_list` |
|   | `device_list = []` |
|   | `for index, rows in df.iterrows():` |
|   | `device_append = [rows.devicename, rows.device, \` |
|   | `rows.devicetype, rows.host, rows.newios, rows.newiosmd5]` |
|   | `device_list.append(device_append)` |
|   | `for x in device_list:` |
|   | `newios, newiosmd5 = x[4], x[5].lower()` |
|   | `print(newios, newiosmd5)` |
|   | 现在运行脚本，您将获得每个设备的新 IOS 文件名和 MD5 值。由于我们有相同的设备类型，新的 IOS 名称和 MD5 值将是相同的。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `python3 read_info5.py` |
|   | `csr1000v-universalk9.16.09.06.SPA.bin 77878ae6db8e34de90e2e3e83741bf39` |
|   | `csr1000v-universalk9.16.09.06.SPA.bin 77878ae6db8e34de90e2e3e83741bf39` |
| **7** | 最初，当我们创建 CSV 文件时，我们使用了比所需更多的信息，这是有原因的。使用`pandas`文件读取方法，我们还想创建一个包含`netmiko`字典格式的列表。我们可以在登录路由器时将字典的值传递给用于 SSH 连接的`netmiko ConnectHandler`。让我们研究一下简单的`netmiko`字典格式，并使用 IP 地址和来自`device_list`的`devicetype`信息为 SSH 登录创建另一个字典。设备字典如下例所示。您还可以添加`logging`和`delay factors`选项，但我们将保持简单，以便在实验室使用。 |
|   | `device1 = {` |
|   | `'device_type': 'cisco_ios',` |
|   | `'host': '10.10.10.1',` |
|   | `'username': 'username',` |
|   | `'password': 'password',` |
|   | `'secret': 'secret',` |
|   | `}` |
|   | 因此，从 10.5.2 开始，我们已经可以通过交互式输入会话从用户那里收集用户名、密码和密码。现在我们已经从一个 CSV 文件中读取了`device_type`和`host` (IP 地址)值。我们可以使用收集的信息将它转换成 SSH 连接的`netmiko`兼容的字典格式。请注意，我们添加了用户名和密码收集工具，以教您如何以交互方式收集它们。如果在极其安全的环境中运行 Python 脚本，可以通过文件读取方法提供所有信息，包括用户名、密码和密码。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `cp read_info5.py read_info6.py` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `nano read_info6.py` |
|   | `read_info6.py` |
|   | `import pandas as pd` |
|   | `df = pd.read_csv(r'./devices_info.csv')` |
|   | `number_of_rows = len(df.index)` |
|   | `# Read the values and save as a list, read column as df and save it as a list` |
|   | `devicename = list(df['devicename'])` |
|   | `device = list(df['device'])` |
|   | `devicetype = list(df['devicetype'])` |
|   | `ip = list(df['host'])` |
|   | `newios = list(df['newios'])` |
|   | `newiosmd5 = list(df['newiosmd5'])` |
|   | `# Convert the list into a device_list` |
|   | `device_list = []` |
|   | `for index, rows in df.iterrows():` |
|   | `device_append = [rows.devicename, rows.device, \` |
|   | `rows.devicetype, rows.host, rows.newios, rows.newiosmd5]` |
|   | `device_list.append(device_append)` |
|   | `i = 0` |
|   | `for x in device_list:` |
|   | `if len(x) !=0:` |
|   | `i += 1` |
|   | `name = f'device{str(i)}'` |
|   | `devicetype, host = x[2], x[3]` |
|   | `device = {` |
|   | `'device_type': devicetype,` |
|   | `'host': host,` |
|   | `'username': 'username',` |
|   | `'password': 'password',` |
|   | `'secret': 'secret',` |
|   | `}` |
|   | `print(name, "=" ,device)` |
|   | 现在，当您运行脚本时，您将看到信息被格式化为一个字典，我们可以将字典分配给变量，在本例中是`device1`和`device2`。想象一下，你有 20 或 200 台设备将阅读的信息转换成`netmiko`友好的词典。有人说自动化完全是在命令的循环中。如果一个任务是重复性的，那就是自动化的潜在目标。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `python3 read_info6.py` |
|   | `device1 = {'device_type': 'cisco_xe', 'host': '192.168.183.111', 'username': 'username', 'password': 'password', 'secret': 'secret'}` |
|   | `device2 = {'device_type': 'cisco_xe', 'host': '192.168.183.222', 'username': 'username', 'password': 'password', 'secret': 'secret'}` |
| **8** | 复制之前的脚本，创建一个名为`read_info7.py`的新脚本。您将修改它，因此字典现在存储在一个列表中。换句话说，您将创建一个包含多个字典的列表。这样，我们可以在 SSH 连接到您的设备期间调用它们和字典。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `cp read_info6.py read_info7.py` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `nano read_info7.py` |
|   | 请注意，出于测试目的，我已经手动将用户名、密码和密码添加到该脚本中。但是，当我们集成前面开发的用户 ID 和密码收集工具时，变量将被替换。当您在生产环境中工作时，强烈建议您删除用户名和密码信息，或者完全删除包含敏感信息的文件。 |
|   | `read_info7.py` |
|   | `import pandas as pd` |
|   | `df = pd.read_csv(r'./devices_info.csv')` |
|   | `number_of_rows = len(df.index)` |
|   | `# Read the values and save as a list, read column as df and save it as a list` |
|   | `devicename = list(df['devicename'])` |
|   | `device = list(df['device'])` |
|   | `devicetype = list(df['devicetype'])` |
|   | `ip = list(df['host'])` |
|   | `newios = list(df['newios'])` |
|   | `newiosmd5 = list(df['newiosmd5'])` |
|   | `# Convert the list into a device_list` |
|   | `device_list = []` |
|   | `for index, rows in df.iterrows():` |
|   | `device_append = [rows.devicename, rows.device, \` |
|   | `rows.devicetype, rows.host, rows.newios, rows.newiosmd5]` |
|   | `device_list.append(device_append)` |
|   | `device_list_netmiko = []` |
|   | `i = 0` |
|   | `for x in device_list:` |
|   | `if len(x) !=0:` |
|   | `i += 1` |
|   | `name = f'device{str(i)}'` |
|   | `devicetype, host = x[2], x[3]` |
|   | `device = {` |
|   | `'device_type': devicetype,` |
|   | `'host': host,` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123',` |
|   | `}` |
|   | `device_list_netmiko.append(device)` |
|   | `print(device_list_netmiko)` |
|   | 当您运行这个脚本时，您应该得到一个包含两个字典作为条目的列表。如果您想将数据解析成 Python 脚本，以便从任何网络设备访问任何信息，那么您必须熟悉处理数据。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `python3 read_info7.py` |
|   | `[{'device_type': 'cisco_xe', 'host': '192.168.183.111', 'username': 'pynetauto', 'password': 'cisco123', 'secret': 'cisco123'}, {'device_type': 'cisco_xe', 'host': '192.168.183.222', 'username': 'pynetauto', 'password': 'cisco123', 'secret': 'cisco123'}]` |
| **9** | 为了测试这个脚本是否能按预期工作，添加一个`netmiko ConnectHandler`，并运行 Cisco `router`命令。注意，只有一个`import`语句(来自`netmiko import ConnectHandler`)和最后四行代码被添加到前面的脚本中。这个 Python 脚本可以从我的 GitHub 站点下载。 |
|   | 下载 URL: |
|   | 创建最终脚本以使用读取的数据，然后执行一个简单的任务；在这种情况下，运行`show clock`命令来显示 CSR 路由器的时间。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `cp read_info7.py read_info8.py` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `nano read_info8.py` |
|   | `read_info8.py` |
|   | `import pandas as pd` |
|   | `from netmiko import ConnectHandler` |
|   | `[... omitted for brevity. Same as read_info7.py]` |
|   | `[... See the source code for full details.]` |
|   | `for device in device_list_netmiko:` |
|   | `net_connect = ConnectHandler(**device)` |
|   | `show_clock = net_connect.send_command("show clock")` |
|   | `print(show_clock)` |
|   | 运行该脚本时，您应该会看到每台路由器的时间。`show clock`命令是最简单的命令之一，您可以从脚本中运行它来检查您的 SSH 连接是否工作正常。检查端口 22 并不测试您的凭证，因此值得编写这样的代码来运行一个简单的`show clock`命令。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool3_read_csv$` `python3 read_info8.py` |
|   | `*13:37:19.262 UTC Fri Jan 15 2021` |
|   | `*13:37:20.403 UTC Fri Jan 15 2021` |

## 检查服务器上新 IOS 的 MD5 值

如前所述，认证新的 IOS 文件是成功升级 IOS 的关键。该 MD5 值可以从思科的网站上获得，或者你可以在新的 IOS 下载后，使用`WinMD5.exe`等工具甚至命令行来检查文件的 MD5 值。在上传文件之前，我们要检查这个 MD5 值是否正确，以再次检查您将要上传的文件的完整性。当您手动将新的 IOS 文件上传到 TFTP 或 FTP 服务器时，您将手动验证这一点，但是在我们的 IOS 升级工具中，我们将 TFTP/FTP 文件传输方法替换为安全复制协议(SCP)文件传输。在文件传输发生之前，我们希望对照良好的 MD5 值检查 SCP 文件夹中 IOS 文件的 MD5 值，这样可以保证文件的完整性，从而避免意外的结果。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| one | 首先，使用 WinSCP 或 FileZilla 创建一个目录来放置新的 IOS 文件。见图 [18-4](#Fig4) 。 |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `mkdir new_ios` |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `cd new_ios` |
|   | `pynetauto@ubuntu20s1:~/my_tools/new_ios$` `pwd` |
|   | `/home/pynetauto/my_tools/new_ios` |
|   | `pynetauto@ubuntu20s1:~/my_tools/new_ios$` `ls` |
|   | `csr1000v-universalk9.16.09.06.SPA.bin`![../images/492721_1_En_18_Chapter/492721_1_En_18_Fig4_HTML.jpg](../images/492721_1_En_18_Chapter/492721_1_En_18_Fig4_HTML.jpg)图 18-4。ubuntu20s1，将新的 IOS 复制到 new_ios 目录 |
| Two | 创建`tool4_md5_linux`目录；然后复制`read_info5.py`文件作为`md5_validate1.py`脚本的基础。还有，为了帮助我们的开发，复制`devices_info.csv`文件。`read_info5.py`和`devices_info.csv`文件都来自于`tool3`开发。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/new_ios$``cd`T2】 |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `pwd` |
|   | `/home/pynetauto/my_tools` |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `mkdir tool4_md5_linux` |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `cd tool4_md5_linux` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool4_md5_linux$` `cp /home/pynetauto/my_tools/tool3_read_csv/read_info5.py ./md5_validate1.py` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool4_md5_linux$` `cp /home/pynetauto/my_tools/tool3_read_csv/devices_info.csv ./devices_info.csv` |
|   | 我们想要修改来自`read_info5.py`的代码的最后一个`for`循环，所以我们的任务是修改这个`for`循环，并添加一个函数来检查刚刚复制的 IOS 文件的 MD5 值，并检查稍后在闪存大小检查期间要使用的文件大小。 |
|   | `md5_validate1.py` |
|   | `import pandas as pd` |
|   | `df = pd.read_csv(r'./devices_info.csv')` |
|   | `number_of_rows = len(df.index)` |
|   | `# Read the values and save as a list, read column as df and save it as a list` |
|   | `devicename = list(df['devicename'])` |
|   | `device = list(df['device'])` |
|   | `devicetype = list(df['devicetype'])` |
|   | `ip = list(df['host'])` |
|   | `newios = list(df['newios'])` |
|   | `newiosmd5 = list(df['newiosmd5'])` |
|   | `# Convert the list into a device_list` |
|   | `device_list = []` |
|   | `for index, rows in df.iterrows():` |
|   | `device_append = [rows.devicename, rows.device, \` |
|   | `rows.devicetype, rows.host, rows.newios, rows.newiosmd5]` |
|   | `device_list.append(device_append)` |
|   | `for x in device_list:` |
|   | `newios, newiosmd5 = x[4], x[5].lower()` |
|   | `print(newios, newiosmd5)` |
| **3** | 现在为内置的`os.path`和`hashlib`模块添加导入代码。`hashlib`将用于检查 Linux 服务器上文件的 MD5，而`os.path`将用于计算实际的文件大小。脚本的中间部分与复制的脚本相同。尽管如此，您仍将更改`device_list:`中的`for x`,以便脚本返回在服务器端计算的 MD5 值和`newios`大小，稍后将使用它们来检查路由器闪存上的空闲大小是否能容纳新的 IOS 大小。更改后，`md5_validate1.py`看起来应该类似于这样: |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool4_md5_linux$` `nano md5_validate2.py` |
|   | `md5_validate2.py` |
|   | `import pandas as pd` |
|   | `import os.path` |
|   | `import hashlib` |
|   | `[... omitted for brevity, same as read_info5.py]` |
|   | `for x in device_list:` |
|   | `print(x[0])` |
|   | `newios = x[4]` |
|   | `newiosmd5 = x[5].lower()` |
|   | `newiosmd5hash = hashlib.md5()` |
|   | `file = open(f'/home/pynetauto/my_tools/new_ios/{newios}', 'rb')` `# change path to your own path` |
|   | `content = file.read()` |
|   | `newiosmd5hash.update(content)` |
|   | `newiosmd5server = newiosmd5hash.hexdigest()` |
|   | `print(newiosmd5server)` |
|   | `newiossize = round(os.path.getsize(f'/home/pynetauto/my_tools/new_ios/{newios}')/1000000, 2)` |
|   | `print(newiossize, "MB")` |
|   | 运行该脚本，它应该返回服务器端的 IOS MD5 值和实际的 IOS 大小(以兆字节为单位)。您还将学习如何检查路由器的已用、空闲和总大小，以确保闪存有足够的空闲空间来容纳新的 IOS。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool4_md5_linux$` `python3 md5_validate2.py` |
|   | `csr1000v-1` |
|   | `77878ae6db8e34de90e2e3e83741bf39` |
|   | `436.57 MB` |
|   | `csr1000v-2` |
|   | `77878ae6db8e34de90e2e3e83741bf39` |
|   | `436.57 MB` |
| four | 一旦您对步骤 3 中的结果感到满意，就在最后一行的末尾添加一个`if-else`语句，看看如何通过测试两个 MD5 值来控制脚本流。 |
|   | `md5_validate3.py` |
|   | `import pandas as pd` |
|   | `import os.path` |
|   | `import hashlib` |
|   | `df = pd.read_csv(r'./devices_info.csv')` |
|   | `number_of_rows = len(df.index)` |
|   | `# Read the values and save as a list, read column as df and save it as a list` |
|   | `devicename = list(df['devicename'])` |
|   | `device = list(df['device'])` |
|   | `devicetype = list(df['devicetype'])` |
|   | `ip = list(df['host'])` |
|   | `newios = list(df['newios'])` |
|   | `newiosmd5 = list(df['newiosmd5'])` |
|   | `# Convert the list into a device_list` |
|   | `device_list = []` |
|   | `for index, rows in df.iterrows():` |
|   | `device_append = [rows.devicename, rows.device, \` |
|   | `rows.devicetype, rows.host, rows.newios, rows.newiosmd5]` |
|   | `device_list.append(device_append)` |
|   | `for x in device_list:` |
|   | `print(x[0])` |
|   | `newios = x[4]` |
|   | `newiosmd5 = str(x[5].lower()).strip()` |
|   | `print(newiosmd5)` |
|   | `newiosmd5hash = hashlib.md5()` |
|   | `file = open(f'/home/pynetauto/my_tools/new_ios/{newios}', 'rb')` |
|   | `content = file.read()` |
|   | `newiosmd5hash.update(content)` |
|   | `newiosmd5server = newiosmd5hash.hexdigest()` |
|   | `print(newiosmd5server.strip())` |
|   | `newiossize = round(os.path.getsize(f'/home/pynetauto/my_tools/new_ios/{newios}')/1000000, 2)` |
|   | `print(newiossize, "MB")` |
|   | `if newiosmd5server == newiosmd5:` |
|   | `print("MD5 values matched!")` |
|   | `else:` |
|   | `print("Mismatched MD5 values. Exit")` |
|   | `exit()` |
|   | 当您运行该脚本时，您将看到类似于以下输出的结果。现在，您已经确认了所读取的信息已经被转换成 Python 变量，以便在我们的脚本中使用。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool4_md5_linux$` `python3 md5_validate3.py` |
|   | `csr1000v-1` |
|   | `77878ae6db8e34de90e2e3e83741bf39` |
|   | `77878ae6db8e34de90e2e3e83741bf39` |
|   | `436.57 MB` |
|   | `MD5 values matched!` |
|   | `csr1000v-2` |
|   | `77878ae6db8e34de90e2e3e83741bf39` |
|   | `77878ae6db8e34de90e2e3e83741bf39` |
|   | `436.57 MB` |
|   | `MD5 values matched!` |

## 检查 Cisco 路由器上的闪存大小

您在前面的脚本中学习了如何获取服务器上的 IOS 大小，新的 IOS 文件大小为 436.57 MB。在将这个新的 IOS 文件上传到路由器的闪存之前，您必须检查闪存中是否有足够的可用空间。如果闪存有足够的空闲空间，上传可以立即进行。不过，如果闪存大小不够大，您将不得不删除旧的或冗余的文件，或者对于较旧的 IOS 设备，您将需要从闪存中删除当前运行的 IOS 文件。在引导过程中，IOS 从闪存复制并解压缩到随机存取存储器(RAM)中。在一些最新的思科平台上，文件已经解压缩，以节省开机自检(POST)过程中的时间。无论哪种方式，您都需要为新的 IOS 文件腾出足够的空间。要获得 Cisco 设备上的空闲闪存大小，您可以使用`show flash:`或`dir`命令，然后使用正则表达式解析信息。如果您知道要运行什么命令以及需要什么信息，就很容易得到这些信息。尽管如此，许多供应商网络设备不提供 API 支持。此外，SNMP 在处理这类信息时也有其局限性。虽然这不是收集我们想要的数据的最聪明或最复杂的方式，但这可能是一些设备的唯一选择。

计算出空闲闪存大小后，如果 IOS 大小超过了空闲闪存大小，我们希望给用户(或脚本)一个选项来定位旧的 IOS 文件并删除它。有时，路由器的闪存上可能有一个很大的文件，所以在这种情况下，我们还必须给用户(或脚本)一个选项来搜索文件和删除一个大文件。让我们看看这是如何实现的。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 创建另一个名为`tool5_fsize_cisco`的工作目录，然后创建一个新的脚本来运行和捕获`dir`或`show flash:`命令。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool4_md5_linux$``cd`T2】 |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `mkdir tool5_fsize_cisco` |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `cd tool5_fsize_cisco` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool5_fsize_cisco$` `nano check_flash1.py` |
|   | 编写以下脚本来捕获 Cisco 路由器上的`dir`命令的输出。在 IOS XE 路由器上，使用`dir`命令更容易捕获信息，但是在其他设备上，`show flash:`命令在大多数设备上都有效。在这个练习中，我们将使用`dir`命令，因为输出更短。 |
|   | `check_flash1.py` |
|   | `import time` |
|   | `from netmiko import ConnectHandler` |
|   | `# Borrowed from read_info7.py result.` |
|   | `devices_list =[` |
|   | `{` |
|   | `'device_type': 'cisco_xe',` |
|   | `'host': '192.168.183.111',` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123'` |
|   | `},` |
|   | `{` |
|   | `'device_type': 'cisco_xe',` |
|   | `'host': '192.168.183.222',` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123'` |
|   | `}]` |
|   | `for device in devices_list:` |
|   | `net_connect = ConnectHandler(**device)` |
|   | `net_connect.send_command("terminal length 0")` |
|   | `showdir = net_connect.send_command("dir")` |
|   | `#showflash = net_connect.send_command("show flash:") # Alternatively use 'show flash:'` |
|   | `print(showdir)` |
|   | `print("-"*80)` |
|   | `time.sleep(2)` |
|   | 当您再次运行 check_flash1.py 脚本时，输出会显示文件详细信息和闪存使用情况。我们对路由器闪存中的空闲空间感兴趣。这里，我们感兴趣的是输出的最后一行中的“总共 7897796608 个字节(5230376448 个空闲字节)”。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool5_fsize_cisco$` `python3 check_flash1.py` |
|   | `Directory of bootflash:/` |
|   | `11  drwx            16384  Sep 28 2020 22:15:16 +00:00  lost+found` |
|   | `32513  drwx             4096  Jan 15 2021 08:38:08 +00:00  .installer` |
|   | `12  -rw-        377500632  Sep 28 2020 22:15:59 +00:00  csr1000v-mono-universalk9.16.07.03.SPA.pkg` |
|   | `13  -rw-      38978681  Sep 28 2020 22:15:59 +00:00  csr1000v-rpboot.16.07.03.SPA.pkg` |
|   | `[...omitted for brevity]` |
|   | `430785  drwx             4096   Dec 3 2020 10:21:10 +00:00  iox` |
|   | `65025  drwx             4096   Dec 3 2020 10:21:25 +00:00  .dbpersist` |
|   | `89409  drwx             4096   Dec 3 2020 10:22:16 +00:00  onep` |
|   | `7897796608 bytes total (6230376448 bytes free)` |
|   | `--------------------------------------------------------------------------------` |
| **2** | 这是第一个路由器的`dir`输出。让我们看看如何使用正则表达式来获得“空闲字节” |
|   | `Directory of bootflash:/` |
|   | `11  drwx            16384  Sep 28 2020 22:15:16 +00:00  lost+found` |
|   | `32513  drwx             4096   Oct 5 2020 11:50:08 +00:00  .installer` |
|   | `12  -rw-        377500632  Sep 28 2020 22:15:59 +00:00  csr1000v-mono-universalk9.16.07.03.SPA.pkg` |
|   | `13  -rw-         38978681  Sep 28 2020 22:15:59 +00:00  csr1000v-rpboot.16.07.03.SPA.pkg` |
|   | `14  -rw-             1941  Sep 28 2020 22:15:59 +00:00  packages.conf` |
|   | `365761  drwx             4096  Sep 28 2020 22:16:36 +00:00  core` |
|   | `390145  drwx             4096  Sep 28 2020 22:16:29 +00:00  .prst_sync` |
|   | `81281  drwx             4096  Sep 28 2020 22:16:36 +00:00  .rollback_timer` |
|   | `455169  drwx            12288   Oct 5 2020 12:00:45 +00:00  tracelogs` |
|   | `48769  drwx             4096  Sep 28 2020 22:16:55 +00:00  virtual-instance` |
|   | `15  -rw-               30   Oct 5 2020 11:51:27 +00:00  throughput_monitor_params` |
|   | `16  -rw-              848   Oct 5 2020 11:51:35 +00:00  cvac.log` |
|   | `447041  drwx             4096  Sep 28 2020 22:17:39 +00:00  CRDU` |
|   | `17  -rw-               16  Sep 28 2020 22:17:43 +00:00  ovf-env.xml.md5` |
|   | `18  -rw-              157   Oct 5 2020 11:51:35 +00:00  csrlxc-cfg.log` |
|   | `19  -rw-               35  Sep 28 2020 22:22:44 +00:00  pnp-tech-time` |
|   | `20  -rw-            51746  Sep 28 2020 22:22:45 +00:00  pnp-tech-discovery-summary` |
|   | `7897796608 bytes total (``7060598784`T2】 |
|   | 由于有许多数字，我们必须精确地定位数字，这可以通过使用积极的前瞻方法来实现。由于数字在`bytes free`的前面，我们可以用它作为搜索句柄，简单地查找这个特定字符串前面的数字串。因此，所需的正则表达式如下所示: |
|   | `\d+(?=\sbytes\sfree\))`

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
&#124; **Regular expression** &#124; **Explanation** &#124;
&#124; `\d+` &#124; This means any number more than one number. &#124;
&#124; `(?=)` &#124; This is a forward-looking regular expression. &#124;
&#124; `\sbytes\sfree\)` &#124; We are looking for an actual string, but we only use it to search. We match the string in front of this string. `\s` means blank. &#124;

 |
|   | 所以，前面的正则表达式应该匹配出现在`bytes free`前面的任何数字，在我们的例子中是 7060598784。 |
| **3** | 复制第一个脚本，并创建以下脚本来应用我们的正则表达式: |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool5_fsize_cisco$` `cp check_flash1.py check_flash2.py` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool5_fsize_cisco$` `nano check_flash2.py` |
|   | `nano check_flash2.py` |
|   | `import time` |
|   | `from netmiko import ConnectHandler` |
|   | `import re` `# Import re module` |
|   | `# This is borrowed from read_info7.py result` |
|   | `devices_list =[` |
|   | `{` |
|   | `'device_type': 'cisco_xe',` |
|   | `'host': '192.168.183.111',` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123'` |
|   | `},` |
|   | `{` |
|   | `'device_type': 'cisco_xe',` |
|   | `'host': '192.168.183.222',` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123'` |
|   | `}]` |
|   | `for device in devices_list:` |
|   | `net_connect = ConnectHandler(**device)` |
|   | `net_connect.send_command("terminal length 0")` |
|   | `showdir = net_connect.send_command("dir")` |
|   | `#showflash = net_connect.send_command("show flash:")` |
|   | `#print(showdir) # Hash out the line` |
|   | `print("-"*80)` |
|   | `time.sleep(2)` |
|   | `p1 = re.compile("\d+(?=\sbytes\sfree\))")` `# Compiled Regular expression` |
|   | `m1 = p1.findall(showdir)` `# Match regular expression` |
|   | `flashfree =  ((int(m1[0])/1000000))` `# convert bytes into MB` |
|   | `print(flashfree)` |
|   | 运行前面的脚本，现在您有了以兆字节为单位的空闲字节。第一个值来自`csr1000v-1`，第二个值来自`csr1000v-2`。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool5_fsize_cisco$` `python3 check_flash2.py` |
|   | `--------------------------------------------------------------------------------` |
|   | `7060.598784` |
|   | `--------------------------------------------------------------------------------` |
|   | `7060.578304` |
|   | 当我们将之前的脚本与之前练习中的`md5_validate2.py`结合起来时，我们可以检查闪存的空闲大小是否大于新的 IOS 文件大小。可以使用比较的结果来改变应用流程。路由器上几乎有 7 GB 的空闲闪存，我们的 IOS 大小为 436.57 MB，因此在将文件上传到闪存之前，无需删除任何文件。但是，如上所述，在较旧的 Cisco 设备上，闪存的大小通常很紧，作为脚本的一部分，您可能需要为用户提供一个选项，从闪存中删除一些文件，以便为新的 IOS 上传腾出空间。通常，我们会在路由器或交换机等关键设备上升级 IOS。工程师投入超过 80%的时间来准备这种类型的更改，这意味着在准备工作开始时就可以检测到闪存空间的不足。大多数情况下，问题需要在实际升级之前解决。但是有时工程师会在变更准备过程中试图偷工减料。如今，大多数声誉卓著的 IT 驱动型公司都采用了 ITIL 流程，而 ITIL 则负责变革管理。这种变更案例的所有者甚至在变更被涉众批准之前就执行端到端的检查，只有这样变更才能开始。出于这个原因，为了节省本章的篇幅，我排除了让用户选择删除文件或在目录中查找文件的脚本。我会把这个作为你的家庭作业，让你知道如何把这个特性添加到你的脚本中。 |

## 备份运行配置、接口状态和路由表

假设我们的路由器有足够的闪存来容纳路由器的新 IOS，您现在想要备份运行配置。在大多数生产环境中，路由器的配置将在配置备份服务器上每天或每周备份一次。在这种情况下，您必须确保正在升级的设备的最新备份配置不超过几个小时。换句话说，最新的路由器备份是您在路由器重新加载之前捕获的。使用 Python 脚本，有两种方法可以备份路由器的`running-config`。第一种方法是将配置保存在 Python 服务器的本地磁盘上，第二种方法是运行`copy running-config tftp/ftp:`命令。如果备份将存储一段时间，第二种方法将是首选的`running-config`备份方法。尽管如此，如果这个备份是为了恢复过程，如果系统由于某种看不见的原因丢失了配置，在您的服务器上做一个备份就足够了。因此，您将学习如何通过 SSH 连接使用`show`命令保存运行配置。

在进行任何更改之前，请先备份运行配置，然后再重新加载路由器。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 同样，创建一个单独的目录来处理新工具。因为本节的内容已经在前面的章节中介绍过了，所以您应该对文件处理非常熟悉。您将在一次尝试中编写这个工具，不需要重复，所以请在这里键入每个单词，并参考代码行中的解释。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool5_fsize_cisco$``cd`T2】 |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `mkdir tool6_make_backup` |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `cd tool6_make_backup` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool6_make_backup$` `nano make_backup1.py` |
|   | 这个脚本将使每个设备的字典和它们的变量变得更加简单。您将调出每个设备的 IP 地址，以形成每个文件的名称。这样，每台设备都将有自己唯一的备份文件名，以后在对问题进行故障排除时，您将不会有一个包含多台设备配置的文件。您可以运行任何`show`命令并备份路由器的运行配置。然而，思科路由器值得捕捉的一些基本的`show`命令有`show running-config`、`show ip route`和`show ip interface brief`。如果您正在使用 Cisco 交换机，`show running-config`、`show ip interface brief`和`show switch`命令可能会有所帮助。现在，让我们编写并运行这段代码。 |
|   | `make_backup1.py` |
|   | `import time` |
|   | `from netmiko import ConnectHandler` |
|   | `# Converted the list of dictionaries back to each variables` |
|   | `device1` `= {` |
|   | `'device_type': 'cisco_xe',` |
|   | `'host': '192.168.183.111',` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123'` |
|   | `}` |
|   | `device2` `= {` |
|   | `'device_type': 'cisco_xe',` |
|   | `'host': '192.168.183.222',` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123'` |
|   | `}` |
|   | `devices_list = [device1, device2]` `# Make a list of devices` |
|   | `for device in devices_list:` `# Read each device from device_list` |
|   | `print(device)` `# Print out each device information during development` |
|   | `ip = str(device['host'])` `# To make unique file names, assign IP address of device as variable, ip.` |
|   | `f1 = open(ip + '_showrun_1.txt', 'w+')` `# Create and open f1` |
|   | `net_connect = ConnectHandler(**device)` `#Connect to device, ** denotes parsing of a dictionary` |
|   | `net_connect.send_command("terminal length 0")` `# Change terminal length to 0` |
|   | `showrun = net_connect.send_command("show running-config")` `# Run show run and save to showrun variable` |
|   | `f1.write(showrun)` `# Write showrun to f1\. showrun is in the memory.` |
|   | `time.sleep(1)` `# Pause for 1 second` |
|   | `f1.close()` `# Close f1` |
|   | `# The remaining codes are same as above except the file name and actual command` |
|   | `f2 = open(ip + '_show_ip_route_1.txt', 'w')` `# Crate and open f2` |
|   | `#net_connect.enable()` |
|   | `showiproute = net_connect.send_command("show ip route")` |
|   | `#net_connect.exit_enable_mode()` |
|   | `f2.write(showiproute)` |
|   | `time.sleep(1)` |
|   | `f2.close()` |
|   | `f3 = open(ip + '_show_ip_int_bri_1.txt', 'w')` |
|   | `showiproute = net_connect.send_command("show ip interface brief")` |
|   | `f3.write(showiproute)` |
|   | `time.sleep(1)` |
|   | `f3.close()` |
|   | `print("All tasks completed successfully")` `# Information to let you know that all tasks completed` |
| **2** | 现在运行脚本。它将通过运行您选择的`show`命令进行备份。这里我们将三个`show`命令输出捕获到不同的文件中。稍后，升级后检查将重新运行相同的命令，并创建重新加载后文件。然后，脚本将执行升级后检查，以确保升级前后的配置保持相同，并且 IOS 升级不会导致任何故障。 |
|   | 一旦你完成了编写`make_backup1.py` Python 代码，运行它来备份`show`命令。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool6_make_backup$` `python3 make_backup1.py` |
|   | `{'device_type': 'cisco_xe', 'host': '192.168.183.111', 'username': 'pynetauto', 'password': 'cisco123', 'secret': 'cisco123'}` |
|   | `{'device_type': 'cisco_xe', 'host': '192.168.183.222', 'username': 'pynetauto', 'password': 'cisco123', 'secret': 'cisco123'}` |
|   | `All tasks completed successfully` |
|   | 使用`ls –lh` Linux 命令检查`show`命令的备份和运行配置。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool6_make_backup$` `ls -lh` |
|   | `total 28K` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto  323 Jan 15 15:33 192.168.183.111_show_ip_int_bri_1.txt` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto  842 Jan 15 15:33 192.168.183.111_show_ip_route_1.txt` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto 4.0K Jan 15 15:33 192.168.183.111_showrun_1.txt` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto  323 Jan 15 15:33 192.168.183.222_show_ip_int_bri_1.txt` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto  842 Jan 15 15:33 192.168.183.222_show_ip_route_1.txt` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto 1.8K Jan 15 15:33 192.168.183.222_showrun_1.txt` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto 1.8K Jan 15 15:33 make_backup1.py` |

您已经成功创建了一个方便的工具，可以在进行任何配置更改之前备份您的设备。现在，在将新的 IOS 上传到 Cisco 路由器之前，我们将完成初始预检查工具。让我们看看如何将新的 IOS 上传到路由器的闪存中。

## B 部分:IOS 上传和更多预检工具开发

让我们进入下一个话题。

## IOS 上传工具

在整个预检查通过并且备份了每台设备的当前运行配置之后，我们需要将新的 IOS 从服务器上传到路由器的闪存中。如前所述，文件上传过程使用 SCP，因为`netmiko`库有一个内置模块，支持不同文件大小的计时。作为一个`netmiko`库用户，我们不用担心文件有多大才能上传文件；`netmiko`已经有一个内置模块来处理这个问题。再次感谢 Kirk Byers 编写并分享了这样一个方便的库。我已经用 FTP 和 TFTP 两种方法测试了文件传输，虽然它们工作正常，但不如`netmiko`的 SCPConn 文件传输方法可靠。

我们已经知道，我们试图上传的实际 IOS 文件大小为 436.57 MB，在生产网络上，将这样的文件上传到网络设备的闪存大约需要 8 到 15 分钟。即使在您计算机上的实验室拓扑中，也需要几分钟。所以，当你开发一个测试工具时，你应该使用一个更小的文件，这样可以节省你的时间。在这个例子中，我使用完整的 436.57 MB 文件进行演示。在生产中，一个网络的速度会不同于另一个网络；因此，文件传输时间也会因网络不同而有很大差异。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 为 IOS 上传工具创建另一个工作目录。这一次，您将复制上一节中创建的脚本，并重写代码来测试文件上传。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool6_make_backup$``cd`T2】 |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `mkdir tool7_upload_ios` |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `cd tool7_upload_ios` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool7_upload_ios$` `pwd` |
|   | `/home/pynetauto/my_tools/tool7_upload_ios` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool7_upload_ios$` `cp /home/pynetauto/my_tools/tool6_make_backup/make_backup1.py ./upload_ios1.py` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool7_upload_ios$` `ls` |
|   | `upload_ios1.py` |
| **2** | 在 IOS 上传部分，我们将新的 IOS 文件复制到了`/home/pynetauto/my_tools/new_ios/`目录。对于 SCP 文件上传测试，我们可以将文件位置指向这个文件夹，或者复制当前工作目录。所以，`s_newios`(源文件位置)指向新的 IOS 文件:`/home/pynetauto/my_tools/new_ios/csr1000v-universalk9.16.09.06.SPA.bin`。对于`d_newios`(对于目标文件名，使用新的 IOS 文件名，以`.bin`结尾)。文件将被保存到路由器的`flash:/`目录中。 |
|   | Cisco 路由器(或交换机)上需要三项配置，SCP 文件传输才能启动并成功地将文件复制到路由器。首先，用户必须拥有 15 级权限，其次，必须配置`aaa`身份验证登录，第三，必须预先配置授权`exec`。如果设备访问由生产环境中的 TACACS 服务器控制，您应该对以下脚本稍作修改。登录将以同样的方式工作，只是身份验证是通过服务器进行的。此外，在许多环境中，不使用 TACACS 服务器。在这种情况下，我们可以利用本地`aaa`授权和认证，这就是您在本例中将要使用的。该脚本将首先检查您的用户名是否具有 15 级权限，然后检查是否配置了`aaa`认证和授权。 |
|   | SCP 文件传输的最后一个要求是路由器必须扮演 SCP 服务器的角色，所以我们会检查是否已经配置了`ip scp server`命令，如果没有配置，脚本会在路由器上启用 SCP 服务，然后启动 IOS 文件传输过程。文件传输结束时，此 SCP 服务将被禁用。 |
|   | 现在修改 Python 文件的内容，当您完成 SCP IOS 上传应用程序时，它应该类似于下面的内容。如果您想添加一些其他功能，您可以这样做，并探索其他选项。免费 Python 脚本的美妙之处在于没有像 Ansible 中的 YAML 代码那样的束缚。使用 Python 脚本，你是汽车的设计师、机械师和司机，而使用 Ansible，你只是一个司机。您可以继续使用 Python 脚本编写您的工具。和以前一样，你会在重要的代码行旁边找到解释。 |
|   | `upload_ios1.py` |
|   | `import time` |
|   | `from netmiko import ConnectHandler, SCPConn` `# Import SCPConn` |
|   | `# From section 10.5.3` |
|   | `s_newios = "/home/pynetauto/my_tools/new_ios/csr1000v-universalk9.16.09.06.SPA.bin"` `# Source file, ensure you have specified the correct directory path` |
|   | `d_newios = "csr1000v-universalk9.16.09.06.SPA.bin"` `# Destination file name` |
|   | `# newiosmd5 = "77878ae6db8e34de90e2e3e83741bf39"` `# MD5 value of new IOS file` |
|   | `device1 = {` |
|   | `'device_type': 'cisco_xe',` |
|   | `'host': '192.168.183.111',` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123'` |
|   | `}` |
|   | `device2 = {` |
|   | `'device_type': 'cisco_xe',` |
|   | `'host': '192.168.183.222',` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123'` |
|   | `}` |
|   | `devices_list = [device1, device2]` |
|   | `for device in devices_list` `:` |
|   | `print(device)` `# Print dictionary item for confirmation only` |
|   | `ip = str(device['host'])` `# Assign a variable, ip to IP Address of device` |
|   | `username = str(device['username'])` `# Assign a variable, username to username of device` |
|   | `net_connect = ConnectHandler(**device)` `# Parse netmiko dictionary to ConnectHandler` |
|   | `net_connect.send_command("terminal length 0")` `# Set terminal to display without any breaks` |
|   | `showrun = net_connect.send_command("show running-config")` `# Run show running-config` |
|   | `check_priv15 = (f'username {username} privilege 15')` `# Assign a variable to username config` |
|   | `aaa_authenication = "aaa authentication login default local enable"` `# Assign a variable to authentication config` |
|   | `aaa_authorization = "aaa authorization exec default local"` `# Assign a variable to authorization config` |
|   | `if check_priv15 in showrun` `: # Check if showrun contains (meets) basic configuration requirements` |
|   | `print(f"{username} has level 15 privilege - OK")` |
|   | `if aaa_authenication in showrun` `:` |
|   | `print("check_aaa_authentication - OK")` |
|   | `if aaa_authorization in showrun:` |
|   | `print("check_aaa_authorization - OK")` `# All three conditions are met, then continue` |
|   | `else:` |
|   | `print("aaa_authorization - FAILED ")` |
|   | `exit()` `# exit application for a review` |
|   | `else:` |
|   | `print("aaa_authentication - FAILED ")` |
|   | `exit()` `# exit application for a review` |
|   | `else:` |
|   | `print(f"{username} has not enough privilege - FAILED")` |
|   | `exit()` `# exit application for a review` |
|   | `net_connect.enable(cmd='enable 15')` `# Enable level 15 privilage` |
|   | `net_connect.config_mode()` `# Enter configuration mode` |
|   | `net_connect.send_command('ip scp server enable')` `# Enable SCP service on the router` |
|   | `net_connect.exit_config_mode()` `# Exit configuration mode` |
|   | `time.sleep(1)` `# Pause for  1 second` |
|   | `print("New IOS uploading in progress! Please wait...")` |
|   | `scp_conn = SCPConn(net_connect)` `# Create object for netmiko SCPConn` |
|   | `scp_conn.scp_transfer_file(s_newios, d_newios)` `# Start file transfer from source to destination` |
|   | `scp_conn.close()` `# close scp_conn session` |
|   | `time.sleep(1)` `# Pause for 1 second` |
|   | `net_connect.config_mode()` `# Enter configuration mode` |
|   | `net_connect.send_command('no ip scp server enable')` `# Disable SCP service on the router` |
|   | `net_connect.exit_config_mode()` `# Exit configurator mode` |
|   | `print("-"*80)` `# Line divider` |
| **3** | 我们知道用户`pynetauto`被正确地配置了 15 级管理员权限，但是`aaa`新模型在`csr1000v-1`路由器上没有启用。让我们运行前面的脚本来测试返回了哪个错误消息。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool7_upload_ios$` `python3 upload_ios1.py` |
|   | `{'device_type': 'cisco_xe', 'host': '192.168.183.111', 'username': 'pynetauto', 'password': 'cisco123', 'secret': 'cisco123'}` |
|   | `pynetauto has level 15 privilege - OK` |
|   | `aaa_authentication - FAILED` |
|   | 现在，继续向第一台路由器添加以下`aaa`配置: |
|   | `csr1000v-1(config)#` `aaa new-model` |
|   | `csr1000v-1(config)#` `aaa authentication login default local enable` |
| **4** | 让我们再运行一次 IOS 上传应用程序，观察脚本在哪里停止。尽管 admin 用户拥有 15 级权限，但脚本抱怨用户没有正确的权限，因为它现在已经转移到了`aaa`本地认证。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool7_upload_ios$` `python3 upload_ios1.py` |
|   | `{'device_type': 'cisco_xe', 'host': '192.168.183.111', 'username': 'pynetauto', 'password': 'cisco123', 'secret': 'cisco123'}` |
|   | `pynetauto has not enough privilege - FAILED` |
|   | 为了解决这个问题，将最后一个`aaa`配置添加到第一个路由器。 |
|   | `csr1000v-1(config)#` `aaa authorization exec default local` |
| **5** | 停下来！暂时不要运行脚本。如果您再次运行该应用程序，您应该会在控制台上看到以下消息，应用程序将进入下一阶段，检查路由器上的 SCP 配置。 |
|   | 为了简单起见，我们可以在启动新的 IOS 上传到第一个设备之前检查这一点。该检查可以在脚本开始时在所有设备上执行，因此我们可以在上传开始之前检测所有设备上的任何配置问题。在最终脚本中，我们将尝试稍微更改这一部分，以便它成为预检查脚本的一部分。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool7_upload_ios$` `python3 upload_ios1.py` |
|   | `{'device_type': 'cisco_xe', 'host': '192.168.183.111', 'username': 'pynetauto', 'password': 'cisco123', 'secret': 'cisco123'}` |
|   | `pynetauto has level 15 privilege - OK` |
|   | `check_aaa_authentication - OK` |
|   | `check_aaa_authorization - OK` |
| **6** | 继续在第二台路由器`csr1000v-2`上启用`aaa`配置。 |
|   | `csr1000v-2(config)#` `aaa new-model` |
|   | `csr1000v-2(config)#` `aaa authentication login default local enable` |
|   | `csr1000v-2(config)#` `aaa authorization exec default local` |
| **7** | 然后，在两台路由器上启用以下调试命令: |
|   | `csr1000v-2#` `debug ip scp` |
|   | `Incoming SCP debugging is on` |
|   | `csr1000v-2#` `terminal monitor` |
|   | `csr1000v-1#` `debug ip scp` |
|   | `Incoming SCP debugging is on` |
|   | `csr1000v-1#` `ter mon` |
| **8** | 现在重新运行 Python 脚本。如果所有的配置验证都通过了，新的 IOS 文件传输将在第一台路由器上开始。当文件传输在`csr1000v-1`完成时，相同的脚本将在第二台路由器`csr1000v-2`上运行。这里，我只演示了在两台路由器上上传 IOS，但是想象一下，如果我们有 20 或 200 台路由器来上传 IOS 映像。另外，请注意，现在我们可以将该脚本安排在工作时间之外运行，这样您就不必在获准回家之前盯着屏幕看几个小时了。这可能是自动化枯燥和重复的任务的最好的部分。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool7_upload_ios$` `python3 upload_ios1.py` |
|   | `{'device_type': 'cisco_xe', 'host': '192.168.183.111', 'username': 'pynetauto', 'password': 'cisco123', 'secret': 'cisco123'}` |
|   | `pynetauto has level 15 privilege - OK` |
|   | `check_aaa_authentication - OK` |
|   | `check_aaa_authorization – OK` |
|   | `New IOS uploading in progress! Please wait...` |
|   | `--------------------------------------------------------------------------------` |
|   | `{'device_type': 'cisco_xe', 'host': '192.168.183.222', 'username': 'pynetauto', 'password': 'cisco123', 'secret': 'cisco123'}` |
|   | `pynetauto has level 15 privilege - OK` |
|   | `check_aaa_authentication - OK` |
|   | `check_aaa_authorization – OK` |
|   | `New IOS uploading in progress! Please wait...` |
|   | `--------------------------------------------------------------------------------` |
|   | 在开发过程中，用户名、密码和密码被打印在屏幕上，以检查正在开发的应用程序是否如设计的那样工作，但是在生产实现中，您必须禁用任何冗余的`print()`语句。本书开头提到过，`print()`函数是给我们的；计算机不必把信息输出到屏幕上。 |
| **9** | 当脚本运行时，检查两台路由器的终端屏幕。如果您观察到以下屏幕日志，您就知道新的 IOS 文件传输已成功完成。 |
|   | `csr1000v-1#` |
|   | `*Jan 15 03:21:00.687: %SYS-5-CONFIG_I: Configured from console by pynetauto on vty1 (192.168.183.132)` |
|   | `*Jan 15 03:21:02.228: SCP: [22 -> 192.168.183.132:46546] send <OK>` |
|   | `*Jan 15 03:21:02.229: SCP: [22 <- 192.168.183.132:46546] recv C0644 436573677 csr1000v-universalk9.16.09.06.SPA.bin` |
|   | `*Jan 15 03:21:02.230: SCP: [22 -> 192.168.183.132:46546] send <OK>` |
|   | `*Jan 15 03:25:34.917: SCP: [22 <- 192.168.183.132:46546] recv 436573677 bytes` |
|   | `*Jan 15 03:25:34.918: SCP: [22 <- 192.168.183.132:46546] recv <OK>` |
|   | `*Jan 15 03:25:34.918: SCP: [22 -> 192.168.183.132:46546] send <OK>` |
|   | `*Jan 15 03:25:34.922: SCP: [22 <- 192.168.183.132:46546] recv <EOF>` |
|   | `*Jan 15 03:25:36.192: %SYS-5-CONFIG_I: Configured from console by pynetauto on vty1 (192.168.183.132)` |
|   | `csr1000v-2#` |
|   | `*Jan 15 03:25:37.522: %SYS-5-CONFIG_I: Configured from console by pynetauto on vty1 (192.168.183.132)` |
|   | `*Jan 15 03:25:39.072: SCP: [22 -> 192.168.183.132:36148] send <OK>` |
|   | `*Jan 15 03:25:39.073: SCP: [22 <- 192.168.183.132:36148] recv C0644 436573677 csr1000v-universalk9.16.09.06.SPA.bin` |
|   | `*Jan 15 03:25:39.074: SCP: [22 -> 192.168.183.132:36148] send <OK>` |
|   | `*Jan 15 03:30:10.935: SCP: [22 <- 192.168.183.132:36148] recv 436573677 bytes` |
|   | `*Jan 15 03:30:10.935: SCP: [22 <- 192.168.183.132:36148] recv <OK>` |
|   | `*Jan 15 03:30:10.935: SCP: [22 -> 192.168.183.132:36148] send <OK>` |
|   | `*Jan 15 03:30:10.937: SCP: [22 <- 192.168.183.132:36148] recv <EOF>` |
|   | `*Jan 15 03:30:12.230: %SYS-5-CONFIG_I: Configured from console by pynetauto on vty1 (192.168.183.132)` |
| **10** | 检查两台路由器上上传的文件，保存配置以完成任务。 |
|   | `csr1000v-1#` `show flash: &#124; in csr1000v-universalk9.16.09.06.SPA.bin` |
|   | `215  436573677 Oct 07 2020 03:25:34.0000000000 +00:00 /bootflash/csr1000v-universalk9.16.09.06.SPA.bin` |
|   | `csr1000v-1#` `write memory` |
|   | `Building configuration...` |
|   | `[OK]` |
|   | `csr1000v-2#` `show flash: &#124; in csr1000v-universalk9.16.09.06.SPA.bin` |
|   | `215  436573677 Oct 07 2020 03:30:10.0000000000 +00:00 /bootflash/csr1000v-universalk9.16.09.06.SPA.bin` |
|   | `csr1000v-2#` `write memory` |
|   | `Building configuration...` |
|   | `[OK]` |

## 检查 Cisco 设备闪存上的新 IOS MD5 值

在之前的 IOS 上传工具开发中，您已经将新的 IOS 版本成功上传到了`csr1000v-1`和`csr1000v-2`路由器。我们需要编写一个脚本来验证 verify IOS 命令，并验证路由器闪存上 IOS 副本的 MD5 值。这一次，我们将只允许脚本运行，如果实际的 IOS 文件被发现在`flash:/`根。然后运行`verify`命令，检查在一个成功的 IOS 验证命令之后，脚本将在输出中期望“Verified ”,因此将使用一个正则表达式来验证 IOS 验证结果。如果成功，脚本将打印出原始值的 MD5 值和闪存上新 IOS 文件的 MD5 值。我们还想继续运行这个应用程序，即使第一个路由器在网络上不可达，所以我们必须包含一个`netmiko`超时异常来解决这个问题。通常，即使您的脚本遇到异常，您也希望继续运行脚本，直到列表中的最后一个设备。

让我们快速编写这个应用程序，并在我们的实验室中测试它。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 和往常一样，让我们从创建一个新目录开始，然后创建一个新的 Python 脚本。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool7_upload_ios$``cd`T2】 |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `mkdir tool8_md5_cisco` |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `cd tool8_md5_cisco` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool8_md5_cisco$` `nano md5_verify1.py` |
| **2** | 这个脚本的大部分内容与前面的脚本相同。让我们快速重写代码来验证命令，并比较用户提供的 MD5 和路由器上计算的 MD5。应用程序流将基于两个 MD5 值比较的结果。 |
|   | 在完成用于 Cisco IOS 路由器的 IOS MD5 检查器应用程序后，您的脚本将类似于以下内容。和往常一样，你的脚本不需要看起来和这个一样，只要它被优化并且运行良好。尝试一次写一行代码，因为这是一个很好的实践，可以让你感受到以写代码为生是什么感觉。如果你喜欢什么都自己做，那么你会喜欢写代码。 |
|   | `md5_verify1.py` |
|   | `from netmiko import ConnectHandler` |
|   | `from netmiko.ssh_exception import  NetMikoTimeoutException` `# To handle Timeout/Network exception` |
|   | `import re` `# For match specific characters from the verified output` |
|   | `d_newios = "csr1000v-universalk9.16.09.06.SPA.bin"` |
|   | `newiosmd5 = "77878ae6db8e34de90e2e3e83741bf39"` |
|   | `device1 = {` |
|   | `'device_type': 'cisco_xe',` |
|   | `'host': '192.168.183.111',` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123',` |
|   | `'global_delay_factor': 2 # Run netmiko commands twice slower. If you are getting errors due to slow router/switch response, use these attributes to slow down the script` |
|   | `}` |
|   | `device2 = {` |
|   | `'device_type': 'cisco_xe',` |
|   | `'host': '192.168.183.222',` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123',` |
|   | `'global_delay_factor': 2` |
|   | `}` |
|   | `devices_list = [device1, device2]` |
|   | `for device in devices_list:` |
|   | `print(device)` |
|   | `ip = str(device['host'])` |
|   | `try:` |
|   | `net_connect = ConnectHandler(**device)` |
|   | `net_connect.send_command("terminal length 0")` |
|   | `locate_newios = net_connect.send_command(f"show flash: &#124; in {d_newios}")` `# Check router's flash for new IOS image file` |
|   | `if d_newios in locate_newios:` `# If new IOS is found on the router's flash, run this script` |
|   | `result = net_connect.send_command("verify /md5 flash:{} {}".format(d_newios,newiosmd5))` `# Cisco IOS/IOS XE verify command, run and assign variable result to the output` |
|   | `print(result)` `# Print the result, informational for user` |
|   | `net_connect.disconnect()` `# Disconnect session` |
|   | `p1 = re.compile(r'Verified')` `# Regular Expression (re) compiler for word 'Verified'` |
|   | `p2 = re.compile(r'[a-fA-F0-9]{31}[a-fA-F0-9]')` `# re compiler for MD5 value` |
|   | `verified = p1.findall(result)` `# Find 'Verified' in result` |
|   | `newiosmd5flash = p2.findall(result)` `# Find the MD5 value from result` |
|   | `if verified:` `# If 'Verified' was found in result, run this part of the script` |
|   | `result = True` |
|   | `print("-"*80)` |
|   | `print("MD5 values MATCH! Continue")` |
|   | `print("MD5 of new IOS on Server : ",newiosmd5)` |
|   | `print("MD5 of new IOS on flash  : ",newiosmd5flash[0])` |
|   | `print("-"*80)` |
|   | `else:` `# If 'Verified' was not found in result, print and exit the application` |
|   | `result = False` |
|   | `print("-"*80)` |
|   | `print("MD5 values DO NOT MATCH! Exiting.")` |
|   | `print("-"*80)` |
|   | `exit()` |
|   | `else:` `# If no new IOS file was found on the router's flash:/. Print the statement` |
|   | `print("No new IOS found on router's flash. Continue to next device...")` |
|   | `print("-"*80)` |
|   | `except (NetMikoTimeoutException):` `# Handle Timeout error due to network issue` |
|   | `print (f'Timeout error to : {ip}')` |
|   | `print("-"*80)` |
|   | `continue` `# Continue to next device` |
|   | `except unknown_error:` `# Handle other errors as exception` |
|   | `print ('Unknown error occured : ' + str(unknown_error))` |
|   | `print("-"*80)` |
|   | `continue` `# Continue to next device` |
|   | `print("Completed new IOS verification.")` `# Informational` |
| **3** | 确保两台路由器都已通电并处于正常工作模式。运行应用程序检查新上传的 IOS 映像文件的 MD5 值。如果一切正常，您应该会得到如下所示的输出。为了节省空间，省略了一些输出。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool8_md5_cisco$` `python3 md5_verify1.py` |
|   | `{'device_type': 'cisco_xe', 'host': '192.168.183.111', 'username': 'pynetauto', 'password': 'cisco123', 'secret': 'cisco123', 'global_delay_factor': 2}` |
|   | `...........................................................` `[omitted for brevity]` |
|   | `...........................................................................Done!` |
|   | `Verified (bootflash:csr1000v-universalk9.16.09.06.SPA.bin) = 77878ae6db8e34de90e2e3e83741bf39` |
|   | `--------------------------------------------------------------------------------` |
|   | `MD5 values MATCH! Continue` |
|   | `MD5 of new IOS on Server :  77878ae6db8e34de90e2e3e83741bf39` |
|   | `MD5 of new IOS on flash  :  77878ae6db8e34de90e2e3e83741bf39` |
|   | `--------------------------------------------------------------------------------` |
|   | `{'device_type': 'cisco_xe', 'host': '192.168.183.222', 'username': 'pynetauto', 'password': 'cisco123', 'secret': 'cisco123', 'global_delay_factor': 2}` |
|   | `..........................................................` `[...omitted for brevity]` |
|   | `...........................................................................Done!` |
|   | `Verified (bootflash:csr1000v-universalk9.16.09.06.SPA.bin) = 77878ae6db8e34de90e2e3e83741bf39` |
|   | `--------------------------------------------------------------------------------` |
|   | `MD5 values MATCH! Continue` |
|   | `MD5 of new IOS on Server :  77878ae6db8e34de90e2e3e83741bf39` |
|   | `MD5 of new IOS on flash  :  77878ae6db8e34de90e2e3e83741bf39` |
|   | `--------------------------------------------------------------------------------` |
|   | `Completed new verification.` |
| **4** | 要模拟`csr1000v-1`不在网络上(不可达)的场景，禁用千兆以太网 1。您必须通过 VMware 工作站的主控制台禁用该端口。 |
|   | `csr1000v-1#` `config terminal` |
|   | `csr1000v-1(config)#` `interface GigabitEthernet1` |
|   | `csr1000v-1(config-if)#` `shutdown` |
|   | 现在重新运行 Python 脚本来检查结果。因为我们已经添加了一个异常来解决这个问题，所以脚本将继续运行直到结束。如果没有添加异常处理程序，您将看到以下错误: |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool8_md5_cisco$` `python3 md5_verify1.py` |
|   | `{'device_type': 'cisco_xe', 'host': '192.168.183.111', 'username': 'pynetauto', 'password': 'cisco123', 'secret': 'cisco123', 'global_delay_factor': 2}` |
|   | `Traceback (most recent call last):` |
|   | `File "/usr/local/lib/python3.8/dist-packages/netmiko/base_connection.py", line 920, in establish_connection` |
|   | `self.remote_conn_pre.connect(**ssh_connect_params)` |
|   | `File "/usr/lib/python3/dist-packages/paramiko/client.py", line 368, in connect` |
|   | `raise NoValidConnectionsError(errors)` |
|   | `paramiko.ssh_exception.NoValidConnectionsError: [Errno None] Unable to connect to port 22 on 192.168.183.111` |
|   | 在处理上一个异常的过程中，发生了另一个异常: |
|   | `Traceback (most recent call last):` |
|   | `File``" md5_verify1.py"`T2】 |
|   | `net_connect = ConnectHandler(**device)` |
|   | `File "/usr/local/lib/python3.8/dist-packages/netmiko/ssh_dispatcher.py", line 312, in ConnectHandler` |
|   | `return ConnectionClass(*args, **kwargs)` |
|   | `File "/usr/local/lib/python3.8/dist-packages/netmiko/cisco/cisco_ios.py", line 17, in __init__` |
|   | `return super().__init__(*args, **kwargs)` |
|   | `File "/usr/local/lib/python3.8/dist-packages/netmiko/base_connection.py", line 346, in __init__` |
|   | `self._open()` |
|   | `File "/usr/local/lib/python3.8/dist-packages/netmiko/base_connection.py", line 351, in _open` |
|   | `self.establish_connection()` |
|   | `File "/usr/local/lib/python3.8/dist-packages/netmiko/base_connection.py", line 942, in establish_connection` |
|   | `raise NetmikoTimeoutException(msg)` |
|   | `netmiko.ssh_exception.NetmikoTimeoutException: TCP connection to device failed.` |
|   | `Common causes of this problem are:` |
|   | `1\. Incorrect hostname or IP address.` |
|   | `2\. Wrong TCP port.` |
|   | `3\. Intermediate firewall blocking access.` |
|   | `Device settings: cisco_xe 192.168.183.111:22` |
| **5** | 现在从第一台路由器上删除新的 IOS 版本，并检查您的脚本是否成功运行。您必须从 VMware 工作站控制台启用`csr1000v-1`的千兆以太网 1 端口，因为您将失去通过 SSH 与该设备的连接。 |
|   | `csr1000v-1#` `delete flash:/csr1000v-universalk9.16.09.06.SPA.bin` |
|   | `Delete filename [csr1000v-universalk9.16.09.06.SPA.bin]?` |
|   | `Delete bootflash:/csr1000v-universalk9.16.09.06.SPA.bin?` `[confirm]` |
|   | 该脚本应该成功运行，并继续运行，直到结束，这也不应该是我们的脚本中的一个节目停止。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool8_md5_cisco$` `python3 md5_verify2.py` |
|   | `{'device_type': 'cisco_xe', 'host': '192.168.183.111', 'username': 'pynetauto', 'password': 'cisco123', 'secret': 'cisco123', 'global_delay_factor': 2}` |
|   | `No new IOS found on router's flash. Continue to the next device...` |
|   | `--------------------------------------------------------------------------------` |
|   | `{'device_type': 'cisco_xe', 'host': '192.168.183.222', 'username': 'pynetauto', 'password': 'cisco123', 'secret': 'cisco123', 'global_delay_factor': 2}` |
|   | `...........................................................[omitted for brevity]` |
|   | `...........................................................................Done!` |
|   | `Verified (bootflash:csr1000v-universalk9.16.09.06.SPA.bin) = 77878ae6db8e34de90e2e3e83741bf39` |
|   | `--------------------------------------------------------------------------------` |
|   | `MD5 values MATCH! Continue` |
|   | `MD5 of new IOS on Server :  77878ae6db8e34de90e2e3e83741bf39` |
|   | `MD5 of new IOS on flash  :  77878ae6db8e34de90e2e3e83741bf39` |
|   | `--------------------------------------------------------------------------------` |
|   | `Completed new IOS verification.` |
| **6** | 您已经从`csr1000v-1`的 flash 中删除了新的 IOS 版本来验证我们的脚本。为了准备下一个实验，我们必须再次运行 IOS 上传工具。再次运行新的 IOS 上传脚本，以便在`csr1000v-1`的闪存上安装新的 IOS。 |
|   | 如果您只想在第一台路由器上上传文件，请删除或注释掉此处显示的`device2`或`csr1000v-2`信息；这将为你节省大约五分钟。 |
|   | `# device2 = {` |
|   | `# 'device_type': 'cisco_xe',` |
|   | `# 'host': '192.168.183.222',` |
|   | `# 'username': 'pynetauto',` |
|   | `# 'password': 'cisco123',` |
|   | `# 'secret': 'cisco123',` |
|   | `# 'global_delay_factor': 2` |
|   | `# }` |
|   | 在开发 Python 工具时，您必须多次测试脚本，以确保自动化任务可重复执行，并获得相同的预期结果。 |

## 停止或重新加载路由器的选项

这里，您将编写一个脚本，为用户提供两个选项:一个选项是更改引导系统的备份运行配置并重新加载，另一个选项是退出应用程序以便稍后重新加载。对于第一个选项，您必须编写代码来更改引导系统，保存更改，然后有选择地备份`running-config`以供以后更改验证。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 更改目录，为这个部分创建一个新的目录，并创建一个新的基础脚本。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool8_md5_cisco$``cd`T2】 |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `mkdir tool9_yes_no` |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `cd tool9_yes_no` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool9_yes_no$` `nano yesno.py` |
| **2** | 这次您将编写一个快速的是/否函数，因此期望的输入是`yes` / `y`或`no` / `n`。如果用户输入的是别的东西，那么`yes_or_no`功能将再次运行，直到输入正确的输入。这样，您可以控制输入，并且基于输入，脚本流将会改变。如果答案是肯定的，我们可以更改路由器的配置并重新加载。如果响应为否，请退出应用程序，稍后重新加载路由器。 |
|   | `yesno.py` |
|   | `yes = ['yes', 'y']` |
|   | `no = ['no', 'n']` |
|   | `def yes_or_no():` |
|   | `resp = input("Would you like to reload your devices? (y/n)? ").lower()` |
|   | `if resp in yes:` |
|   | `print("YES")` |
|   | `elif resp in no:` |
|   | `print("NO")` |
|   | `else:` |
|   | `yes_or_no()` |
|   | `yes_or_no()` |
|   | `print("All tasks completed.")` |
|   | 完成前面的脚本后，运行该脚本并进行测试，如下所示: |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool9_yes_no$` `python3 yesno.py` |
|   | `Would you like to reload your devices? (y/n)?` `y` |
|   | `YES` |
|   | `All tasks completed.` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool9_yes_no$` `python3 yesno.py` |
|   | `Would you like to reload your devices? (y/n)?` `yes` |
|   | `YES` |
|   | `All tasks completed.` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool9_yes_no$` `python3 yesno.py` |
|   | `Would you like to reload your devices? (y/n)?` `N` |
|   | `NO` |
|   | `All tasks completed.` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool9_yes_no$` `python3 yesno.py` |
|   | `Would you like to reload your devices? (y/n)?` `NO` |
|   | `NO` |
|   | `All tasks completed.` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool9_yes_no$` `python3 yesno.py` |
|   | `Would you like to reload your devices? (y/n)?` `sure` |
|   | `Would you like to reload your devices? (y/n)?` `Why not?` |
|   | `Would you like to reload your devices? (y/n)?` `12345` |
|   | `Would you like to reload your devices? (y/n)?` `OK` |
|   | `Would you like to reload your devices? (y/n)?` `YES` |
|   | `YES` |
|   | `All tasks completed.` |
| **3** | 现在是时候使用这个基本脚本并将其扩展到我们的场景中了。制作副本，修改脚本，如`reload_yesno1.py`所示。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool9_yes_no$` `cp yesno.py reload_yesno1.py` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool9_yes_no$` `nano reload_yesno1.py` |
|   | 以下脚本将更改设备上的引导系统语句，保存配置，并执行一些`show`命令来捕获预加载操作状态。最后，它将重新加载路由器。 |
|   | `reload_yesno1.py` |
|   | `from netmiko import ConnectHandler` |
|   | `import time` |
|   | `d_newios = "csr1000v-universalk9.16.09.06.SPA.bin"` |
|   | `newiosmd5 = "77878ae6db8e34de90e2e3e83741bf39"` |
|   | `device1 = {` |
|   | `'device_type': 'cisco_xe',` |
|   | `'host': '192.168.183.111',` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123',` |
|   | `'global_delay_factor': 2 # Used to slow down the script` |
|   | `}` |
|   | `device2 = {` |
|   | `'device_type': 'cisco_xe',` |
|   | `'host': '192.168.183.222',` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123',` |
|   | `'global_delay_factor': 2` |
|   | `}` |
|   | `devices_list = [device1, device2]` |
|   | `yes_list = ['yes', 'y']` |
|   | `no_list = ['no', 'n']` |
|   | `def yes_or_no():` |
|   | `resp = input("Would you like to reload your devices? (y/n)? ").lower()` |
|   | `if resp in yes_list:` |
|   | `print("Reloading devices")` |
|   | `for device in devices_list:` |
|   | `ip = str(device['host'])` |
|   | `net_connect = ConnectHandler(**device)` |
|   | `net_connect.enable(cmd='enable 15')` |
|   | `config_commands1 = ['no boot system', 'boot system flash:/' + d_newios, 'do write memory']` |
|   | `output = net_connect.send_config_set(config_commands1)` |
|   | `print (output)` |
|   | `net_connect.send_command('terminal length 0\n')` |
|   | `show_boot = net_connect.send_command('show boot\n')` |
|   | `show_dir = net_connect.send_command('dir\n')` |
|   | `if d_newios not in show_dir:` |
|   | `print('Unable to locate new IOS on the flash:/. Exiting.')` |
|   | `print("-"*80)` |
|   | `exit()` |
|   | `elif d_newios not in show_boot:` |
|   | `print('Boot system was not correctly configured. Exiting.')` |
|   | `print("-"*80)` |
|   | `exit()` |
|   | `elif d_newios in show_boot and d_newios in show_dir:` |
|   | `print(f'Found {d_newios} in show boot')` |
|   | `print("-"*80)` |
|   | `net_connect.send_command("terminal length 0")` |
|   | `time.sleep(1)` |
|   | `with open(f'{ip}_showver_pre.txt', 'w+') as f1:` |
|   | `print("Capturing pre-reload 'show version'")` |
|   | `showver_pre = net_connect.send_command("show version")` |
|   | `f1.write(showver_pre)` |
|   | `time.sleep(1)` |
|   | `with open(f'{ip}_showrun_pre.txt', 'w+') as f2:` |
|   | `print("Capturing pre-reload 'show running-config'")` |
|   | `showrun_pre = net_connect.send_command("show running-config")` |
|   | `f2.write(showrun_pre)` |
|   | `time.sleep(1)` |
|   | `with open(f'{ip}_showint_pre.txt', 'w+') as f3:` |
|   | `print("Capturing pre-reload 'show ip interface brief'")` |
|   | `showint_pre = net_connect.send_command("show ip interface brief")` |
|   | `f3.write(showint_pre)` |
|   | `time.sleep(1)` |
|   | `with open(f'{ip}_showroute_pre.txt', 'w+') as f4:` |
|   | `print("Capturing pre-reload 'show ip route'")` |
|   | `showroute_pre = net_connect.send_command("show ip route")` |
|   | `f4.write(showroute_pre)` |
|   | `time.sleep(1)` |
|   | `print("-"*80)` |
|   | `# Trigger the device reload` |
|   | `print("Your device is now reloading.")` |
|   | `net_connect.send_command('reload', expect_string="[confirm]")` |
|   | `net_connect.send_command('yes\n')` |
|   | `net_connect.send_command('\n')` |
|   | `net_connect.disconnect()` |
|   | `print("-"*80)` |
|   | `elif resp in no_list:` |
|   | `print("You have chosen to reload the devices later. Exiting the application.")` |
|   | `else:` |
|   | `yes_or_no()` |
|   | `yes_or_no()` |
|   | `print("All tasks completed.")` |
| **4** | 当您运行前一个脚本时，它将在脚本中间挂起，超时，并继续运行，直到脚本结束。但是脚本不会启动路由器重新加载。 |
|   | 当您尝试手动重新加载路由器时，它会抱怨最终用户许可协议，并揭示实际问题。我们忘记接受最终用户许可协议，并且没有设置路由器平台的正确功能集。 |
|   | `csr1000v-1#` `reload` |
|   | `% Unfortunately EULA is not detected for following feature/features:` |
|   | `% ax` |
|   | `% Please configure 'license accept end user agreement' and` |
|   | `% use 'write' command to ensure license configurations take effect` |
|   | `% Continue reload will cause functionality loss for above feature/features.` |
|   | `Continue to reload? (yes/[no]):` |
|   | 我们将按照说明添加 ax(企业)许可证级别，然后接受 EULA 并保存配置。在 csr1000v-1 上接受许可后，在 csr1000v-2 上重复该过程。 |
|   | `csr1000v-1#` `configure terminal` |
|   | `csr1000v-1(config)#` `license boot level ax` |
|   | `% use 'write' command to make license boot config take effect on next boot` |
|   | `csr1000v-1(config)#` `license accept end user agreement` |
|   | `[omitted for brevity]` |
|   | `Activation  of the  software command line interface will be evidence of` |
|   | `your acceptance of this agreement.` |
|   | `ACCEPT? (yes/[no]): yes` |
|   | `csr1000v-1(config)#` `exit` |
|   | `csr1000v-1#` `write memory` |
|   | `Building configuration...` |
|   | `[OK]` |
|   | 当您发出一个`reload`命令时，我们希望看到来自路由器的`[confirm]`。 |
|   | `csr1000v-1#` `reload` |
|   | `Proceed with reload? [confirm]` |
|   | 您还必须接受第二台路由器`csr1000v-2`上的最终用户许可协议。重复前面显示的过程。 |
| **5** | After accepting the end-user license agreement (EULA) and saving the configuration, this is the right time to take a snapshot of your routers. You will be running your script against these devices multiple times and do not want to reverse the change every time you want to test this feature. So, on VMware Workstation, go to the Snapshot Manager feature and take another snapshot of both routers. See Figure [18-5](#Fig5).![../images/492721_1_En_18_Chapter/492721_1_En_18_Fig5_HTML.jpg](../images/492721_1_En_18_Chapter/492721_1_En_18_Fig5_HTML.jpg)图 18-5。快照管理器，拍摄 csr1000v-1 的快照 |
|   | 也给`csr1000v-2`路由器拍一张快照。VMware Workstation Pro 允许您拍摄 Cisco 路由器的快照，如果您想重新运行相同的测试，您可以随时返回到该快照。请特别注意，在生产环境中，由于时间戳和数据库相关问题，Cisco 通常不允许管理员拍摄 Cisco 虚拟机的快照。 |
| **6** | 现在再次运行脚本，这次第一个路由器重新加载 OK，但是返回“OSError: Socket is closed”错误并断开我们的`netmiko ConnectHandler`连接。如果我们只进行单个设备升级，并希望完成任务，这是很好的。我们希望脚本继续在第二台路由器上运行这组命令。只有当我们能够在多种设备上应用该解决方案并获得一致的结果时，才能实现网络自动化的真正威力。 |
|   | 看起来我们必须为这个错误做一个例外，以便它运行并重新加载第二台路由器。这可以通过使用`try ~ except`方法来实现。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool9_yes_no$` `python3 reload_yesno1.py` |
|   | `Would you like to reload your devices? (y/n)? y` |
|   | `Reloading devices` |
|   | `configure terminal` |
|   | `Enter configuration commands, one per line.  End with CNTL/Z.` |
|   | `csr1000v-1(config)#no boot system` |
|   | `csr1000v-1(config)#boot system flash:/csr1000v-universalk9.16.09.06.SPA.bin` |
|   | `csr1000v-1(config)#do write memory` |
|   | `Building configuration...` |
|   | `[OK]` |
|   | `csr1000v-1(config)#end` |
|   | `csr1000v-1#` |
|   | `Found csr1000v-universalk9.16.09.06.SPA.bin in show boot` |
|   | `--------------------------------------------------------------------------------` |
|   | `Capturing pre-reload 'show version'` |
|   | `Capturing pre-reload 'show running-config'` |
|   | `Capturing pre-reload 'show ip interface brief'` |
|   | `Capturing pre-reload 'show ip route'` |
|   | `--------------------------------------------------------------------------------` |
|   | `Your device is now reloading.` |
|   | `Traceback (most recent call last):` |
|   | `File "reload_yesno1.py", line 88, in <module>` |
|   | `yes_or_no()` |
|   | `File "reload_yesno1.py", line 79, in yes_or_no` |
|   | `[...omitted for brevity]` |
|   | `File "/usr/lib/python3/dist-packages/paramiko/channel.py", line 1198, in _send` |
|   | `raise socket.error("Socket is closed")` |
|   | `OSError: Socket is closed` |
| **7** | 让我们复制并重构我们的脚本，使其包含`try ~ except`语句来捕捉`OSError`，这样脚本就可以继续运行。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool9_yes_no$` `cp reload_yesno1.py reload_yesno2.py` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool9_yes_no$` `nano reload_yesno2.py` |
|   | `reload_yesno2.py` |
|   | `from netmiko import ConnectHandler` |
|   | `import time` |
|   | `d_newios = "csr1000v-universalk9.16.09.06.SPA.bin"` |
|   | `newiosmd5 = "77878ae6db8e34de90e2e3e83741bf39"` |
|   | `device1 = {` |
|   | `'device_type': 'cisco_xe',` |
|   | `'host': '192.168.183.111',` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123',` |
|   | `'global_delay_factor': 2` |
|   | `}` |
|   | `device2 = {` |
|   | `'device_type': 'cisco_xe',` |
|   | `'host': '192.168.183.222',` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123',` |
|   | `'global_delay_factor': 2` |
|   | `}` |
|   | `devices_list = [device1, device2]` |
|   | `yes_list = ['yes', 'y']` |
|   | `no_list = ['no', 'n']` |
|   | `def yes_or_no():` |
|   | `resp = input("Would you like to reload your devices? (y/n)? ").lower()` |
|   | `if resp in yes_list:` |
|   | `print("Reloading devices")` |
|   | `for device in devices_list:` |
|   | `ip = str(device['host'])` |
|   | `net_connect = ConnectHandler(**device)` |
|   | `net_connect.enable(cmd='enable 15')` |
|   | `config_commands1 = ['no boot system', 'boot system flash:/' + d_newios, 'do write memory']` |
|   | `output = net_connect.send_config_set(config_commands1)` |
|   | `print (output)` |
|   | `net_connect.send_command('terminal length 0\n')` |
|   | `show_boot = net_connect.send_command('show boot\n')` |
|   | `show_dir = net_connect.send_command('dir\n')` |
|   | `if d_newios not in show_dir:` |
|   | `print('Unable to locate new IOS on the flash:/. Exiting.')` |
|   | `print("-"*80)` |
|   | `exit()` |
|   | `elif d_newios not in show_boot:` |
|   | `print('Boot system was not correctly configured. Exiting.')` |
|   | `print("-"*80)` |
|   | `exit()` |
|   | `elif d_newios in show_boot and d_newios in show_dir:` |
|   | `try:` |
|   | `print(f'Found {d_newios} in show boot')` |
|   | `print("-"*80)` |
|   | `net_connect.send_command("terminal length 0")` |
|   | `time.sleep(1)` |
|   | `with open(f'{ip}_showver_pre.txt', 'w+') as f1:` |
|   | `print("Capturing pre-reload 'show version'")` |
|   | `showver_pre = net_connect.send_command("show version")` |
|   | `f1.write(showver_pre)` |
|   | `time.sleep(1)` |
|   | `with open(f'{ip}_showrun_pre.txt', 'w+') as f2:` |
|   | `print("Capturing pre-reload 'show running-config'")` |
|   | `showrun_pre = net_connect.send_command("show running-config")` |
|   | `f2.write(showrun_pre)` |
|   | `time.sleep(1)` |
|   | `with open(f'{ip}_showint_pre.txt', 'w+') as f3:` |
|   | `print("Capturing pre-reload 'show ip interface brief'")` |
|   | `showint_pre = net_connect.send_command("show ip interface brief")` |
|   | 6 `f3.write(showint_pre)` |
|   | `time.sleep(1)` |
|   | `with open(f'{ip}_showroute_pre.txt', 'w+') as f4:` |
|   | `print("Capturing pre-reload 'show ip route'")` |
|   | `showroute_pre = net_connect.send_command("show ip route")` |
|   | `f4.write(showroute_pre)` |
|   | `time.sleep(1)` |
|   | `print("-"*80)` |
|   | `# Trigger the device reload` |
|   | `print("Your device is now reloading.")` |
|   | `net_connect.send_command('reload', expect_string="[confirm]")` |
|   | `net_connect.send_command('yes')` |
|   | `net_connect.send_command('\n')` |
|   | `net_connect.disconnect()` |
|   | `print("-"*80)` |
|   | `except OSError:` |
|   | `print("Device is now reloading. This may take 2-5 minutes.")` |
|   | `time.sleep(10)` |
|   | `print("-"*80)` |
|   | `elif resp in no_list:` |
|   | `print("You have chosen to reload the devices later. Exiting the application.")` |
|   | `else:` |
|   | `yes_or_no()` |
|   | `yes_or_no()` |
|   | `print("All tasks completed.")` |
|   | 现在，重新运行脚本，您将看到脚本成功地到达了最后一行代码。此外，`csr1000v-1`和`csr1000v-2`都应该被重新加载并提交到新的 IOS XE 镜像中，`csr1000v-universalk9.16.09.06.SPA.bin`。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool9_yes_no$` `python3 reload_yesno2.py` |
|   | `Would you like to reload your devices? (y/n)? yes` |
|   | `Reloading devices` |
|   | `configure terminal` |
|   | `Enter configuration commands, one per line.  End with CNTL/Z.` |
|   | `csr1000v-1(config)#no boot system` |
|   | `csr1000v-1(config)#boot system flash:/csr1000v-universalk9.16.09.06.SPA.bin` |
|   | `csr1000v-1(config)#do write memory` |
|   | `Building configuration...` |
|   | `[OK]` |
|   | `[...omitted for brevity]` |
|   | `Your device is now reloading.` |
|   | `Device is now reloading. This may take 2-5 minutes.` |
|   | `--------------------------------------------------------------------------------` |
|   | `All tasks completed.` |
| **8** | While the script runs, keep an eye on the first router’s console, and you will see that the system is booting into the `.bin` file of the new IOS XE image. See Figure [18-6](#Fig6).![../images/492721_1_En_18_Chapter/492721_1_En_18_Fig6_HTML.jpg](../images/492721_1_En_18_Chapter/492721_1_En_18_Fig6_HTML.jpg)图 18-6。csr1000v-1，引导至新的 IOS XE 映像 |
|   | 路由器经过 POST 过程后，通过运行`show version`命令检查 IOS 版本，现在路由器运行在新的 IOS 映像上。脚本继续在第二台路由器上运行，在`csr1000v-2`路由器上将观察到相同的结果。 |
|   | `csr1000v-1#show version` |
|   | `Cisco IOS XE Software, Version 16.09.06` |
|   | `Cisco IOS Software [Fuji], Virtual XE Software (X86_64_LINUX_IOSD-UNIVERSALK9-M), Version 16.9.6, RELEASE SOFTWARE (fc2)` |
|   | `Technical Support: http://www.cisco.com/techsupport` |
|   | `Copyright (c) 1986-2020 by Cisco Systems, Inc.` |
|   | `Compiled Thu 27-Aug-20 02:35 by mcpre` |
|   | `Cisco IOS-XE software, Copyright (c) 2005-2020 by cisco Systems, Inc.` |
|   | `All rights reserved.  Certain components of Cisco IOS-XE software are` |
|   | `licensed under the GNU General Public License` `("GPL") Version 2.0.  The` |
|   | `software code licensed under GPL Version 2.0 is free software that comes` |
|   | `with ABSOLUTELY NO WARRANTY.  You can redistribute and/or modify such` |
|   | `GPL code under the terms of GPL Version 2.0.  For more details, see the` |
|   | `documentation or "License Notice" file accompanying the IOS-XE software,` |
|   | `or the applicable URL provided on the flyer accompanying the IOS-XE` |
|   | `software.` |
|   | `ROM: IOS-XE ROMMON` |
|   | `csr1000v-1 uptime is 1 minute` |
|   | `Uptime for this control processor is 2 minutes` |
|   | `System returned to ROM by reload` |
|   | `System image file is "bootflash:/csr1000v-universalk9.16.09.06.SPA.bin"` |
|   | `Last reload reason: Reload Command` |
| **9** | 在前一个应用程序成功运行时，您还将获得每个路由器的四个`show`命令的副本。这些文件将在 IOS 升级后与同一组`show`命令结果进行比较。这充分验证了 IOS 升级成功运行，并且没有对通过这些设备服务的网络造成任何中断。这只是一个开发实验室，但是如果您在生产环境中运行该脚本，该文件可能包含数百行。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool9_yes_no$ ls -lh` |
|   | `total 44K` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto  323 Jan 15 16:57 192.168.183.111_showint_pre.txt` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto  842 Jan 15 16:57 192.168.183.111_showroute_pre.txt` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto 4.0K Jan 15 16:57 192.168.183.111_showrun_pre.txt` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto 2.3K Jan 15 16:57 192.168.183.111_showver_pre.txt` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto  323 Jan 15 16:57 192.168.183.222_showint_pre.txt` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto  842 Jan 15 16:57 192.168.183.222_showroute_pre.txt` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto 1.8K Jan 15 16:57 192.168.183.222_showrun_pre.txt` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto 2.3K Jan 15 16:57 192.168.183.222_showver_pre.txt` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto 3.6K Jan 15 16:31 reload_yesno1.py` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto 3.9K Jan 15 16:56 reload_yesno2.py` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto  285 Jan 15 16:30 yesno.py` |

现在，我们已经重新加载了两台路由器，它们正在运行最新的 IOS XE 映像，我们必须通过重新登录设备并使用捕获的信息执行升级后检查来锦上添花。继续下一节。

## 检查重新加载设备，并执行重新加载后配置验证

您已经到达了我们将开发的最终工具。您将学习如何创建一个工具，在我们的脚本启动路由器重新加载后，扫描并检查端口 22 是否处于打开状态。当脚本检测到打开的端口 22 时，应用程序将 SSH 到设备中，然后执行运行配置的重新加载后捕获。预加载捕获可以比作使用 Python 的`difflib`库。让我们按照一步一步的过程来开发最终的工具。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 为了简单起见，您可以复制前面的脚本并对其进行修改，以创建本章的最后一个迷你脚本。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool9_yes_no$``cd`T2】 |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `mkdir tool10_post_check` |
|   | `pynetauto@ubuntu20s1:~/my_tools$` `cd tool10_post_check` |
|   | `pynetauto@ubuntu20s1:~/my_tools/ tool10_post_check $` `touch post_check1.py` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool10_post_check$` `nano post_check1.py` |
| **2** | 这里，我们将创建一个检查端口 22 的套接字应用程序。当它检测到端口 22 打开时，它将登录到该设备并运行`show clock`命令。否则，它将休眠 10 秒钟，并重新检查端口 22。该检查将重复 60 次，这意味着检查将运行 10 分钟，这是我们让路由器重新启动并启动到新的 IOS XE 映像的时间。在生产中，这个值必须根据网络速度和实际的硬件 CPU 处理器速度而有所不同，并且您必须估计出等待时间。本实验假设，如果设备的端口 22 在执行`reload`命令后没有恢复服务，则可能需要进行故障排除。 |
|   | `post_check1.py` |
|   | `import socket` |
|   | `import time` |
|   | `from netmiko import ConnectHandler` |
|   | `t1 = time.mktime(time.localtime()) # Timer start to measure script running time` |
|   | `device1 = {` |
|   | `'device_type': 'cisco_xe',` |
|   | `'host': '192.168.183.111',` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123',` |
|   | `'global_delay_factor': 2` |
|   | `}` |
|   | `device2 = {` |
|   | `'device_type': 'cisco_xe',` |
|   | `'host': '192.168.183.222',` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123',` |
|   | `'global_delay_factor': 2` |
|   | `}` |
|   | `devices_list = [device1, device2]` |
|   | `for device in devices_list:` |
|   | `ip = str(device['host'])` |
|   | `port = 22` |
|   | `retry = 60` |
|   | `delay = 10` |
|   | `def isOpen(ip, port):` |
|   | `s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)` |
|   | `s.settimeout(3)` |
|   | `try:` |
|   | `s.connect((ip, int(port)))` |
|   | `s.shutdown(socket.SHUT_RDWR)` |
|   | `return True` |
|   | `except:` |
|   | `return False` |
|   | `finally:` |
|   | `s.close()` |
|   | `t1 = time.mktime(time.localtime())` |
|   | `ipup = False` |
|   | `for i in range(retry):` |
|   | `if isOpen(ip, port):` |
|   | `ipup = True` |
|   | `print(f"{ip} is online. Logging into device to perform post reload check")` |
|   | `net_connect = ConnectHandler(**device)` |
|   | `print(net_connect.send_command("show clock"))` |
|   | `break` |
|   | `else:` |
|   | `print("Device is still reloading. Please wait...")` |
|   | `time.sleep(delay)` |
|   | `t2 = time.mktime(time.localtime()) - t1` |
|   | `print("Total wait time : {0} seconds".format(t2))` |
|   | 当您运行前面的脚本时，它将检查端口 22，如果端口 22 在目标设备上打开，它应该 SSH 到路由器并运行`show clock`命令。然后它将跳出`for`循环，移动到下一个设备，所以您的结果应该类似于这个输出。现在您知道端口 22 后检查器工作正常，我们准备编写完整的后检查应用程序。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool10_post_check$` `python3 post_check1.py` |
|   | `192.168.183.111 is online. Logging into device to perform post reload check` |
|   | `*16:13:37.425 UTC Fri Jan 15 2021` |
|   | `192.168.183.222 is online. Logging into device to perform post reload check` |
|   | `*16:13:42.200 UTC Fri Jan 15 2021` |
|   | `Total wait time : 4.0 seconds` |
| **3** | 现在，从 VMware Workstation 用户界面，转到`csr1000v-1`的控制台，启用访问列表以阻止端口 22 来测试应用程序。启用`access-list 100`来阻塞`csr1000v-1`上端口 22 的流量。见图 [18-7](#Fig7) 。 |
|   | `Username: pynetauto` |
|   | `Password: ********` |
|   | `csr1000v-1> enable` |
|   | `csr1000v-1#``conf termina`T2】 |
|   | `csr1000v-1(config)#` `access-list 100 deny tcp any any eq 22` |
|   | `csr1000v-1(config)#` `access-list 100 permit ip any any` |
|   | `csr1000v-1(config)#` `interface Gi1` |
|   | `csr1000v-1(config-if)#` `ip access-group 100 in` |
|   | `csr1000v-1(config-if)#`![../images/492721_1_En_18_Chapter/492721_1_En_18_Fig7_HTML.jpg](../images/492721_1_En_18_Chapter/492721_1_En_18_Fig7_HTML.jpg)图 18-7。VMware 控制台，csr1000v-1，使访问列表 100 能够阻止端口 22 上的流量 |
| **4** | 使用以下 Python 命令运行基本后检查脚本。由于我们阻塞了端口 22 来模拟一个不可到达的设备，它将返回“设备仍在重新加载”。请稍候…”消息每隔 10 秒出现一次。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool10_post_check$` `python3 post_check1.py` |
|   | `Device is still reloading. Please wait...` |
|   | `Device is still reloading. Please wait...` |
|   | 在 VMware Workstation 的主控制台上，登录`csr1000v-1`并从 GigabitEthernet1 接口中删除访问组 100；这将允许脚本检测端口 22 何时对 SSH 开放。 |
|   | `csr1000v-1(config-if)#` `no ip access-group 100 in` |
|   | 一旦访问列表从接口 GigabitEthernet1 中删除，您的脚本将检测到一个开放的端口 22，登录到路由器，并运行`show clock`命令。然后继续到第二台路由器，完成环路。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool10_post_check$` `python3 post_check1.py` |
|   | `Device is still reloading. Please wait...` |
|   | `Device is still reloading. Please wait...` |
|   | `Device is still reloading. Please wait...` |
|   | `Device is still reloading. Please wait...` |
|   | `192.168.183.111 is online. Logging into device to perform post reload check` |
|   | `*16:19:26.299 UTC Fri Jan 15 2021` |
|   | `192.168.183.222 is online. Logging into device to perform post reload check` |
|   | `*16:19:29.063 UTC Fri Jan 15 2021` |
|   | `Total wait time : 2.0 seconds` |
| **5** | 为了测试以前的应用程序，您将需要从以前的开发中创建的文件。让我们从`tool9`开发中复制所有预加载的`show`文件。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool10_post_check$` `pwd` |
|   | `/home/pynetauto/my_tools/tool10_post_check` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool10_post_check$` `ls` |
|   | `post_check1.py` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool10_post_check$` `ls /home/pynetauto/my_tools/tool9_yes_no/` |
|   | `reload_yesno1.py  192.168.183.111_showroute_pre.txt  192.168.183.222_showroute_pre.txt` |
|   | `reload_yesno2.py  192.168.183.111_showrun_pre.txt    192.168.183.222_showrun_pre.txt` |
|   | `yesno.py          192.168.183.111_showver_pre.txt    192.168.183.222_showver_pre.txt` |
|   | `192.168.183.111_showint_pre.txt  192.168.183.222_showint_pre.txt` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool10_post_check$` `cp /home/pynetauto/my_tools/tool9_yes_no/192.* ./` |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool10_post_check$` `ls` |
|   | `192.168.183.111_showint_pre.txt    192.168.183.111_showver_pre.txt    192.168.183.222_showrun_pre.txt` |
|   | `192.168.183.111_showroute_pre.txt  192.168.183.222_showint_pre.txt    192.168.183.222_showver_pre.txt` |
|   | `192.168.183.111_showrun_pre.txt    192.168.183.222_showroute_pre.txt  post_check1.py` |
| **6** | 复制第一个文件，并将其命名为`post_check2.py`。以此作为我们最终剧本的基础。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool10_post_check$` `cp post_check1.py post_check2.py` |
|   | 编写以下代码并完成应用程序。该应用程序将检查端口 22，然后登录到每个路由器，并从每个路由器捕获四个`show`命令。然后，使用 Python 的`difflib`库，我们逐行比较捕获前后的配置。接下来，我们将每个比较集保存为 HTML 格式，以便于查看。仔细阅读和研究每一行代码；下面的代码中嵌入了解释，供您参考: |
|   | `post_check2.py` |
|   | `from netmiko import ConnectHandler` |
|   | `import socket` |
|   | `import time` |
|   | `import difflib` |
|   | `d_newios = "csr1000v-universalk9.16.09.06.SPA.bin"` |
|   | `device1 = {` |
|   | `'device_type': 'cisco_xe',` |
|   | `'host': '192.168.183.111',` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123',` |
|   | `'global_delay_factor': 2` |
|   | `}` |
|   | `device2 = {` |
|   | `'device_type': 'cisco_xe',` |
|   | `'host': '192.168.183.222',` |
|   | `'username': 'pynetauto',` |
|   | `'password': 'cisco123',` |
|   | `'secret': 'cisco123',` |
|   | `'global_delay_factor': 2` |
|   | `}` |
|   | `devices_list = [device1, device2]` |
|   | `# Checks SSH port and then logs back in to complete the post-upgrade check.` |
|   | `def post_check():` |
|   | `for device in devices_list:` |
|   | `ip = str(device['host'])` |
|   | `port = 22` |
|   | `retry = 120` |
|   | `delay = 10` |
|   | `def isOpen(ip, port):` |
|   | `s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)` |
|   | `s.settimeout(3)` |
|   | `try:` |
|   | `s.connect((ip, int(port)))` |
|   | `s.shutdown(socket.SHUT_RDWR)` |
|   | `return True` |
|   | `except:` |
|   | `return False` |
|   | `finally:` |
|   | `s.close()` |
|   | `t1 = time.mktime(time.localtime())` |
|   | `ipup = False` |
|   | `for i in range(retry):` |
|   | `if isOpen(ip, port):` |
|   | `ipup = True` |
|   | `print(f"{ip} is online. Logging into device to perform post reload check")` |
|   | `# Capture four show commands result from each router` |
|   | `print("Performing post upgrade check.")` |
|   | `net_connect = ConnectHandler(**device)` |
|   | `net_connect.enable(cmd='enable 15')` |
|   | `config_commands1 = ['no boot system', 'boot system flash:/' + d_newios, 'do write memory']` |
|   | `output = net_connect.send_config_set(config_commands1)` |
|   | `print (output)` |
|   | `net_connect.send_command('terminal length 0\n')` |
|   | `with open(f'{ip}_showver_post.txt', 'w+') as f1:` |
|   | `print("Capturing post-reload 'show version'")` |
|   | `showver_post = net_connect.send_command("show version")` |
|   | `f1.write(showver_post)` |
|   | `time.sleep(1)` |
|   | `with open(f'{ip}_showrun_post.txt', 'w+') as f2:` |
|   | `print("Capturing post-reload 'show running-config'")` |
|   | `showrun_post = net_connect.send_command("show running-config")` |
|   | `f2.write(showrun_post)` |
|   | `time.sleep(1)` |
|   | `with open(f'{ip}_showint_post.txt', 'w+') as f3:` |
|   | `print("Capturing post-reload 'show ip interface brief'")` |
|   | `showint_post = net_connect.send_command("show ip interface brief")` |
|   | `f3.write(showint_post)` |
|   | `time.sleep(1)` |
|   | `with open(f'{ip}_showroute_post.txt', 'w+') as f4:` |
|   | `print("Capturing post-reload 'show ip route'")` |
|   | `showroute_post = net_connect.send_command("show ip route")` |
|   | `f4.write(showroute_post)` |
|   | `time.sleep(1)` |
|   | `# Compare pre vs post configurations` |
|   | `showver_pre = "showver_pre"` |
|   | `showver_post = "showver_post"` |
|   | `showver_pre_lines = open(f"{ip}_showver_pre.txt").readlines() #converts into strings first for comparison` |
|   | `#time.sleep(1)` |
|   | `showver_post_lines = open(f"{ip}_showver_post.txt").readlines() #converts into strings first for comparison` |
|   | `#time.sleep(1)` |
|   | `# Four arguments required in HtmlDiff function` |
|   | `difference = difflib.HtmlDiff(wrapcolumn=70).make_file(showver_pre_lines, showver_post_lines, showver_pre, showver_post)` |
|   | `difference_report = open(f"{ip}_show_ver_compared.html", "w+")` |
|   | `difference_report.write(difference) # Writes the differences to html file` |
|   | `difference_report.close()` |
|   | `time.sleep(1)` |
|   | `print("-"*80)` |
|   | `showrun_pre = "showrun_pre"` |
|   | `showrun_post = "showrun_post"` |
|   | `showrun_pre_lines = open(f"{ip}_showrun_pre.txt").readlines()` |
|   | `showrun_post_lines = open(f"{ip}_showrun_post.txt").readlines()` |
|   | `difference = difflib.HtmlDiff(wrapcolumn=70).make_file(showrun_pre_lines, showrun_post_lines, showrun_pre, showrun_post)` |
|   | `difference_report = open(f"{ip}_show_run_compared.html", "w+")` |
|   | `difference_report.write(difference)` |
|   | `difference_report.close()` |
|   | `time.sleep(1)` |
|   | `showint_pre = "showint_pre"` |
|   | `showint_post = "showint_post"` |
|   | `showint_pre_lines = open(f"{ip}_showint_pre.txt").readlines()` |
|   | `showint_post_lines = open(f"{ip}_showint_post.txt").readlines()` |
|   | `difference = difflib.HtmlDiff(wrapcolumn=70).make_file(showint_pre_lines, showint_post_lines, showint_pre, showint_post)` |
|   | `difference_report = open(f"{ip}_show_int_compared.html", "w+")` |
|   | `difference_report.write(difference)` |
|   | `difference_report.close()` |
|   | `time.sleep(1)` |
|   | `showroute_pre = "showroute_pre"` |
|   | `showroute_post = "showroute_post"` |
|   | `showroute_pre_lines = open(f"{ip}_showroute_pre.txt").readlines()` |
|   | `showroute_post_lines = open(f"{ip}_showroute_post.txt").readlines()` |
|   | `difference = difflib.HtmlDiff(wrapcolumn=70).make_file(showroute_pre_lines, showroute_post_lines, showroute_pre, showroute_post)` |
|   | `difference_report = open(f"{ip}_show_route_compared.html", "w+")` |
|   | `difference_report.write(difference)` |
|   | `difference_report.close()` |
|   | `time.sleep(1)` |
|   | `print("-"*80)` |
|   | `break` |
|   | `else:` |
|   | `print("Device is still reloading. Please wait...")` |
|   | `time.sleep(delay)` |
|   | `t2 = time.mktime(time.localtime()) - t1` |
|   | `print("Total wait time : {0} seconds".format(t2))` |
|   | `print("="*80)` |
|   | `time.sleep(1)` |
|   | `post_check()` |
|   | `print("All tasks completed. Check pre and post configuration comparison html files.")` |
| **5** | 运行脚本；它应该在重新加载后创建备份文件，然后在比较每一行后创建 HTML 文件。该脚本不会触发路由器像前面的脚本一样重新加载。这里我们感兴趣的是创建文件，然后比较文件前后的内容。在最终的脚本中，我们将需要把这个脚本添加到`reload_yesno2.py`中，并把它变成一个完全工作的应用程序。因此，如果 HTML 与您预期的不同，不要惊慌。 |
|   | `pynetauto@ubuntu20s1:~/my_tools/tool10_post_check$` `python3 post_check2.py` |
|   | `192.168.183.111 is online. Logging into device to perform post reload check` |
|   | `Performing post upgrade check.` |
|   | `configure terminal` |
|   | `Enter configuration commands, one per line.  End with CNTL/Z.` |
|   | `csr1000v-1(config)#no boot system` |
|   | `csr1000v-1(config)#boot system flash:/csr1000v-universalk9.16.09.06.SPA.bin` |
|   | `csr1000v-1(config)#do write memory` |
|   | `Building configuration...` |
|   | `[OK]` |
|   | `csr1000v-1(config)#end` |
|   | `csr1000v-1#` |
|   | `Capturing post-reload 'show version'` |
|   | `Capturing post-reload 'show running-config'` |
|   | `Capturing post-reload 'show ip interface brief'` |
|   | `Capturing post-reload 'show ip route'` |
|   | `--------------------------------------------------------------------------------` |
|   | `--------------------------------------------------------------------------------` |
|   | `Total wait time : 19.0 seconds` |
|   | `================================================================================` |
|   | `192.168.183.222 is online. Logging into device to perform post reload check` |
|   | `Performing post upgrade check.` |
|   | `configure terminal` |
|   | `Enter configuration commands, one per line.  End with CNTL/Z.` |
|   | `csr1000v-2(config)#no boot system` |
|   | `csr1000v-2(config)#boot system flash:/csr1000v-universalk9.16.09.06.SPA.bin` |
|   | `csr1000v-2(config)#do write memory` |
|   | `Building configuration...` |
|   | `[OK]` |
|   | `csr1000v-2(config)#end` |
|   | `csr1000v-2#` |
|   | `Capturing post-reload 'show version'` |
|   | `Capturing post-reload 'show running-config'` |
|   | `Capturing post-reload 'show ip interface brief'` |
|   | `Capturing post-reload 'show ip route'` |
|   | `--------------------------------------------------------------------------------` |
|   | `--------------------------------------------------------------------------------` |
|   | `Total wait time : 18.0 seconds` |
|   | `================================================================================` |
|   | `All tasks completed. Check pre and post configuration comparison html files.` |
|   | Connect to the `ubuntu20s1` server using WinSCP or FileZilla and locate the backup and comparison files in the `/home/yourname/my_tools/tool10_post_check/` directory. You can copy the HTML files and open them in a web browser. See Figure [18-8](#Fig8).![../images/492721_1_En_18_Chapter/492721_1_En_18_Fig8_HTML.jpg](../images/492721_1_En_18_Chapter/492721_1_En_18_Fig8_HTML.jpg)图 18-8。WinSCP，检查和复制 HTML 比较文件 |
| **6** | Copy the files from the automation server onto your Windows host PC and open the HTML files in a web browser. If everything worked, you will see the headings with `_pre` and `_post` for each respective `show` command. Since we have not integrated this script with the `reload_yesno2.py` script, it will still display the currently running configurations. We will integrate all ten applications we have developed so far in the next chapter and turn them into an end-to-end working application. See Figure [18-9](#Fig9).![../images/492721_1_En_18_Chapter/492721_1_En_18_Fig9_HTML.jpg](../images/492721_1_En_18_Chapter/492721_1_En_18_Fig9_HTML.jpg)图 18-9。复制和打开 HTML 文件检查示例 |

## 摘要

在本章中，您开发了十种迷你工具，为下一章的最终 Cisco IOS 升级应用做好了准备。本章中开发的每个工具都有其使用案例，也可以作为一个独立的工具，只需稍加修改或不需要修改就可以用于生产。正如您所看到的，我们使用了各种 Python 模块来开发我们自己的 Python 应用程序，以满足我们的需求。这些工具可以组合成一个应用程序；我们可以提出各种工作流，开发不同的 Python 网络应用程序(工具)。编写 Python 程序的一般过程在所有厂商的网络设备上都是一样的。只要 Python 模块支持特定的供应商产品，您就可以对任何供应商产品应用类似的自动化应用程序开发策略。现在，让我们结合所有十个应用程序，创建一个功能齐全的 Cisco IOS XE 升级工具。