# 14.Python 网络自动化实验室:SSH paramiko 和 netmiko

在本章中，您将使用 Python 的 SSH 库`paramiko`和`netmiko`来控制您的网络设备。`paramiko`是 Ansible 对网络设备的 SSH 连接管理所依赖的，而`netmiko`是`paramiko`的工程师友好版本，因为`netmiko`也依赖于`paramiko`。通过研究这些网络模块如何工作，您可以了解依赖这些网络模块的其他应用程序的内部工作方式。在本章的前半部分，您将学习使用 Python 脚本和`paramiko`库来替换基本的网络工程师手工任务。在本章的后半部分，你将学习使用`netmiko`库编写 Python 脚本。一旦您掌握了如何使用这些 SSH 模块，您就可以立即将它们应用到您的工作中。这些 SSH 实验将作为本书末尾开发 IOS XE 升级应用程序的基础。

![../images/492721_1_En_14_Chapter/492721_1_En_14_Figa_HTML.jpg](../images/492721_1_En_14_Chapter/492721_1_En_14_Figa_HTML.jpg)

## 使用 paramiko 和 netmiko 库的 Python 网络自动化实验室

在前一章中，我们使用 Telnet 实验室重点介绍了基本的 Python 网络概念。无论您是使用 Telnet 还是 SSH，都可以应用相同的 Python 网络概念。当然，SSH 是比 Telnet 更安全的远程登录协议，它也使用不同的库来登录网络设备。如您所知，Telnet 是一种纯文本网络协议，与 SSH 相比不安全。在大多数安全网络中，通常禁止使用 Telnet，只允许加密的 SSH 连接。要使用 Python 连接到使用 SSH 的 Cisco 设备，必须首先安装 Python `paramiko`库，并且必须在 Cisco 设备上配置加密的 RSA 密钥。为了开始这一章，让我们首先安装`paramiko`库来开始我们的 SSH 实验。

## Python SSH 实验室:paramiko

在您的 Ubuntu Python automation 服务器上，您可以使用下面显示的`pip`命令安装`paramiko`:

```py
pynetauto@ubuntu20s1:~$ pip3 install paramiko

```

完成`paramiko`安装后，快速运行 Python 解释器会话，并运行`import paramiko`来检查库是否可以正确导入。准备好之后，开始第一个 SSH 实验。

```py
pynetauto@ubuntu20s1:~$ python

Python 3.8.2 (default, Jul 16 2020, 14:00:26)
[GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import paramiko

>>>

```

## paramiko 实验 1:在 Python 解释器中交互配置所有设备的时钟和时区

在本实验中，您将登录到`ubunsu20s1` Python 自动化服务器上的 Python 解释器，并编写一个实时脚本来与所有路由器和交换机交互，以更改它们的时间和时区设置。您必须打开所有三台路由器和两台交换机的电源。如果您的 PC 使用较旧的低性能 CPU 或更少的内存，您只需打开一台路由器和一台交换机的电源；这将使您在本实验中避免高 CPU 利用率和内存争用问题。见图 [14-1](#Fig1) 。

![../images/492721_1_En_14_Chapter/492721_1_En_14_Fig1_HTML.jpg](../images/492721_1_En_14_Chapter/492721_1_En_14_Fig1_HTML.jpg)

图 14-1。

SSH paramiko 实验室 1，正在使用的设备

您将练习一个交互式 SSH 会话，以便从 Python 解释器 shell 管理您的网络设备。在通过 SSH 连接到 Cisco 设备之前，我们必须首先为每台设备生成 RSA 密钥。由于我们在实验室中没有使用 AAA RADIUS 服务器进行身份认证，因此我们将为每台设备创建本地证书。按照以下任务为第一个 SSH 实验做准备:

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 使用以下 Cisco IOS 命令在每台设备上创建 1，024 位本地 RSA 密钥，并仅启用 SSH 连接来管理每台设备。以下示例仅显示了`LAB-R1`路由器上的配置，但相同的配置必须应用于所有其它设备，以便在您的网络上完全禁用 Telnet。`LAB-R1#` `configure terminal` |
|   | `Enter configuration commands, one per line.  End with CNTL/Z.` |
|   | `LAB-R1(config)#` `ip domain-name pynetauto.local` |
|   | `LAB-R1(config)#` `crypto key generate rsa` |
|   | `The name for the keys will be: LAB-R1.pynetauto.local` |
|   | `Choose the size of the key modulus in the range of 360 to 4096 for your` |
|   | `General Purpose Keys. Choosing a key modulus greater than 512 may take` |
|   | `a few minutes` `.` |
|   | `How many bits in the modulus [512]:` `1024` |
|   | `% Generating 1024 bit RSA keys, keys will be non-exportable...` |
|   | `[OK] (elapsed time was 2 seconds)` |
|   | `LAB-R1(config)#` |
|   | `*Aug  9 13:04:41.381: %SSH-5-ENABLED: SSH 1.99 has been enabled` |
|   | `LAB-R1(config)#` `line vty 0 15` |
|   | `LAB-R1(config-line)#` `transport input all` |
|   | `LAB-R1(config-line)#` `end` |
|   | `LAB-R1#` `write memory` |
|   | 现在在`lab-r2`、`LAB-SW1`、`lab-sw2`和`R1`上应用先前的配置。您可以一次复制以下命令，并将其粘贴到每个设备的控制台中: |
|   | `configure terminal` |
|   | `ip domain-name pynetauto.local` |
|   | `crypto key generate rsa` |
|   | `1024` |
|   | `line vty 0 15` |
|   | `transport input all` |
|   | `do write memory` |
| **2** | 您可以使用`ssh –l user_name IP_address`命令 SSH 到任意两台 Cisco 设备之间的另一台设备。从`R1`中，使用以下命令 SSH 到所有其他路由器和交换机: |
|   | `R1#` `ssh -l pynetauto 192.168.183.10` |
|   | `**************************************************************************` |
|   | `* IOSv is strictly limited to use for evaluation, demonstration and IOS  *` |
|   | `* education. IOSv is provided as-is and is not supported by Cisco's      *` |
|   | `* Technical Advisory Center. Any use or disclosure, in whole or in part, *` |
|   | `* of the IOSv Software or Documentation to any third party for any       *` |
|   | `* purposes is expressly prohibited except as otherwise authorized by     *` |
|   | `* Cisco in writing.                                                      *` |
|   | `**************************************************************************` |
|   | `Password:*******` |
|   | `[...omitted for brevity]` |
|   | `LAB-R1#` `exit` |
|   | `[Connection to 192.168.183.10 closed by foreign host]` |
|   | `R1#` |
|   | 尝试 ssh 到其他设备和 vise vesa。 |
|   | `R1#` `ssh -l pynetauto 192.168.183.20` |
|   | `R1#` `ssh -l pynetauto 192.168.183.101` |
|   | `R1#` `ssh -l pynetauto 192.168.183.102` |
| **3** | 如果想从 Linux 服务器测试 SSH 连接，可以使用`ssh user_name IP_address`命令。但是，由于遗留的 SSH 密钥交换问题，您可能必须指定加密密钥类型，以便从 Linux Python 服务器 SSH 到 Cisco 设备。 |
|   | Ubuntu SSH 登录到 R1 实验室(192.168.183.10)示例: |
|   | `pynetauto@ubuntu20s1:~$` `ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 -c 3des-cbc pynetauto@192.168.183.10` |
|   | `The authenticity of host '192.168.183.10 (192.168.183.10)' can't be established.` |
|   | `RSA key fingerprint is SHA256:D9HqPuccjTD+WAGLMOYkyZ3KooHqYqe+5n7Hs2AI67I.` |
|   | `Are you sure you want to continue connecting (yes/no/[fingerprint])?` `yes` |
|   | `Warning: Permanently added '192.168.183.10' (RSA) to the list of known hosts` `.` |
|   | `[...omitted for brevity]` |
|   | `Password: *********` |
|   | `[...omitted for brevity]` |
|   | `LAB-R1#` `exit` |
|   | `Connection to 192.168.183.10 closed.` |
|   | `pynetauto@ubuntu20s1:~$` |
|   | `Ubuntu SSH login to LAB-SW1 (192.168.183.101) example:` |
|   | `pynetauto@ubuntu20s1:~$` `ssh -l pynetauto 192.168.183.101 -c aes256-cbc -oKexAlgorithms=+diffie-hellman-group1-sha1` |
|   | `The authenticity of host '192.168.183.101 (192.168.183.101)' can't be established.` |
|   | `RSA key fingerprint is SHA256:0sbazxGQ82A3KAC26l6msWR3BrklVXnW0sHChkij23g.` |
|   | `Are you sure you want to continue connecting (yes/no/[fingerprint])?` `yes` |
|   | `Warning: Permanently added '192.168.183.101' (RSA) to the list of known hosts.` |
|   | `[...omitted for brevity]` |
|   | `Password: *********` |
|   | `[...omitted for brevity]` |
|   | `LAB-SW1#` `exit` |
|   | `Connection to 192.168.183.101 closed.` |
|   | `pynetauto@ubuntu20s1:~$` |
| **4** | 假设您想更进一步，简化从 Linux 服务器的 SSH 登录。在这种情况下，首先必须检查 Linux 服务器上使用的 SSH 版本，以避免 Linux 服务器和 Cisco 设备之间可能出现的 Diffie-Hellman 密钥交换问题。通过修改`ubuntu20s1`上的`.ssh/config`文件，在您的 Linux 服务器上永久使用`diffie-hellman-group1-sha1`密钥交换方法。 |
|   | 要检查 Python 服务器上的 SSH 版本，请使用以下命令: |
|   | `pynetauto@ubuntu20s1:~$` `ssh -V` |
|   | `OpenSSH_8.2p1 Ubuntu-4, OpenSSL 1.1.1f  31 Mar 2020` |
|   | 要对密钥交换方法进行硬编码，请打开`/home/user_name/.ssh/config`文件，并将以下信息添加到文件中。这将在 SSH 客户端(`ubuntu20s1`)上启用旧的算法，允许它连接到旧类型的 SSH 服务器(在本例中是 Cisco 设备)。 |
|   | `pynetauto@ubuntu20s1:~$` `nano /home/pynetauto/.ssh/config` |
|   | `GNU nano 4.8` `/home/pynetauto/.ssh/config` |
|   | `Host 192.168.183.10` |
|   | `KexAlgorithms +diffie-hellman-group1-sha1` |
|   | `Host 192.168.183.20` |
|   | `KexAlgorithms +diffie-hellman-group1-sha1` |
|   | `Host 192.168.183.101` |
|   | `KexAlgorithms +diffie-hellman-group1-sha1` |
|   | `Host 192.168.183.102` |
|   | `KexAlgorithms +diffie-hellman-group1-sha1` |
|   | `Host 192.168.183.133` |
|   | `KexAlgorithms +diffie-hellman-group1-sha1` |
|   | `^G Get Help  ^O Write Out  ^W Where Is  ^K Cut Text    ^J Justify   ^C Cur Pos` |
|   | `^X Exit      ^R Read File  ^\ Replace   ^U Paste Text  ^T To Spell  ^_ Go To Line` |

![../images/492721_1_En_14_Chapter/492721_1_En_14_Figb_HTML.gif](../images/492721_1_En_14_Chapter/492721_1_En_14_Figb_HTML.gif)

此外，如果您由于这个问题遇到了已知主机问题，您可以按照下面论坛中的说明从您的 Linux 服务器中删除记录，并尝试重新建立到 Cisco 网络设备的 SSH 连接。

[T2`https://superuser.com/questions/30087/remove-key-from-known-hosts`](https://superuser.com/questions/30087/remove-key-from-known-hosts)

此外，如果您在 Cisco 路由器或交换机上遇到 RSA 密钥问题，您可以“归零”RSA 以重新创建 RSA 密钥。您可以使用以下命令清除上一个密钥:

`R1 (config)#` `crypto key zeroize rsa`

`Configure SSH Configuration again`

`R1(config)#` `hostname <name>`

`R1(config)#` `ip domain-name <domain>`

`R1(config)#` `crypto key generate rsa`

`R1(config)#` `ip ssh version 2`

如果 GNS3 中的设备遇到 Diffie-Hellman 密钥交换问题，并且您无法找到解决方案，则保存运行配置，从拓扑中删除节点，然后重新配置您的设备；这可能与 GNS3、VMware 和 Cisco 映像文件不兼容问题有关。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **5** | 现在，让我们在`ubuntu20s1`服务器上打开 Python 解释器，输入以下内容，通过 SSH 实时连接配置正确的时间和时区。请将时区更新为您自己的当地时间。是的，你需要在交互式会话中逐字键入以下内容来练习编写代码。Python 开发工程师每天都要编写成百上千行代码，这可不是在公园里散步。 |
|   | 同样，如果您使用不同的 IP 地址范围，请更新 IP 地址。此外，每个冒号后的四个前导空格要精确，并注意任何特殊方法中的大写。运行 Python 解释器会话的命令时，请确保将时间更改为当前时间和时区。 |
|   | `>>>``import paramiko`T2】 |
|   | `>>>``import time`T2】 |
|   | `>>>` |
|   | `>>>``ip_addresses = ["192.168.183.10", "192.168.183.20", "192.168.183.101", "192.168.183.102", "192.168.183.133"]`T2】 |
|   | `>>>` |
|   | > > >`username = "pynetauto"` `# username variable` |
|   | `>>>``password = "cisco123"`T2】 |
|   | `>>>` |
|   | `>>>``ssh_client = paramiko.SSHClient()`T2】 |
|   | `>>>``ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())`T2】 |
|   | `>>>``for ip in ip_addresses:`T2】 |
|   | `...``ssh_client.connect(hostname=ip, username=username, password=password)`T2】 |
|   | `...``print("Connected to " + ip + "\n")`T2】 |
|   | `...``remote_connection = ssh_client.invoke_shell()`T2】 |
|   | `...` `remote_connection.send("terminal length 0\n")` |
|   | `...``remote_connection.send("configure terminal\n")`T2】 |
|   | `...``remote_connection.send("clock timezone AEST +10\n")`T2】 |
|   | `...``remote_connection.send("clock summer-time AEST recurring\n")`T2】 |
|   | `...``remote_connection.send("exit\n")`T2】 |
|   | `...``time.sleep(1)`T2】 |
|   | `...``remote_connection.send("clock set 15:15:00 12 Jan 2021\n")`T2】 |
|   | `...``remote_connection.send("copy running-config startup-config\n")`T2】 |
|   | `...``remote_connection.send("end\n")`T2】 |
|   | `...``output = remote_connection.recv(6000)`T2】 |
|   | `...``print((output).decode('ascii'))`T2】 |
|   | `...``time.sleep(2)`T2】 |
|   | `...``ssh_client.close()`T2】 |
| **6** | 如果您的交互式会话进展顺利，它会在登录到每台设备并配置每台设备上的时钟和时区时打印出会话。在本实验结束时，您的所有设备都应该配置为符合您当地时区的正确时间。为了检查配置，让我们配置另一个运行`show`命令并显示它的快速脚本。在 Ubuntu Python automation server 上执行这些任务。您不再需要登录每台设备来运行相同的命令五次。只需从您的服务器上运行它们。 |
|   | `pynetauto@ubuntu20s1:~$` `mkdir ssh_labs` |
|   | `pynetauto@ubuntu20s1:~$` `cd ssh_labs` |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `nano display_show.py` |
|   | `GNU nano 4.8` `/home/pynetauto/ssh_labs/ display_show.py` |
|   | `import time` |
|   | `import paramiko` |
|   | `ip_addresses = ["192.168.183.10", "192.168.183.20", "192.168.183.101", "192.168.183.102", "192.168.183.133"]` |
|   | `username = "pynetauto"` |
|   | `password = "cisco123"` |
|   | `for ip in ip_addresses` `:` |
|   | `ssh_client = paramiko.SSHClient()` |
|   | `ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())` |
|   | `ssh_client.connect(hostname=ip, username=username, password=password)` |
|   | `print("Connected to " + ip + "\n")` |
|   | `remote_connection = ssh_client.invoke_shell()` |
|   | `output1 = remote_connection.recv(3000)` `# Catches and removes the login prompt output` |
|   | `# print(output1.decode('ascii'))` `# remove hash to print the login prompt message` |
|   | `# Now send the commands you want to run and display on the screen` |
|   | `remote_connection.send("show clock detail\n")` |
|   | `time.sleep(2)` |
|   | `output2 = remote_connection.recv(6000)` |
|   | `print((output2).decode('ascii'))` |
|   | `print("-"*80)` |
|   | `^G Get Help  ^O Write Out  ^W Where Is   ^K Cut Text    ^J Justify    ^C Cur Pos` |
|   | `^X Exit      ^R Read File  ^\ Replace    ^U Paste Text  ^T To Spell   ^_ Go To Line` |
|   | 之前的 Python 脚本就像是一个针对多个网络设备的`show`命令工具。现在运行脚本来检查所有设备上的时钟和时区更改。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$ python3 display_show.py` |
|   | `Connected to 192.168.183.10` |
|   | `show clock detail` |
|   | `15:15:23.609 AEST Tue Jan 12 2021` |
|   | `Time source is user configuration` |
|   | `Summer time starts 02:00:00 AEST Sun Mar 14 2021` |
|   | `Summer time ends 02:00:00 AEST Sun Nov 7 2021` |
|   | `LAB-R1#` |
|   | `--------------------------------------------------------------------------------` |
|   | `Connected to 192.168.183.20` |
|   | `show clock detail` |
|   | `15:15:23.615 AEST Tue Jan 12 2021` |
|   | `Time source is user configuration` |
|   | `Summer time starts 02:00:00 AEST Sun Mar 14 2021` |
|   | `Summer time ends 02:00:00 AEST Sun Nov 7 2021` |
|   | `lab-r2#` |
|   | `--------------------------------------------------------------------------------` |
|   | `[...omitted for brevity]` |
| **7** | 当您处于交互模式时，您可以在导入一个库后使用`dir(library_name)`显示每个库可用的模块。在前面的例子中，您已经使用了`paramiko`库中的`SSHClient`和`AutoAddPolicy`模块。 |
|   | `>>>` `import paramiko` |
|   | `>>>` `dir(paramiko)` |
|   | `['AUTH_FAILED', 'AUTH_PARTIALLY_SUCCESSFUL', 'AUTH_SUCCESSFUL', 'Agent', 'AgentKey', 'AuthHandler', 'AuthenticationException' , 'AutoAddPolicy', 'BadAuthenticationType',` |
|   | `[...omitted for brevity]` |
|   | `'SFTP_NO_CONNECTION', 'SFTP_NO_SUCH_FILE', 'SFTP_OK', 'SFTP_O P_UNSUPPORTED', 'SFTP_PERMISSION_DENIED', 'SSHClient', 'SSHConfig', 'SSHException', 'SecurityOptions', 'ServerInterface', 'Su bsystemHandler', 'Transport', 'WarningPolicy', '__all__', '__author__', '__builtins__', '__cached__',` |
|   | `[...omitted for brevity]` |
|   | `'sftp_client', 'sftp_file', 'sftp_handle', 'sftp_server', 'sftp_si', 'ssh_exception', 'ssh_gss', 'sys', 'transport',  'util']` |
| **8** | 要在`paramiko`中查看每个模块的包，您可以首先导入每个模块，然后再次使用`dir(module_name)`查看该模块的一些细节。 |
|   | `>>>` `from paramiko import SSHClient` |
|   | `>>>` `dir(SSHClient)` |
|   | `['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__enter__', '__eq__', '__exit__', '__format__', '__ge__', '__ getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__' , '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_aut h', '_families_and_addresses', '_key_from_filepath', '_log', 'close', 'connect', 'exec_command', 'get_host_keys', 'get_transp ort', 'invoke_shell', 'load_host_keys', 'load_system_host_keys', 'open_sftp', 'save_host_keys', 'set_log_channel', 'set_missi ng_host_key_policy']` |
|   | `>>>` `from paramiko import AutoAddPolicy` |
|   | `>>>` `dir(AutoAddPolicy)` |
|   | `['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__' , '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce _ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'missing_host_key']` |

## paramiko 实验 2:在没有用户交互的情况下在 Cisco 设备上配置 NTP 服务器(NTP 实验)

在本实验中，您将配置`LAB-R1`和`lab-r2`，从两个外部文件中读取信息。第一个文件每行包含每个路由器的 IP 地址，另一个文件包含用户名和密码。当您使用外部文件时，网络管理员不必坐在设备的远程控制台前以交互方式键入信息。在下一章，你将学习如何使用 Linux `cron`作为一个调度器来运行你的 Python 应用程序，而不需要你的交互，这样你的应用程序就变成了机器人。与 Cisco ACI 和 Red Hat Ansible Tower 提供的花哨功能相比，使用 Python 脚本作为应用程序和使用 Linux `cron`作为默认调度程序可能看起来相当简陋(对您的公司没有成本)和原始(没有美化的 GUI)。尽管如此，你必须了解`cron`是如何工作的，以及如何定制你的环境，因为每个客户都有不同的网络环境。没有哪两个网络在规模和复杂程度上是相同的。毕竟，计划者就是计划者。见图 [14-2](#Fig2) 。

![../images/492721_1_En_14_Chapter/492721_1_En_14_Fig2_HTML.jpg](../images/492721_1_En_14_Chapter/492721_1_En_14_Fig2_HTML.jpg)

图 14-2。

SSH paramiko 实验 2，使用中的设备

您需要打开 IP 服务服务器`centos8s1`的电源，为路由器提供 NTP 服务。对于本实验，您需要打开`ubuntu20s1`、`centos8s1`、`LAN-R1`和`lab-r2`的电源，并打开`LAB-SW1`和`lab-sw2`的电源，以连接两台路由器。在这个实验室中，您必须完成许多任务，所以让我们编写脚本并在实验室中运行它。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 如果您还没有创建`ssh_labs`目录，在`ubuntu20s1`服务器上，按照以下步骤为 SSH labs 创建一个新目录，然后在同一个目录中创建两个外部文件: |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$``cd`T2】 |
|   | `pynetauto@ubuntu20s1:~$` `mkdir ssh_labs` |
|   | `pynetauto@ubuntu20s1:~$` `cd ssh_labs` |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `nano routerlist` |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `cat routerlist` |
|   | `192.168.183.10` |
|   | `192.168.183.20` |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `nano adminpass` |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `cat adminpass` |
|   | `pynetauto` |
|   | `cisco123` |
| **2** | 我已经做了谷歌搜索，复制了一个示例`ssh_client.py`脚本，并修改了内容以适应我的需要。您可以到下面的站点获取基本模板 SSH 脚本，开始编写 SSH 脚本。 |
|   | URL: [`https://gist.github.com/ghawkgu/944017`](https://gist.github.com/ghawkgu/944017) |
|   | ssh _ client . py |
|   | `#!/usr/bin/env python` |
|   | `import paramiko` |
|   | `hostname = 'localhost'` |
|   | `port = 22` |
|   | `username = 'foo'` |
|   | `password = 'xxxYYYxxx'` |
|   | `if __name__ == "__main__":` |
|   | `paramiko.util.log_to_file('paramiko.log')` |
|   | `s = paramiko.SSHClient()` |
|   | `s.load_system_host_keys()` |
|   | `s.connect(hostname, port, username, password)` |
|   | `stdin, stdout, stderr = s.exec_command('ifconfig')` |
|   | `print stdout.read()` |
|   | `s.close()` |
|   | 该脚本将在两台路由器上配置 NTP 服务器，并在网络上启用时间同步。NTP 在企业网络中起着重要作用，它可以保持所有设备的时间同步，因此系统日志和报告服务器上的时间戳精确到秒。因为这不是一本网络书籍，所以我不会对 stratum 和 NTP 特性进行过多的描述，但是在这里要注意一些事情。首先，思科和许多厂商的网络设备不信任运行在 Windows 机器上的微软 W32tm 服务。第二，某些 Cisco 网络和服务器设备的时间必须设置为最低层，以作为可靠的时间源。通常，该值等于或小于第五层，下层是更值得信任的时间。 |
|   | 修改基本`paramiko`登录配置。完成后，它应该类似于以下脚本: |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `nano ssh_ntp_lab.py` |
|   | `GNU nano 4.8`**/home/pynetato/ssh _ labs/ssh _ NTP _ lab . py** |
|   | `#!/usr/bin/env python3` |
|   | `import paramiko` `# import paramiko library` |
|   | `import time` `# import time module` |
|   | `from datetime import datetime` `# import datetime module from datetime library` |
|   | `t_ref = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")` `# Time reference in desired time format` |
|   | `file1 = open("routerlist")` `# open routerlist as file1` |
|   | `for line in file1:` `# for loop for router ip address` |
|   | `print(t_ref)` `# print time reference` |
|   | `print ("Now logging into " + (line))` `# print statement` |
|   | `ip_address = line.strip()` `# remove any white spaces` |
|   | `file2= open("adminpass")` `# open adminpass as file2` |
|   | `for line1 in file2:` `# read the first line(admin ID) in file 2` |
|   | `username = line1.strip()` `# remove any white spaces` |
|   | `for line2 in file2` `: # read the second line (password) in file2` |
|   | `password = line2.strip()` `# remove any white spaces` |
|   | `ssh_client = paramiko.SSHClient()` `# Create paramiko SSH client object` |
|   | `ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())` `# Automatically accept host key policy` |
|   | `ssh_client.connect(hostname=ip_address,username=username,password=password)` `# SSH connection objects` |
|   | `print ("Successful connection to " + (ip_address) +"\n")` `# print statement` |
|   | `print ("Now completing following tasks : " + "\n")` `# print statement` |
|   | `remote_connection = ssh_client.invoke_shell()` `# invoke shell session` |
|   | `output1 = remote_connection.recv(3000)` `# Catches and removes the login prompt output` |
|   | `# print(output1.decode('ascii'))` `# remove hash to print the login prompt message` |
|   | `remote_connection.send("configure terminal\n")` `# Move to configuration mode` |
|   | `print ("Configuring NTP Server")` `# print statement` |
|   | `remote_connection.send("ntp server 192.168.183.130\n")` `# configure NTP server` |
|   | `remote_connection.send("end\n")` `# go back to exec privilege mode` |
|   | `remote_connection.send("copy running-config start-config\n")` `# send save command` |
|   | `print ()` `# print remote_connections` |
|   | `time.sleep(2)` `#` |
|   | `output2 = remote_connection.recv(6000)` `# capture session in output variable` |
|   | `print((output2).decode('ascii'))` `# print output using ASCII decoding` |
|   | `print (("Successfully configured your device & Disconnecting from ") + (ip_address))` `# Print statement` |
|   | `ssh_client.close` `# Close SSH connection` |
|   | `time.sleep(2)` `# Pause for 2 seconds` |
|   | `file1.close()` `# Close file1` |
|   | `file2.close()` `# Close file2` |
|   | `^G Get Help  ^O Write Out    ^W Where Is   ^K Cut Text    ^J Justify    ^C Cur Pos` |
|   | `^X Exit      ^R Read File    ^\ Replace    ^U Paste Text  ^T To Spell   ^_ Go To Line` |
| **3** | 由于我们只有两台设备需要检查，这次您可以手动检查端口。登录`LAB-R1`和`lab-r2`，然后运行`show control-plane host open-ports`命令，检查 SSH 端口(22)是否正常工作并处于`LISTEN`状态。 |
|   | `LAB-R1#` `show control-plane host open-ports` |
|   | `Active internet connections (servers and established)` |
|   | `Prot         Local Address        Foreign Address     Service                State` |
|   | `tcp          *:22                 *:0                 SSH-Server             LISTEN` |
|   | `tcp          *:23                 *:0                 Telnet                 LISTEN` |
|   | `udp          *:56827              *:0                 udp_transport Server   LISTEN` |
|   | `lab-r2#` `show control-plane host open-ports` |
|   | `Active internet connections (servers and established)` |
|   | `Prot         Local Address        Foreign Address     Service                State` |
|   | `tcp          *:22                 *:0                 SSH-Server             LISTEN` |
|   | `tcp          *:23                 *:0                 Telnet                 LISTEN` |
|   | `udp          *:18999              *:0                 udp_transport Server   LISTEN` |
|   | 或者，您可以修改`display_show.py`文件并从 Python 文件中获取信息。下载`chapter 14_codes.zip`中包含的`display_show_control_plane.py`，使用它可以得到相同的结果。 |
|   | 源代码下载网址: [`https://github.com/pynetauto/apress_pynetauto`](https://github.com/pynetauto/apress_pynetauto) |
| **4** | 现在，在运行脚本之前，检查 NTP 服务是否在`centos8s1`上正确运行。如果您发现 NTP 服务没有运行，您必须在运行脚本之前解决该问题。在 CentOS 8.1 上，我们之前在第 [8](08.html) 章安装了`chronyd`，作为 NTP 服务器。以下是解决`chronyd`常见问题的命令。下一步，我们必须通过修改`chrony.conf`文件来完成服务器配置，使其成为一个功能服务器。 |
|   | `[pynetauto@centos8s1 ~]$` `systemctl status chronyd` |
|   | `[pynetauto@centos8s1 ~]$` `systemctl restart chronyd` |
|   | `[pynetauto@centos8s1 ~]$` `systemctl enable chronyd` |
|   | `[pynetauto@centos8s1 ~]$` `sudo firewall-cmd --add-port=123/udp --permanent` |
|   | `[pynetauto@centos8s1 ~]$` `sudo firewall-cmd --reload` |
|   | 如果您忘记安装`chrony`，请使用`dnf install`命令进行安装。 |
|   | `[pynetauto@centos8s1 ~]$` `dnf install chrony` |
|   | 另外，检查 NTP 服务器上的当前时间。 |
|   | `[pynetauto@centos8s1 ~]$` `date` |
|   | `Tue Jan 12 17:13:16 AEDT 2021` |
|   | 对于`chronyd`，您必须从这里指定的 URL 获取您的本地区域附近的 NTP 服务器列表，并且您必须更新 NTP 服务器池，如图 [14-1](#Fig1) 所示。确保用散列(`#`)注释掉第一个默认行。请确保从以下站点选择离您最近的公共 NTP 服务器: |
|   | URL: [`https://www.pool.ntp.org/en/`](https://www.pool.ntp.org/en/) |
|   | 在`sudo`模式下打开文件，修改`/etc/`下的`chrony.conf`文件。 |
|   | `[pynetauto@centos8s1 ~]$` `sudo nano /etc/chrony.conf` |
|   | `GNU nano 4.8` `/etc/chrony.conf` |
|   | `# Use public servers from the pool.ntp.org project.` |
|   | `# Please consider joining the pool (` `http://www.pool.ntp.org/join.html).` |
|   | `# pool 2.centos.pool.ntp.org iburst` |
|   | `server 0.oceania.pool.ntp.org` |
|   | `server 1.oceania.pool.ntp.org` |
|   | `server 2.oceania.pool.ntp.org` |
|   | `server 3.oceania.pool.ntp.org` |
|   | `# Record the rate at which the system clock gains/losses time.` |
|   | `driftfile /var/lib/chrony/drift` |
|   | `[...omitted for brevity]` |
|   | `^G Get Help  ^O Write Out   ^W Where Is   ^K Cut Text    ^J Justify   ^C Cur Pos` |
|   | `^X Exit      ^R Read File   ^\ Replace    ^U Paste Text  ^T To Spell  ^_ Go To Line` |
|   | 当您在同一个配置文件上时，转到该行的末尾，确认您的网络已被允许从本地网络访问此 NTP 服务器。如果您已经在第 [8](08.html) 章中对此进行了配置，它应该已经在那里了。 |
|   | `[... omitted for brevity]` |
|   | `# Allow NTP client access from the local network.` |
|   | `allow 192.168.183.0/24` |
| **5** | 如果一切看起来都井然有序，返回到`ubuntu8s1` Python 服务器并运行`ssh_ntp_lab.py`脚本。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `python ssh_ntp_lab.py` |
|   | `2021-01-12_17-31-59` |
|   | `Now logging into 192.168.183.10` |
|   | `Successful connection to 192.168.183.10` |
|   | `Now completing following tasks :` |
|   | `Configuring NTP Server` |
|   | `configure terminal` |
|   | `Enter configuration commands, one per line.  End with CNTL/Z.` |
|   | `LAB-R1(config)#ntp server 192.168.183.130` |
|   | `LAB-R1(config)#end` |
|   | `LAB-R1#copy running-config start-config` |
|   | `Destination filename [start-config]?` |
|   | `Successfully configured your device & Disconnecting from 192.168.183.10` |
|   | `2021-01-12_17-31-59` |
|   | `Now logging into 192.168.183.20` |
|   | `Successful connection to 192.168.183.20` |
|   | `Now completing following tasks :` |
|   | `Configuring NTP Server` |
|   | `configure terminal` |
|   | `Enter configuration commands, one per line.  End with CNTL/Z.` |
|   | `lab-r2(config)#ntp server 192.168.183.130` |
|   | `lab-r2(config)#end` |
|   | `lab-r2#copy running-config start-config` |
|   | `Destination filename [start-config]?` |
|   | `Successfully configured your device & Disconnecting from 192.168.183.20` |
| **6** | 一旦 NTP 脚本成功运行，使用新的`show`命令修改`display_show.py`脚本并运行它。在这个实验室中，我将新的`show`命令脚本命名为`display_show_ntp.py`。要检查 NTP 状态，请在脚本中包含`show ntp status`命令。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `cp display_show.py display_show_ntp.py` |
|   | 您可以随时在 CLI 中检查状态，以便快速验证。 |
|   | `LAB-R1#` `show ntp status` |
|   | `lab-r2 #` `show ntp status` |
|   | 如果您看到如下所示的类似 NTP 状态消息，您的路由器的时间已经与 Linux NTP 服务器的时间(192.168.183.130)同步。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `python3 display_show_ntp.py` |
|   | `Connected to 192.168.183.10` |
|   | `show ntp status` |
|   | `Clock is synchronized, stratum 5, reference is 192.168.183.130` |
|   | `nominal freq is 1000.0003 Hz, actual freq is 1000.0003 Hz, precision is 2**15` |
|   | `ntp uptime is 191100 (1/100 of seconds), resolution is 1000` |
|   | `reference time is E3A7C697.1089E8E5 (06:56:23.064 UTC Tue Jan 12 2021)` |
|   | `clock offset is 9948.5451 msec, root delay is 7.75 msec` |
|   | `root dispersion is 16599.57 msec, peer dispersion is 2.51 msec` |
|   | `loopfilter state is 'SPIK' (Spike), drift is 0.000499999 s/s` |
|   | `system poll interval is 64, last update was 375 sec ago.` |
|   | `--------------------------------------------------------------------------------` |
|   | `Connected to 192.168.183.20` |
|   | `show ntp status` |
|   | `Clock is synchronized, stratum 5, reference is 192.168.183.130` |
|   | `nominal freq is 1000.0003 Hz, actual freq is 1000.0003 Hz, precision is 2**15` |
|   | `ntp uptime is 190000 (1/100 of seconds), resolution is 1000` |
|   | `reference time is E3A7C6A4.121D0A5D (06:56:36.070 UTC Tue Jan 12 2021)` |
|   | `clock offset is 2100.9149 msec, root delay is 12.98 msec` |
|   | `root dispersion is 7958.81 msec, peer dispersion is 4.38 msec` |
|   | `loopfilter state is 'CTRL' (Normal Controlled Loop), drift is 0.000499999 s/s` |
|   | `system poll interval is 64, last update was 736sec ago.` |
|   | `--------------------------------------------------------------------------------` |

您已经成功地在`LAB-R1`和`lab-r2`路由器上配置了 NTP 服务器，并与网络中的 Linux NTP 服务器同步了时间。此外，不需要一次输入一个 IP 地址和管理员凭证；在运行脚本之前，您将它们预加载到两个独立的文件中。这将在第 8 章的`cron`实验室派上用场。密码安全和密码库是重要的主题；然而，它们超出了本书的范围。现在，让我们快速进入下一个 SSH 实验，将我们的设备备份到我们的 TFTP 服务器。

## paramiko 实验 3:创建一个交互式 paramiko SSH 脚本，将正在运行的配置保存到 TFTP 服务器

在本实验中，您将使用 Python 的`input`函数和`getpass`模块制作一个交互式工具来获取网络管理员的 ID 和密码。为了简化实验，脚本将使用一个包含所有 IP 地址的列表，备份文件将保存到运行在`centos8s1` (192.168.183.130)上的 TFTP 服务器。通过简单的修改，您可以定制和制作操作工具，以节省时间和资源。在本实验中，您只对五台设备进行备份，但是想象一下，如果像在一些客户的网络中一样，需要在 500 台设备上完成这项工作。此外，如果您想使用自动调度程序每天运行这样的脚本，工程师们不再需要坐在他们的计算机前进行备份。当然，也有企业级网络设备备份解决方案，但我们希望通过在我们的实验室中重新创建并运行这些工具，来深入了解这个主题，并了解这些工具的工作原理。见图 [14-3](#Fig3) 。

![../images/492721_1_En_14_Chapter/492721_1_En_14_Fig3_HTML.jpg](../images/492721_1_En_14_Chapter/492721_1_En_14_Fig3_HTML.jpg)

图 14-3。

SSH paramiko 实验 3，使用中的设备

开箱即用的供应商解决方案具有卓越的功能，适合大多数规模庞大的标准化客户环境。尽管如此，您几乎总是需要一些定制，以使解决方案在真实的生产环境中更加通用和有用。没有进一步的讨论，让我们写一个交互式工具 SSH 到我们的路由器和交换机，并采取一些备份。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 作为第一步，检查是否可以从 Python 自动化服务器 ping 所有网络设备。这一次，您将再次使用`fping`并通过一个命令检查连通性。如果您仍然没有安装`fping`，现在使用以下命令进行安装: |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `sudo apt-get install fping` |
|   | 成功安装`fping`后，运行如下命令来确认您的服务器的网络连接: |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `fping 192.168.183.10 192.168.183.20 192.168.183.101 192.168.183.102 192.168.183.133` |
|   | `192.168.183.10 is alive` |
|   | `192.168.183.20 is alive` |
|   | `192.168.183.133 is alive` |
|   | `192.168.183.102 is alive` |
|   | `192.168.183.101 is alive` |
| **2** | 您已经确认了网络连接，现在让我们来确认我们之前安装的 TFTP 服务是否在`centos8s1`多 IP 服务服务器上正常工作。使用以下命令检查 Linux 服务器上 TFTP 服务的运行状态。 |
|   | TFTP ( `xinetd`)处于活动状态，并且在监听模式下与端口 69 一起正常工作。 |
|   | `[pynetauto@centos8s1 ~]$` `systemctl is-active xinetd.service` |
|   | `active` |
|   | `[pynetauto@centos8s1 ~]$ sudo netstat -anp &#124; grep 69` |
|   | `[sudo] password for pynetauto:` |
|   | `udp        0      0 0.0.0.0:69           0.0.0.0:*                        1241/xinetd` |
|   | `udp6       0      0 :::69                   :::*` |
|   | `[... omitted for brevity]` |

![../images/492721_1_En_14_Chapter/492721_1_En_14_Figc_HTML.gif](../images/492721_1_En_14_Chapter/492721_1_En_14_Figc_HTML.gif)

如果您的服务器的端口 69 没有列出，您必须使用以下命令使用`ufw`命令来允许您的服务器上的端口:

`[pynetauto@centos8s1 ~]$ sudo ufw allow 69/udp`

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **3** | 现在，为了让这个实验更加有趣，我们想测量端到端任务从开始到结束需要多长时间，这样我们就可以测量脚本的速度，并根据需要调整睡眠计时器。正如您已经在`paramiko`和`telnet`脚本中观察到的，已经添加了`time.sleep(s)`代码，以允许虚拟路由器和交换机有足够的响应时间，并且通过`netmiko`脚本，许多计时器都内置到库中。然而，它并不总是 100%准确，所以有时，你仍然需要使用睡眠定时器来定制不同的设备。 |
|   | 当你创建应用程序时，你必须开发一些小创意和小工具来使你的 Python 脚本更有价值。下面显示的计时器收费脚本是一个建议，这个工具测量从 1 到 1000 万计数所需的时间。你可以调整数字，看看你的电脑计算数字的速度有多快。您还可以将您的函数或任务放在脚本中间，以测量脚本运行的速度。 |
|   | 在 Python 中，一个函数处理数据的速度比另一个函数快得多，花时间测试脚本的速度是值得的。毕竟，Python 并不以其速度著称，但通常是 Python 编码人员选择了错误的模块或工具，并给脚本增加了延迟。此外，在网络自动化领域，速度很重要，但不是 Python 应用程序最关键的部分。通常精度比速度更重要。如果你真的需要速度，总有一种最接近机器语言的 C 编程语言。无论如何，在您的服务器上编写以下代码，并检查这个简单的脚本是如何工作的。虽然这是一个简单的脚本，但是许多简单的脚本构成了您的应用程序的基础。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `nano timer_tool.py` |
|   | `GNU nano 4.8` `/home/pynetauto/ssh_labs/timer_tool.py` |
|   | `import time` `# Import time module` |
|   | `start_timer = time.mktime(time.localtime())` `# Start time` |
|   | `########## REPLACE ME! #########` |
|   | `big_number = range(10000000)` `# Put some function or task to run here` |
|   | `for i in big_number:` |
|   | `print(i,end=" ")` |
|   | `# print(" ".join(str(i) for i in big_number))` `# This is a join method to print the number, can replace above two lines of code` |
|   | `##############################` |
|   | `total_time = time.mktime(time.localtime()) - start_timer` `# End time minus start time` |
|   | `print("Total time : ", total_time, "seconds")` `# Total time format` |
|   | `^G Get Help  ^O Write Out    ^W Where Is   ^K Cut Text    ^J Justify   ^C Cur Pos` |
|   | `^X Exit      ^R Read File    ^\ Replace    ^U Paste Text  ^T To Spell  ^_ Go To Line` |
| **4** | 猜猜你的电脑从 1 数到 1000 万需要多长时间？在您的`ubuntu20s1` Python 服务器上，通过键入`python timer_tool.py`运行计时器工具。对于测试计算机来说，从 1 数到 1000 万用了整整 22 秒。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `python timer_tool.py` |
|   | `[...omitted for brevity]` |
|   | `9999974 9999975 9999976 9999977 9999978 9999979 9999980 9999981 9999982 9999983 9999984 9999985 9999986 9999987 9999988 9999989 9999990 9999991 9999992 9999993 9999994 9999995 9999996 9999997 9999998 9999999` |
|   | `Total time :  22.0 seconds` |
| **5** | 为了使我们的脚本能够与网络管理员交互，让我们使用`getpass`库的`getpass`模块制作一个用户名和密码收集器工具。使用`getpass`模块，我们可以隐藏输入的密码，并且通过一些修改，我们可以让用户再次输入密码，以验证第一个密码。密码经常输入错误，我们可以通过将`if`语句合并到我们的密码脚本中来解决这个问题。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `nano password_tool.py` |
|   | `GNU nano 4.8` `/home/pynetauto/ssh_labs/password_tool.py` |
|   | `from getpass import getpass` `# Import getpass module from getpass library` |
|   | `def get_credentials()` `:# Create get_credentials function` |
|   | `#Prompts for and returns a username and password` `# Comment` |
|   | `username = input("*Enter Network Admin ID : ")` `# Prompt user for username` |
|   | `password = None` `# Set original password to None` |
|   | `while not password:` `# Keep prompting til password is entered` |
|   | `password = getpass("*Enter Network Admin PWD : ")` `# Prompt for password` |
|   | `password_verify = getpass("**Confirm Network Admin PWD : ")` `# Verify password again` |
|   | `if password != password_verify:` `# If password fails to verify, run the following script` |
|   | `print("! Network Admin Passwords do not match. Please try again.")` `# Inform the user of mismatch` |
|   | `password = None` `# Reset password to None and ask for the password again` |
|   | `print(username, password)` `# For testing purpose only, remove this when applied to the script` |
|   | `return username, password` `#returns username and password` |
|   | `get_credentials()` `# Run get_credentials() function` |
|   | `^G Get Help  ^O Write Out    ^W Where Is   ^K Cut Text    ^J Justify   ^C Cur Pos` |
|   | `^X Exit      ^R Read File    ^\ Replace    ^U Paste Text  ^T To Spell  ^_ Go To Line` |
| **6** | 请创建一个密码工具脚本，并从您的`ubuntu20s1`服务器运行它。出于测试目的，我们将在这里打印用户名和密码，但您必须从功能中删除`print (` `username` `,` `password` `)`命令，并在按下回车键后进入静默状态。根据需要注释掉`print`语句。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `python password_tool.py` |
|   | `*Enter Network Admin ID :` `pynetauto` |
|   | `*Enter Network Admin PWD :********` |
|   | `**Confirm Network Admin PWD : ********` |
|   | `pynetauto cisco123` |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` |
| **7** | 现在，您已经开发了两个迷你工具，让我们编写交互代码来备份我们设备的实验室网络。完成`paramiko`脚本后，您的脚本应该类似于下面这样。详细的解释嵌入在代码中，所以在完整地编写脚本之前，先研究一下代码。如果你遇到问题，参考源代码，但只有在必要的时候。通常大多数代码是由你在键盘上输入的，而不是剪切和粘贴的！ |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `nano interactive_backup.py` |
|   | `GNU nano 4.8` `/home/pynetauto/ssh_labs/interactive_backup.py` |
|   | `#!/usr/bin/env python3 # for Linux system to run this script as python3 file` |
|   | `import re # import regular expression module` |
|   | `import time # import time module` |
|   | `import paramiko # import paramiko library` |
|   | `from datetime import datetime # import datetime module from datetime library` |
|   | `from getpass import getpass # Import getpass module from getpass library` |
|   | `t_ref = datetime.now().strftime("%Y-%m-%d_%H-%M-%S") # Time reference to be used for file name` |
|   | `device_list = ["192.168.183.10", "192.168.183.20", "192.168.183.101", "192.168.183.102", "192.168.183.133"] # Device list` |
|   | `start_timer = time.mktime(time.localtime()) # Start time` |
|   | `def get_credentials():# Define a function called get_credentials` |
|   | `#Prompts for, and returns a username and password # comment` |
|   | `global username # Make username global, so it can be used throughout this script` |
|   | `global password # Make password global, so it can be used throughout this script` |
|   | `username = input("*Enter Network Admin ID : ") # Enter username` |
|   | `password = None # set password default value to None` |
|   | `while not password: # Until password is entered` |
|   | `password = getpass("*Enter Network Admin PWD : ") # Enter the password first time` |
|   | `password_verify = getpass("**Confirm Network Admin PWD : ") # Get password for verification, second time` |
|   | `if password != password_verify: # Password verification` |
|   | `print("! Network Admin Passwords do not match. Please try again.") # Informational` |
|   | `password = None # Set password to None` |
|   | `return username, password # Optional, returns username and password` |
|   | `get_credentials()# Run get_credentials function, to save username and password` |
|   | `for ip in device_list: # for loop to grab device IP addresses` |
|   | `print(t_ref) # Comment for user information` |
|   | `print("Now logging into " + (ip)) # Informational` |
|   | `ssh_client = paramiko.SSHClient()# Initiate paramiko SSH client session as ssh_client` |
|   | `ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) # Accept missing host key policy` |
|   | `ssh_client.connect(hostname=ip,username=username,password=password) # SSH connection with credentials` |
|   | `print("Successful connection to " + (ip) +"\n") # Informational` |
|   | `print("Now making running-config backup of " + (ip) + "\n") # Comment for user information` |
|   | `remote_connection = ssh_client.invoke_shell() # Invoke shell` |
|   | `time.sleep(3) # Pause 3 seconds to invoke shell` |
|   | `remote_connection.send("copy running-config tftp\n") # Send copy command` |
|   | `remote_connection.send("192.168.183.130\n") # Respond to TFTP server IP request, TFTP IP` |
|   | `remote_connection.send((ip)+ ".bak@" + (t_ref)+ "\n") # Respond to backup file name request` |
|   | `time.sleep(3) ## Pause for 3 seconds, give device to respond` |
|   | `print() # Print screen` |
|   | `time.sleep(3) # Pause for 3 seconds, give time to process data` |
|   | `output = remote_connection.recv(65535) # Receive output up to 65535 lines` |
|   | `print((output).decode('ascii')) #Print output using ASCII decoding method` |
|   | `print(("Successfully backed-up running-config to TFTP & Disconnecting from ") + (ip) + "\n") # Print statement to provide an update to the user` |
|   | `print("-"*80) # Print ~ 80 times` |
|   | `ssh_client.close # Close SSH session` |
|   | `time.sleep(1) # Pause for 1 second` |
|   | `total_time = time.mktime(time.localtime()) - start_timer # Start time minus current time` |
|   | `print("Total time : ", total_time, "seconds") # Print the total time to run the script in seconds` |
|   | `^G Get Help  ^O Write Out    ^W Where Is   ^K Cut Text    ^J Justify   ^C Cur Pos` |
|   | `^X Exit      ^R Read File    ^\ Replace    ^U Paste Text  ^T To Spell  ^_ Go To Line` |
| **8** | 在第 8 章[中](08.html)，你在`centos8s1`服务器上创建了一个`tftpdir`目录用于 TFTP 文件的共享和存储。作为运行前面脚本的预检查，检查`/var/tftpdir`目录中的文件。在 Linux 中，改变大小的文件通常放在`var`(变量)目录下。 |
|   | `[pynetauto@centos8s1 ~]$` `cd /var/tftpdir` |
|   | `[pynetauto@centos8s1 tftpdir]$` `pwd` |
|   | `/var/tftpdir` |
|   | `[pynetauto@centos8s1 tftpdir]$` `ls -lh` |
|   | `total 45M` |
|   | `-rw-r--r--. 1 pynetauto pynetauto  45M Jul 18 04:59 c3725-adventerprisek9-mz.124-15.T14.bin` |
|   | `-rw-rw-r--. 1 tftpuser  tftpuser  1.2K Jan  9 00:07 running-config` |
|   | `-rw-rw-r--. 1 tftpuser  tftpuser   100 Jun  8  2020 transfer_file01` |
|   | `-rw-r--r--. 1 root      root       100 Jun  8  2020 transfer_file77` |
| **9** | 回到 Python 自动化服务器(`ubuntu20s1`)。好了，现在让我们运行交互式备份脚本，通过 SSH 访问每台设备，并在 TFTP 服务器上备份每台设备的运行配置。运行`python interactive_backup.py`命令，输入网络管理员凭证，然后坐下来观察。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `python interactive_backup.py` |
|   | `*Enter Network Admin ID :` `pynetauto` |
|   | `*Enter Network Admin PWD : ********` |
|   | `**Confirm Network Admin PWD : ********` |
|   | `2021-01-12_18-42-23` |
|   | `Now logging into 192.168.183.10` |
|   | `Successful connection to 192.168.183.10` |
|   | `Now making running-config backup of 192.168.183.10` |
|   | `[...omitted for brevity]` |
|   | `Destination filename [lab-r1-confg]? 192.168.183.10.bak@2021-01-12_18-42-23` |
|   | `!!` |
|   | `3953 bytes copied in 2.972 secs (1330 bytes/sec)` |
|   | `LAB-R1#` |
|   | `Successfully backed-up running-config to TFTP & Disconnecting from 192.168.183.10` |
|   | `--------------------------------------------------------------------------------` |
|   | `2021-01-12_18-42-23` |
|   | `Now logging into 192.168.183.20` |
|   | `Successful connection to 192.168.183.20` |
|   | `[...omitted for brevity]` |
|   | `lab-r2#` |
|   | `Successfully backed-up running-config to TFTP & Disconnecting from 192.168.183.20` |
|   | `--------------------------------------------------------------------------------` |
|   | `2021-01-12_18-42-23` |
|   | `Now logging into 192.168.183.101` |
|   | `Successful connection to 192.168.183.101` |
|   | `[...omitted for brevity]` |
|   | `LAB-SW1#` |
|   | `Successfully backed-up running-config to TFTP & Disconnecting from 192.168.183.101` |
|   | `--------------------------------------------------------------------------------` |
|   | `2021-01-12_18-42-23` |
|   | `Now logging into 192.168.183.102` |
|   | `Successful connection to 192.168.183.102` |
|   | `[...omitted for brevity]` |
|   | `lab-sw2#` |
|   | `Successfully backed-up running-config to TFTP & Disconnecting from 192.168.183.102` |
|   | `--------------------------------------------------------------------------------` |
|   | `2021-01-12_18-42-23` |
|   | `Now logging into 192.168.183.133` |
|   | `Successful connection to 192.168.183.133` |
|   | `[...omitted for brevity]` |
|   | `R1#` |
|   | `Successfully backed-up running-config to TFTP & Disconnecting from 192.168.183.133` |
|   | `--------------------------------------------------------------------------------` |
|   | `Total time :  78.0 seconds` |
|   | 将五台实验室设备备份到 TFTP 服务器需要 78 秒。在接下来的`netmiko`实验中，我们还将了解 FTP 的文件管理，但是我们到目前为止学到的概念可以在 FTP 或 SFTP 场景中重用。 |
| **10** | 现在重新登录到您的`centos8s1`服务器；然后将您的目录更改为`/var/tftpdir`并运行`ls –lh`命令。您应该可以找到所有带有我们代码中指定的日期和时间戳的设备备份。现在，您已经完成了捕获所有设备的运行配置的 SSH 交互式脚本。我们在这里只使用了五个设备，但是设备的数量将会成倍增加，甚至在生产中您都不必担心。太好了。 |
|   | `[pynetauto@centos8s1 tftpdir]$` `ls -lh 192.*` |
|   | `-rw-rw-r--. 1 tftpuser tftpuser 4.5K Jan 12 18:43 192.168.183.101.bak@2021-01-12_18-42-23` |
|   | `-rw-rw-r--. 1 tftpuser tftpuser 3.8K Jan 12 18:43 192.168.183.102.bak@2021-01-12_18-42-23` |
|   | `-rw-rw-r--. 1 tftpuser tftpuser 3.5K Jan 12 18:43 192.168.183.10.bak@2021-01-12_18-42-23` |
|   | `-rw-rw-r--. 1 tftpuser tftpuser 1.4K Jan 12 18:43 192.168.183.133.bak@2021-01-12_18-42-23` |
|   | 听着... |

现在，您已经通过 SSH 连接和 TFTP 文件传输完成了正在运行的配置备份，从而完成了`paramiko`实验。您可以轻松地调整配置，使用 FTP 或 SFTP 文件传输进行进一步的测试和开发。在本章的后半部分，你将在不同的场景中使用通用的`netmiko`库。

## Python SSH 实验室:netmiko

是一个优秀的 SSH 库，用于通过 SSH 连接管理网络设备。尽管如此，你必须努力工作来微调你的脚本部分，使其顺利运行。例如，通过 SSH 连接和运行不同命令的时间需要特别注意时间和提示。幸运的是，一位 CCIE 退休工程师已经努力工作，并考虑了我们在使用`paramiko`时可能遇到的许多问题。他开发了一个令人难以置信的叫做`netmiko`的 Python 库。`netmiko`是一个多供应商库，用于简化`paramiko`到网络设备的 SSH 连接；Kirk Byers 开发它是为了支持各种厂商的网络设备。在 Python 中，世界上许多隐藏的技术大师并不害怕分享他们的知识和智慧。在使用了大约两年的`netmiko`之后，我无法感谢 Kirk Byers 将我从`paramiko`的许多陷阱中拯救出来。他已经想到了`paramiko`的 SSH 连接问题。我们不得不享受一个工程师的艺术和汗水的成果，开拓 Python 网络自动化。这里是 Kirk 的官方`netmiko`链接和 GitHub 网站供进一步阅读。还有，`nornir`项目是`netmiko`的扩展；它具有 Ansible 的相同特性，但是是用 Python 编写的。`nornir`超出了本书的范围，但是当你有时间的时候，请上网查一下。

网址: [`https://pynet.twb-tech.com/`](https://pynet.twb-tech.com/) (Kirk Byers 的《网络工程师的 Python》)

网址:【with Netmiko 入门)

网址: [`https://github.com/ktbyers/netmiko/blob/master/netmiko/ssh_dispatcher.py`](https://github.com/ktbyers/netmiko/blob/master/netmiko/ssh_dispatcher.py) (支持的设备列表)

现在，在编写第一个`netmiko` Python 脚本之前，确保已经使用`sudo pip3 install netmiko`安装了`netmiko`库，如下所示:

```py
pynetauto@ubuntu20s1:~$ sudo pip3 install netmiko

[sudo] password for pynetauto:
Collecting netmiko
  Downloading netmiko-3.2.0-py2.py3-none-any.whl (157 kB)
     |████████████████████████████| 157 kB 4.8 MB/s
Requirement already satisfied: pyserial in /usr/lib/python3/dist-packages (from netmiko) (3.4)
[... omitted for brevity]

Successfully installed netmiko-3.2.0 scp-0.13.2 textfsm-1.1.0

```

在安装完`netmiko`之后，启动 Python 解释器并导入`netmiko`模块。您可以使用`pip3 freeze`命令来检查已安装的库，但是有时即使它被列出，您也无法在系统上运行多个 Python 版本的环境中使用该模块。如果解释器上没有返回错误，那么它已经成功安装，您可以开始编写下面的代码了:

```py
pynetauto@ubuntu20s1:~/ssh_labs$ pip3 freeze

...
netmiko==3.3.2
...

pynetauto@ubuntu20s1:~$ python3

Python 3.8.2 (default, Jul 16 2020, 14:00:26)
[GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import netmiko

>>>

```

验证后，按 Ctrl+Z 或键入`exit()`或`quit()`关闭 Python 3 解释器。

## netmiko 实验 1: netmiko 使用字典来存储设备信息，而不是 JSON 对象

使用 netmiko，您必须以字典格式提供设备信息，其中至少包含基本的 SSH 登录信息，例如设备类型、IP(主机名)、管理员 ID 和密码。您还可以提供其他可选信息，如密码、端口号和登录状态。乍一看，这种字典格式类似于 JavaScript Object Notation (JSON)格式的数据集。`netmiko`设备信息是内置的 Python 字典，不是浏览器和服务器用来发送数据的 JSON 数据集。典型的`netmiko`字典通常是这样的:

```py
cisco_3850 = {
    'device_type': 'cisco_ios',
    'host':   '10.20.30.40',
    'username': 'cisco',
    'password': 'password123',
    'port' : 8022,          # optional, if not used defaults to 22
    'secret': 'secret123',     # optional, if not used defaults to ''
}

```

如果你想像前面的`paramiko`例子一样把前面的字典变平，你可以这样写字典。尽管如此，以前的结构化信息看起来更好看。

```py
cisco_csr1k = {"device_type":"cisco_xe", "ip":"192.168.183.1", "username":"pynetauto", "password":"cisco123"}

```

我们还可以通过混合一些输入语句和`getpass`函数来请求用户输入，从而增强`netmiko`字典，如下所示:

```py
from netmiko import ConnectHandler
from getpass import getpass

device1 = {
'device_type': 'cisco_ios',
'ip': input('IP Address : '),
'username': input('Enter username : '),
'password': getpass('SSH password : '),
}

```

在进入`netmiko` lab 1 之前，我们将确认`netmiko`字典不是 JSON 对象。让我们快速地在 Python 解释器中输入这段代码来确认这个事实。

![../images/492721_1_En_14_Chapter/492721_1_En_14_Figd_HTML.gif](../images/492721_1_En_14_Chapter/492721_1_En_14_Figd_HTML.gif)

打开 Python 解释器，在解释器窗口中输入以下内容。确保在创建字典时使用双引号，`device1`。Python 会自动把它们转换成单引号，你就知道为什么了。首先，检查一个`netmiko`字典的属性。

`>>>` `device1 = {"device_type":"cisco_ios", "ip":"192.168.183.10", "username":"pynetauto", "password":"cisco123"}`

`>>>` `print(device1)`

`{'device_type': 'cisco_ios', 'ip': '192.168.183.10', 'username': 'pynetauto', 'password': 'cisco123'}`

`>>>` `print(type(device1))`

`<class 'dict'>`

`>>> dir(device1)`

`['__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__',`

`(omitted for brevity)`

`'update', 'values']`

使用`dumps`方法将`device1`字典转换成 JSON 格式。当我们打印转换后的 JSON 对象时，它们看起来像一个 Python 字典，但是关键的区别是所有的键和值集都用双引号括起来。

`>>>` `import json`

`>>>` `device2 = json.dumps(device1)`

`>>>` `print(device2)`

`{"device_type": "cisco_ios", "ip": "192.168.183.10", "username": "pynetauto", "password": "cisco123"}`

`>>>` `print(type(device2))`

`<class 'str'>`

乍一看，您可能会认为 JSON 对象与`netmiko` dictionary 对象相同，但它是一个字符串对象，正如`dir()`方法所揭示的那样。JSON 对象属于 Python 内置的`str`类，当然`netmiko`字典属于内置的`dict`类。

`>>>` `dir(device2)`

`['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', (omitted for brevity)`

`, 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']`

`# Quickly check if device1 is the same as device2`

`>>>` `if device1 == device2:`

`...` `print(True)`

`...` `else:`

`...` `print(False)`

`...`

`False`

在`netmiko`实验 1 中，您将学习如何在 Cisco 路由器上使用 TCL shell 命令创建目录和文件，以便您可以创建虚拟文件来练习从路由器的`flash:`中删除文件。您将使用 IOSv 路由器`LAB-R1`，以保持简单，因为您将编写的实际脚本开始变得复杂，尤其是如果您来自非思科网络背景。尝试将注意力集中在概念上，而不是 IOSv 映像有多旧。正如我在第一章中解释的那样，最新和最棒的工具是好的，但是它们不需要学习网络或 Python 网络自动化的基本概念。见图 [14-4](#Fig4) 。

![../images/492721_1_En_14_Chapter/492721_1_En_14_Fig4_HTML.jpg](../images/492721_1_En_14_Chapter/492721_1_En_14_Fig4_HTML.jpg)

图 14-4。

SSH netmiko 实验 1，正在使用的设备

本实验的目的是让您练习使用 Python 脚本从 Cisco 设备的`flash` `:`中删除文件，而不是直接连接到 Cisco 设备。您将首先格式化`LAB-R1`的闪存，使用`mkdir`命令创建一个目录，并使用传统的 TCL shell 命令创建一些要删除的文件。我们应该能够编写 Python 代码，允许我们删除旧文件，还允许我们导航到一个文件夹来定位我们正在寻找的文件，以便 Python 应用程序可以根据需要删除这些文件。虽然您可能看不出与您的工作有任何关系，但这个特性在 IOS 升级应用程序开发中非常有用。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 打开`LAB-R1`的控制台窗口，格式化磁盘 0，这样就没有文件了。 |
|   | `LAB-R1#``format flash`T2】 |
|   | `Format operation may take a while. Continue? [confirm]` |
|   | `Format operation will destroy all data in "flash:".  Continue? [confirm]` |
|   | `Format: All system sectors written. OK...` |
|   | `Format: Total sectors in formatted partition: 4193217` |
|   | `Format: Total bytes in formatted partition: 2146927104` |
|   | `Format: Operation completed successfully.` |
|   | `Format of flash0: complete` |
|   | `LAB-R1#show flash:` |
|   | `-#- --length-- -----date/time------ path` |
|   | `2142711808 bytes available (8192 bytes used)` |
| **2** | 使用`mkdir flash:/directory_name`在`flash` `:`下创建一个目录。 |
|   | `LAB-R1#` `mkdir flash:/old_files` |
|   | `Create directory filename [old_files]?` |
|   | `Created dir flash0:/old_files` |
|   | `LAB-R1#dir` |
|   | `Directory of flash0:/` |
|   | `4  drw-           0  Jan 12 2021 08:09:26 +00:00  old_files` |
|   | `2142720000 bytes total (2142707712 bytes free)` |
| **3** | 现在使用传统的 TCL shell 创建四个文件，如下所示。两个文件将在`flash` `:`下创建，另外两个文件将在`flash:old_files/`下创建。 |
|   | `LAB-R1#` `tclsh` |
|   | `LAB-R1(tcl)#` `puts [open "flash:Delete_me_1.bin" w+]` |
|   | `file0` |
|   | `LAB-R1(tcl)#` `puts [open "flash:Don't_delete_me_1.txt" w+]` |
|   | `file1` |
|   | `LAB-R1(tcl)#` `puts [open "flash:old_files/Delete_me_2.bin" w+]` |
|   | `file2` |
|   | `LAB-R1(tcl)#` `puts [open "flash:old_files/Don't_delete_me_2.txt" w+]` |
|   | `file3` |
|   | `LAB-R1(tcl)#` `dir` |
|   | `Directory of flash0:/` |
|   | `4  drw-           0  Jan 12 2021 08:09:26 +00:00  old_files` |
|   | `5  -rw-           0  Jan 12 2021 08:11:16 +00:00  Delete_me_1.bin` |
|   | `6  -rw-           0  Jan 12 2021 08:11:24 +00:00  Don't_delete_me_1.txt` |
|   | `2142720000 bytes total (2142707712 bytes free)` |
|   | `LAB-R1#` `dir flash:/old_files/` |
|   | `Directory of flash0:/old_files/` |
|   | `7  -rw-           0  Jan 12 2021 08:11:32 +00:00  Delete_me_2.bin` |
|   | `8  -rw-           0  Jan 12 2021 08:11:40 +00:00  Don't_delete_me_2.txt` |
|   | `2142720000 bytes total (2142707712 bytes free)` |
| **4** | 我们已经在`LAB-R1`的`flash:`上创建了一个虚拟目录和虚拟 IOS ( `.bin`)文件。让我们编写一个很酷的 SSH 脚本，使用`netmiko`库登录到`LAB-R1`，然后使用 Python 脚本删除一些`.bin`文件。是的，您可以登录到路由器的 CLI 并删除该文件，但是您可能会问，为什么要这么麻烦地用 Python 脚本创建它呢？第一，作为一个想为网络自动化写代码的读者，你必须做艰苦的工作来享受你的劳动成果。第二，这个剧本可以跟你顶嘴，可以团队合作。最后，想象一下，如果您要处理 100 台路由器或交换机，而不是一台设备。另外，想象一下你必须定期做这种训练，作为你工作的一部分。Python network automation 的真正威力在于它的循环(`for`循环和`while`循环)，在下一个实验中，让我们将这个脚本修改为较新的版本，并在多个设备上使用它。 |
|   | 查看引用嵌入描述的脚本。编写完代码后，转到第 5 步运行脚本。 |
|   | `GNU nano 4.8` `/home/pynetauto/ssh_labs/netmiko_delete_me.py` |
|   | `#!/usr/bin/env python3` |
|   | `import re` |
|   | `from netmiko import ConnectHandler` |
|   | `from getpass import getpass` |
|   | `import time` |
|   | `device1 = {` `#Netmiko dictionary for device1` |
|   | `'device_type': 'cisco_ios',` |
|   | `'ip': input('IP Address : '),` |
|   | `'username': input('Enter username : '),` |
|   | `'password': getpass('SSH password : '),` |
|   | `}` |
|   | `net_connect = ConnectHandler(**device1)` `# Netmiko ConnectHandler object` |
|   | `net_connect.send_command("terminal length 0\n")` `# Make terminal length to 0 to display all` |
|   | `time.sleep(1)` `# Pause for 1 second` |
|   | `dir_flash = net_connect.send_command("dir flash:\n")` `# Send "dir flash:" command` |
|   | `print(dir_flash)` `# Display content of dir flash output` |
|   | `p30 = re.compile(r'D[0-9a-zA-Z]{4}.*.bin')` `# Regular Expression to capture any file starting with "D", ends with "bin"` |
|   | `m30 = p30.search(dir_flash)` `# Search for first match of p30` |
|   | `time.sleep(1)` `# Pause for 1 second` |
|   | `# net_connect1.enable() (Optional, not required with privilege 15 access)` |
|   | `print("!!! WARNING - You cannot reverse this step.")` `# Message to user` |
|   | `# If dir_flash contains a string which satisfies p30 (True),` |
|   | `# then run this script to delete a file.` |
|   | `if bool(m30) == True:` `# If m30 is true` |
|   | `print("If you can see 'Delete_me.bin' file, select it and press Enter.")` `# Informational` |
|   | `del_cmd = "del flash:/"` `# Partial command 1` |
|   | `old_ios = input("*Old IOS (bin) file to delete : ")` `# Partial command 2, select a file under flash:` |
|   | `while not p30.match(old_ios) or old_ios not in dir_flash:` `# User input request until correct file name is given` |
|   | `old_ios = input("**Old IOS (bin) file to delete : ")` |
|   | `command = del_cmd + old_ios` `# Complete command (1 + 2)` |
|   | `output = net_connect.send_command_timing` `( # Special netmiko send_command_timing command with timer` |
|   | `command_string=command` `,` |
|   | `strip_prompt=False` `,` |
|   | `strip_command=False` |
|   | `)` |
|   | `if "Delete filename" in output:` `# if the returned output contains "Delete filename", send "Enter" (change line)` |
|   | `output += net_connect.send_command_timing(` |
|   | `command_string="\n",` |
|   | `strip_prompt=False,` |
|   | `strip_command=False` |
|   | `)` |
|   | `if "confirm" in output:` `# if the returned output contains "confirm", send "y"` |
|   | `output += net_connect.send_command_timing(` |
|   | `command_string="y",` |
|   | `strip_prompt=False,` |
|   | `strip_command=False` |
|   | `)` |
|   | `net_connect.disconnect` `# Disconnect from SSH session` |
|   | `print(output)` `# Informational` |
|   | `# If None (False), then run this script to search directory for .bin file to delete` |
|   | `elif bool(m30) == False:``# If no .bin file starting with D is found under "flash:", run this`T2】 |
|   | `print("No IOS file under 'flash:/', select the directory to view.")` `# Informational` |
|   | `open_dir = input("*Enter Directory name : ")` `# Partial command 1` |
|   | `while not open_dir in dir_flash:` `# Ask until correct response is received` |
|   | `open_dir = input("** Enter Directory name : ")` `# If file does not exist, request user input again` |
|   | `open_dir_cmd = (r"dir flash:/" + open_dir)` `# Completed command` |
|   | `send_open_dir = net_connect.send_command(open_dir_cmd)` `# Send the command` |
|   | `print(send_open_dir)` `# Informational` |
|   | `p31 = re.compile(r'D[0-9a-zA-Z]{4}.*.bin')` `# Regular Expression to capture any file starting with "D", ends with "bin"` |
|   | `m31 = p31.search(send_open_dir)` `# Send completed command` |
|   | `if bool(m31) == True:` `# If there is a file with the string satisfy p31 expression` |
|   | `print("If you see old IOS (bin) in the directory. Select it and press Enter.")` `# Informational` |
|   | `del_cmd = "del flash:/" + open_dir + "/"` `# Completed command` |
|   | `old_ios = input("*Old IOS (bin) file to delete : ")` `# Enter the .bin file to delete` |
|   | `while not p30.match(old_ios) or old_ios not in send_open_dir:` `# User input request until correct file name is given` |
|   | `old_ios = input("**Old IOS (bin) file to delete : ")` |
|   | `command = del_cmd + old_ios` `# Complete command` |
|   | `output = net_connect.send_command_timing(` `# Special netmiko send_command_timing command with timer` |
|   | `command_string=command` `,` |
|   | `strip_prompt=False,` |
|   | `strip_command=False` |
|   | `)` |
|   | `if "Delete filename" in output:` `# if the returned output contains "Delete filename", send "Enter" (change line)` |
|   | `output += net_connect.send_command_timing` `(` |
|   | `command_string="\n",` |
|   | `strip_prompt=False,` |
|   | `strip_command=False` |
|   | `)` |
|   | `if "confirm" in output:` `# if the returned output contains "confirm", send "y"` |
|   | `output += net_connect.send_command_timing(` |
|   | `command_string="y",` |
|   | `strip_prompt=False,` |
|   | `strip_command=False` |
|   | `)` |
|   | `net_connect.disconnect` `# Disconnect from SSH session` |
|   | `print(output)` `# Print content of output` |
|   | `else` `: # Both conditions failed to satisfy, exit the script` |
|   | `("No IOS found.")` |
|   | `exit()` |
|   | `net_connect.disconnect` `# Disconnect from SSH session` |
|   | `^G Get Help  ^O Write Out    ^W Where Is   ^K Cut Text    ^J Justify   ^C Cur Pos` |
|   | `^X Exit      ^R Read File    ^\ Replace    ^U Paste Text  ^T To Spell  ^_ Go To Line` |
| **5** | 现在，导航回您的`ubuntu20s1` (192.168.183.132) Python 服务器并 ping `LAB-R1` (192.168.183.10)以确认设备的连接性。您仍然在使用 SSH 协议，`netmiko`实验室仍然是 SSH 实验室的一部分，所以您应该在`/home/pynetauto/ssh_labs`目录中工作。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `ping 192.168.183.10 -c 3` |
|   | `PING 192.168.183.10 (192.168.183.10) 56(84) bytes of data.` |
|   | `64 bytes from 192.168.183.10: icmp_seq=1 ttl=255 time=7.37 ms` |
|   | `64 bytes from 192.168.183.10: icmp_seq=2 ttl=255 time=6.73 ms` |
|   | `64 bytes from 192.168.183.10: icmp_seq=3 ttl=255 time=12.9 ms` |
|   | `--- 192.168.183.10 ping statistics ---` |
|   | `3 packets transmitted, 3 received, 0% packet loss, time 2004ms` |
|   | `rtt min/avg/max/mdev = 6.734/9.016/12.948/2.791 ms` |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$ ls netmiko*` |
|   | `netmiko_delete_me.py` |
| **6** | 现在使用`python netmiko_delete_me.py`运行脚本。当脚本返回输出时，选择`.bin`文件，并按 Enter 键将其从`LAB-R1`的闪存中删除。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `python netmiko_delete_me.py` |
|   | `IP Address : 192.168.183.10` |
|   | `Enter username : pynetauto` |
|   | `SSH password :` |
|   | `Directory of flash0:/` |
|   | `4  drw-           0  Jan 12 2021 08:09:26 +00:00  old_files` |
|   | `5  -rw-           0  Jan 12 2021 08:11:16 +00:00  Delete_me_1.bin` |
|   | `6  -rw-           0  Jan 12 2021 08:11:24 +00:00  Don't_delete_me_1.txt` |
|   | `2142720000 bytes total (2142707712 bytes free)` |
|   | `!!! WARNING - You cannot reverse this step.` |
|   | `If you can see 'Delete_me.bin' file, select it and press Enter.` |
|   | `*Old IOS (bin) file to delete : Delete_me_1.bin` |
|   | `del flash:/Delete_me_1.bin` |
|   | `Delete filename [Delete_me_1.bin]?` |
|   | `Delete flash0:/Delete_me_1.bin? [confirm]y` |
|   | `LAB-R1#` |
| **7** | 现在打开`LAB-R1`的控制台，检查文件`Delete_me_1.bin`是否已经从`flash`的`:`中删除。如果您在这里只看到一个文件和一个文件夹，那么您已经完成了第一项任务。转到步骤 9，重新运行相同的脚本。 |
|   | `LAB-R1#` `dir` |
|   | `Directory of flash0:/` |
|   | `4  drw-           0  Jan 12 2021 08:09:26 +00:00  old_files` |
|   | `6  -rw-           0  Jan 12 2021 08:11:24 +00:00  Don't_delete_me_1.txt` |
|   | `2142720000 bytes total (2142707712 bytes free)` |
| **8** | 第二次运行相同的脚本；这一次，由于`flash` `:`下没有`.bin`文件，所以会提示不同的信息，要求您选择一个目录来搜索`.bin`文件。当你剪切并粘贴目录名时，它会运行脚本来寻找难以捉摸的`.bin`文件并显示结果。当脚本找到`.bin`文件时，继续删除`Delete_me_2.bin`文件。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `python netmiko_delete_me.py` |
|   | `IP Address :` `192.168.183.10` |
|   | `Enter username :` `pynetauto` |
|   | `SSH password : ********` |
|   | `Directory of flash0:/` |
|   | `4  drw-           0  Jan 12 2021 08:09:26 +00:00  old_files` |
|   | `6  -rw-           0  Jan 12 2021 08:11:24 +00:00  Don't_delete_me_1.txt` |
|   | `2142720000 bytes total (2142707712 bytes free)` |
|   | `!!! WARNING - You cannot reverse this step.` |
|   | `No IOS file under 'flash:/', select the directory to view.` |
|   | `*Enter Directory name :``old_files`T2】 |
|   | `Directory of flash0:/old_files/` |
|   | `7  -rw-           0  Jan 12 2021 08:11:32 +00:00  Delete_me_2.bin` |
|   | `8  -rw-           0  Jan 12 2021 08:11:40 +00:00  Don't_delete_me_2.txt` |
|   | `2142720000 bytes total (2142707712 bytes free)` |
|   | `If you see old IOS (bin) in the directory. Select it and press Enter.` |
|   | `*Old IOS (bin) file to delete :``Delete_me_2.bin`T2】 |
|   | `del flash:/old_files/Delete_me_2.bin` |
|   | `Delete filename [/old_files/Delete_me_2.bin]?` |
|   | `Delete flash0:/old_files/Delete_me_2.bin? [confirm]y` |
|   | `LAB-R1#` |
| **9** | 返回到`LAB-R1`并运行`dir flash:old_files/`命令来查看目录内容。如果您在目录下只看到一个文件，则您已经完成了本实验的第二项任务。 |
|   | `LAB-R1#` `dir flash:/old_files/` |
|   | `Directory of flash0:/old_files/` |
|   | `8  -rw-           0  Jan 12 2021 08:11:40 +00:00  Don't_delete_me_2.txt` |
|   | `2142720000 bytes total (2142707712 bytes free)` |
| **10** | 现在删除工作目录和文件，因为我们已经完成了本实验。 |
|   | `LAB-R1#` `delete /recursive /force flash:old_files` |
|   | `LAB-R1#delete flash:` `Don't_delete_me_1.txt` |
|   | `Delete filename [Don't_delete_me_1.txt]?` |
|   | `Delete flash0:/Don't_delete_me_1.txt? [confirm]` |
|   | `LAB-R1#` `dir` |
|   | `Directory of flash0:/` |
|   | `No files in directory` |
|   | `2142720000 bytes total (2142711808 bytes free)` |

您现在已经学习了如何编写 Python 代码来删除和搜索路由器的闪存文件。你可以把你的任务变成 Python 脚本，这是 Python 网络自动化的开始。接下来，我们将开发一个端口扫描工具来检查开放的端口，并将其应用到我们的工作中。

## netmiko 实验 2:使用套接字模块开发一个简单的端口扫描器，然后开发一个 nemiko Disable Telnet 脚本

在本实验中，您将学习如何使用套接字模块开发一个简单的端口扫描工具，然后在您的`netmiko`实验 2 脚本(`netmiko_disable_telnet.py`)中使用该扫描工具来检查打开的端口 23，并使用`netmiko`库禁用这些端口。早些时候，我们在`line vty 0 15`下配置了`transport input all`，允许 Telnet 和 SSH 连接用于所有设备管理。要禁用 Telnet，您必须用`transport input ssh`命令重新配置虚拟电传(`vty`)线路。本实验需要打开所有路由器和交换机的电源。

在本实验结束时，您将能够扫描网络设备以查找任何开放的端口；您将检查端口 23(或 22 或任何其他感兴趣的端口)是否在使用中。通过禁用所有设备上的 Telnet 端口 23 来保护您的设备，并且只允许 SSH 连接用于设备管理。再次强调，尝试将注意力集中在概念上，并开发实现本实验目标所需的工具。见图 [14-5](#Fig5) 。

![../images/492721_1_En_14_Chapter/492721_1_En_14_Fig5_HTML.jpg](../images/492721_1_En_14_Chapter/492721_1_En_14_Fig5_HTML.jpg)

图 14-5。

SSH netmiko 实验 2，使用中的设备

让我们首先开发一个迷你扫描工具，并验证我们的路由器和交换机上的开放端口。然后将扫描工具合并到我们的脚本中，`netmiko_disable_telnet.py`。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 首先，您必须使用`socket.socket(family, type)`创建一个 socket 对象，将 family 设置为`socket.AF_INET`，type 设置为`socket.SOCK_STREAM`。根据 Python 套接字编程，`socket.AF_INET`为 IPv4 指定 IP 地址族，`socket.SOCK_STREAM`为 TCP 指定套接字类型。要检查端口状态，使用`socket.connect_ex(dest)`，将套接字作为套接字对象，将`dest`作为包含 IP 地址和所需端口号的元组。如果端口是打开的，`socket.connect_ex()`返回 0，但是如果端口是关闭的，会根据被扫描的端口返回不同的数字。在端口扫描结束时，您必须使用`socket.close()`关闭套接字。 |
|   | 我们将要使用的简单端口扫描仪模板如下所示，它允许我们只扫描单个端口的单个设备。如果您将它放到您的 Linux 服务器上，创建一个名为`scan_open_port.py`的新文件，并运行代码，您将能够检查单个目的地的端口状态。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `nano scan_open_port.py` |
|   | `GNU nano 4.8` `/home/pynetauto/ssh_labs/scan_open_port.py` |
|   | `import  socket` `# Import socket module` |
|   | `sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)` `# Create a socket object` |
|   | `dest = ("192.168.183.10", 22)` `# IP and Port to scan` |
|   | `port_open = sock.connect_ex(dest)` `# Create socket connect object` |
|   | `# open returns int 0, closed returns an integer based on port number` |
|   | `if port_open == 0:` `# If port is opened, it returns 0` |
|   | `print(port_open)` `# print result = 0` |
|   | `print("On ", {dest[0]}, "port is open.")` `# Informational` |
|   | `else:` |
|   | `print(port_open)` `# print result, an integer other than 0` |
|   | `print("On ", {dest[0]}, "port is closed.")` `# Informational` |
|   | `sock.close()` `# close socket object` |
|   | `^G Get Help  ^O Write Out   ^W Where Is   ^K Cut Text     ^J Justify     ^C Cur Pos` |
|   | `^X Exit      ^R Read File   ^\ Replace    ^U Paste Text   ^T To Spell    ^_ Go To Line` |
|   | 当您在实验室的`LAB-R1` (192.168.183.10)路由器上运行该脚本时，结果将如下所示: |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `python3 scan_open_port.py` |
|   | `0` |
|   | `On  {'192.168.183.10'} port is open.` |
|   | 当您将端口 22 (SSH)更改为 80 (HTTP)并再次扫描端口时，它会返回 111 和“端口已关闭”消息。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `python3 scan_open_port.py` |
|   | `111` |
|   | `On  {'192.168.183.10'} port is closed.` |
| **2** | 前面的脚本工作得很好，但不能很好地适应我们的用例，我们必须修改脚本，使它在我们的环境中更具可伸缩性和通用性。使用前面的脚本作为我们的模板，让我们重写脚本来一次扫描多个设备的端口。我的脚本看起来如下，但是没有正确或错误的编码方式，所以你也可以通过修改来增加你的天赋。由于这个脚本扫描多个端口，我将其命名为`scan_open_ports.py`(末尾有复数“s”)。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `nano scan_open_ports.py` |
|   | `GNU nano 4.8` `/home/pynetauto/ssh_labs/scan_open_ports.py` |
|   | `import  socket` `# Import socket module` |
|   | `ip_addresses = ["192.168.183.10", "192.168.183.20", "192.168.183.101", "192.168.183.102", "192.168.183.133"]` `# IP address list` |
|   | `for ip in ip_addresses:` `# get ip from the list, ip_addresses` |
|   | `for port in range (22, 24):` `# port range, ports 22-23, always n-1 for the last digit` |
|   | `dest = (ip, port)` `# combine both ip and port number into one object as socket method takes 1 attribute` |
|   | `try` `: # Use try except method` |
|   | `with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock: # s as a socket object` |
|   | `sock.settimeout(3)` `#` |
|   | `connection = sock.connect(dest)` `# connect to destination on specified port` |
|   | `print(f"On {ip}, port {port} is open!")` `# Informational` |
|   | `except` `:` |
|   | `print(f"On {ip}, port {port} is closed.")` `# Informational` |
|   | `^G Get Help  ^O Write Out    ^W Where Is   ^K Cut Text    ^J Justify   ^C Cur Pos` |
|   | `^X Exit      ^R Read File    ^\ Replace    ^U Paste Text  ^T To Spell  ^_ Go To Line` |
|   | 如图所示完成脚本后，运行脚本，如果您在网络设备上同时打开了 Telnet (22)和 SSH (23 ),结果应该类似于以下内容。您也可以为其他端口扫描任务指定不同的端口范围。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `python3 scan_open_ports.py` |
|   | `On 192.168.183.10, port 22 is open!` |
|   | `On 192.168.183.10, port 23 is open!` |
|   | `On 192.168.183.20, port 22 is open!` |
|   | `On 192.168.183.20, port 23 is open!` |
|   | `On 192.168.183.101, port 22 is open!` |
|   | `On 192.168.183.101, port 23 is open!` |
|   | `On 192.168.183.102, port 22 is open!` |
|   | `On 192.168.183.102, port 23 is open!` |
|   | `On 192.168.183.133, port 22 is open!` |
|   | `On 192.168.183.133, port 23 is open!` |
| **3** | 在两个步骤中，您已经开发了一个 Python 端口扫描器，可以用于您的工作。 |

![../images/492721_1_En_14_Chapter/492721_1_En_14_Fige_HTML.jpg](../images/492721_1_En_14_Chapter/492721_1_En_14_Fige_HTML.jpg) Warning!

注意在哪里以及如何使用这种工具；您不希望在工作场所或客户的网站上违反公司的安全政策。如果您的工作不建议在没有适当的更改控制和批准的情况下执行端口扫描任务，请不要运行端口扫描程序。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
|   | 好了，现在你有了另一个工具；基于前面的脚本，让我们继续编写一些代码来检查端口，如果我们的设备上启用了 Telnet，让 Python 应用程序 SSH 进入并修改设置；然后保存更改后的配置。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `nano netmiko_disable_telnet.py` |
|   | `GNU nano 4.8                    /` `home/pynetauto/ssh_labs/netmiko_disable_telnet.py` |
|   | `#!/usr/bin/env python3` |
|   | `import re` |
|   | `from netmiko import ConnectHandler` |
|   | `from getpass import getpass` |
|   | `import time` |
|   | `import  socket` |
|   | `def get_credentials():` `# Enhanced User ID and password collection tool` |
|   | `#Prompts for, and returns a username and password` |
|   | `global username` `# Make username as a global variable to be used throughout this script` |
|   | `global password` `# Make password as a global variable to be used throughout this script` |
|   | `username = input("Enter your username : ")` |
|   | `password = None` |
|   | `while not password:` |
|   | `password = getpass()` |
|   | `password_verify = getpass("Retype your password : ")` `# Verify the password is correctly typed` |
|   | `if password != password_verify:` |
|   | `print("Passwords do not match. Please try again.")` |
|   | `password = None` |
|   | `return username, password` |
|   | `get_credentials()` `# Run this function first to collect the username and password` |
|   | `device1 = {` `# Netmiko dictionary for device1` |
|   | `'device_type': 'cisco_ios',` |
|   | `'ip': '192.168.183.10',` |
|   | `'username': username` `,` |
|   | `'password': password,` |
|   | `}` |
|   | `device2 = {` `# Netmiko dictionary for device2` |
|   | `'device_type': 'cisco_ios',` |
|   | `'ip': '192.168.183.20',` |
|   | `'username': username,` |
|   | `'password': password,` |
|   | `}` |
|   | `device3 = {` `# Netmiko dictionary for device3` |
|   | `'device_type': 'cisco_ios',` |
|   | `'ip': '192.168.183.101',` |
|   | `'username': username,` |
|   | `'password': password,` |
|   | `}` |
|   | `device4 = {` `# Netmiko dictionary for device4` |
|   | `'device_type': 'cisco_ios',` |
|   | `'ip': '192.168.183.102',` |
|   | `'username': username,` |
|   | `'password': password,` |
|   | `}` |
|   | `device5 = {` `# Netmiko dictionary for device5` |
|   | `'device_type': 'cisco_ios',` |
|   | `'ip': '192.168.183.133',` |
|   | `'username': username,` |
|   | `'password': password,` |
|   | `}` |
|   | `devices = [device1, device2, device3, device4, device5]` `# List of netmiko devices` |
|   | `for device in devices:` `# Loop through   devices` |
|   | `ip = device.get("ip", "")` `# get value of the key "ip"` |
|   | `for port in range (23, 24):` `# only port 23` |
|   | `dest = (ip, port)` `# Combine ip and port number to form dest object` |
|   | `try:` |
|   | `with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:` `# port scanner tool` |
|   | `sock.settimeout(3)` `# add 3 seconds pause to socket application` |
|   | `connection = sock.connect(dest)` `#` |
|   | `print(f"On {ip}, port {port} is open!")` `# Informational` |
|   | `net_connect = ConnectHandler(**device)` `# create a netmiko ConnectHandler object` |
|   | `show_clock = net_connect.send_command("show clock\n")` `# Send "show clock" command` |
|   | `print(show_clock)` `# Display time` |
|   | `config_commands = ['line vty 0 15', 'transport input ssh']` `# netmiko config_commands` |
|   | `net_connect.send_config_set(config_commands)` `# send netmiko send_config_set` |
|   | `output = net_connect.send_command("show run &#124; b line vty")` `# send a show command to``check vty 0 15` |
|   | `print()` `# Informational` |
|   | `print('-' * 80)` `# Displayed information separator line` |
|   | `print(output)` `# Informational` |
|   | `print('-' * 80)` `# Displayed information separator line` |
|   | `print()` `# Informational` |
|   | `net_connect.disconnect()` `# close netmiko connection` |
|   | `except:` |
|   | `print(f"On {ip}, port {port} is closed.")` |
|   | `# #``This is for saving the configuration after a successful configuration change`T2】 |
|   | `# net_connect = ConnectHandler(**device) # Commented out for third run` |
|   | `# write_mem = net_connect.send_command("write mem\n") # Commented out for third run` |
|   | `# print()` |
|   | `# print('-' * 80)` |
|   | `# print(write_mem) # Commented out for third run` |
|   | `# print('-' * 80)` |
|   | `# print()` |
|   | `# net_connect.disconnect()` |
|   | `^G Get Help  ^O Write Out    ^W Where Is   ^K Cut Text    ^J Justify   ^C Cur Pos` |
|   | `^X Exit      ^R Read File    ^\ Replace    ^U Paste Text  ^T To Spell  ^_ Go To Line` |
| **4** | 运行`netmiko_disable_telnet.py`脚本并更新配置以禁用 Telnet 登录。 |

![../images/492721_1_En_14_Chapter/492721_1_En_14_Figf_HTML.jpg](../images/492721_1_En_14_Chapter/492721_1_En_14_Figf_HTML.jpg) Warning!

如果您在生产中使用类似的脚本，请确保您的主要远程控制台管理协议是 SSH。您遵循了公司的策略，使用自动脚本删除 Telnet 服务。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `python netmiko_disable_telnet.py` |
|   | `Enter your username : pynetauto` |
|   | `Password: ********` |
|   | `Retype your password : ********` |
|   | `On 192.168.183.10, port 23 is open!` |
|   | `*09:48:17.800 UTC Tue Jan 12 2021` |
|   | `--------------------------------------------------------------------------------` |
|   | `line vty 0 4` |
|   | `logging synchronous` |
|   | `login local` |
|   | `transport input ssh` |
|   | `line vty 5 15` |
|   | `logging synchronous` |
|   | `login local` |
|   | `transport input ssh` |
|   | `!` |
|   | `no scheduler allocate` |
|   | `ntp server 192.168.183.130` |
|   | `!` |
|   | `end` |
|   | `--------------------------------------------------------------------------------` |
|   | `[... omitted for brevity]` |
|   | `--------------------------------------------------------------------------------` |
|   | `On 192.168.183.133, port 23 is open!` |
|   | `*01:40:37.823 UTC Fri Mar 1 2002` |
|   | `--------------------------------------------------------------------------------` |
|   | `line vty 0 4` |
|   | `exec-timeout 0 0` |
|   | `logging synchronous` |
|   | `login local` |
|   | `transport input ssh` |
|   | `line vty 5 15` |
|   | `exec-timeout 0 0` |
|   | `logging synchronous` |
|   | `login local` |
|   | `transport input ssh` |
|   | `!` |
|   | `!` |
|   | `end` |
|   | `--------------------------------------------------------------------------------` |
| **5** | 第二次运行脚本进行验证。现在不允许对设备进行远程登录，我们应该会收到如下关闭消息: |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `python3 netmiko_disable_telnet.py` |
|   | `Enter your username : pynetauto` |
|   | `Password:********` |
|   | `Retype your password : ********` |
|   | `On 192.168.183.10, port 23 is closed.` |
|   | `On 192.168.183.20, port 23 is closed.` |
|   | `On 192.168.183.101, port 23 is closed.` |
|   | `On 192.168.183.102, port 23 is closed.` |
|   | `On 192.168.183.133, port 23 is closed.` |
| **6** | 一旦前面的任务成功完成，从相同的代码中删除`except:`行下的`#`(取消注释)。然后重新运行 Python 代码来保存所有五个设备的配置。这里，我复制了原始脚本，并取消了脚本末尾的注释行: |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `cp netmiko_disable_telnet.py netmiko_disable_telnet_uncommented.py` |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `nano netmiko_disable_telnet_uncommented.py` |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `python netmiko_disable_telnet_uncommented.py` |
|   | 取消注释后，最后几行代码应该如下所示: |
|   | `except:` |
|   | `print(f"On {ip}, port {port} is closed.")` |
|   | `# This is for saving the configuration after a successful configuration change.` |
|   | `net_connect = ConnectHandler(**device)` |
|   | `write_mem = net_connect.send_command(“write mem\n”)` |
|   | `print()` |
|   | `print('-' * 80)` |
|   | `print(write_mem)` |
|   | `print('-' * 80)` |
|   | `print()` |
|   | `net_connect.disconnect()` |
| **7** | 再次运行脚本以保存当前运行的配置。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `python netmiko_disable_telnet_uncommented.py` |
|   | `Enter your username : pynetauto` |
|   | `Password:` |
|   | `Retype your password :` |
|   | `On 192.168.183.10, port 23 is closed.` |
|   | `--------------------------------------------------------------------------------` |
|   | `Building configuration...` |
|   | `[OK]` |
|   | `--------------------------------------------------------------------------------` |
|   | `[... omitted for brevity]` |
|   | `--------------------------------------------------------------------------------` |
|   | `On 192.168.183.133, port 23 is closed.` |
|   | `--------------------------------------------------------------------------------` |
|   | `Building configuration...` |
|   | `[OK]` |
|   | `--------------------------------------------------------------------------------` |

您刚刚开发了一个迷你端口扫描工具，然后使用它作为开发 SSH ( `netmiko`)工具的模板来关闭所有实验室设备上的 Telnet 端口。现在，您的实验室拓扑更加安全，您只能使用 SSH 连接访问路由器和交换机进行设备管理。

## netmiko 实验 3:配置比较

在这个`netmiko`实验中，您将使用`difflib`库开发一个快速设备配置比较工具。该脚本将借用上一个实验的部分脚本，并通过检查 SSH 连接端口 22 的开放端口状态，将端口扫描器用作预检查通信验证工具。本实验将并排比较两台相似设备的运行配置。如果你做过一段时间的网络工程师，你应该熟悉 Notepad++中的比较模块和类似的工具。您必须手动登录到每个设备，运行`show`命令，将配置作为两个独立的日志或两个文本文件删除，然后在 Notepad++上打开它们，并运行比较工具。一旦进行了比较，您必须手动找出差异，将缺失的配置应用到第二个设备。这里我们正在开发一个工具，用于通过 SSH 连接访问遗留设备；然而，对于支持 REST API 的网络设备，同样的比较可以用于通过 API 调用收集运行配置。相同的脚本可以应用于收集的数据集。另外，假设您想进一步使用这个脚本。在这种情况下，我们可以利用强大的数据模块，如`pandas`和`xlsxwriter`来读取作为数据帧的行，并只提取两种配置之间的差异，这样许多手动任务就可以自动化。

对于本实验，您需要访问`Lab-R1` (192.168.183.10)和`lab-r2` (192.168.183.20)。此外，交换机和路由器的传输设备都需要通电。您将使用 WinSCP 来访问在`ubuntu20s1` Python 服务器上收集的数据。所以如果你能提前下载并安装 WinSCP 或 FileZilla 进行文件检索，你就做好了充分的准备。见图 [14-6](#Fig6) 。

![../images/492721_1_En_14_Chapter/492721_1_En_14_Fig6_HTML.jpg](../images/492721_1_En_14_Chapter/492721_1_En_14_Fig6_HTML.jpg)

图 14-6。

SSH netmiko 实验 3，使用中的设备

成功完成实验后，您将在脚本的运行目录中创建三个文件:两个包含运行配置的文本文件和一个包含比较结果的 XML 文件。按照以下步骤完成本实验:

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 首先，复制上一个实验中的端口扫描工具，并进行必要的修改，以便 SSH 端口 22 的打开状态可以被该工具探测到。进行更改后，该脚本应类似于以下内容: |
|   | `for device in devices:` `# Loop through netmiko devices list` |
|   | `ip = device.get("ip", "")` `# Get value of the key "ip" from device dictionary` |
|   | `for port in range (22, 23):` `# For only port 22` |
|   | `dest = (ip, port)` `# Combine ip and port number to form dest object` |
|   | `try:` |
|   | `with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:` |
|   | `sock.settimeout(3)` |
|   | `connection = sock.connect(dest)` `# Send socket request` |
|   | `print (f"on {ip}, port {port} is open!")``# Informational, pass object using format`T2】 |
|   | `except:` |
|   | `print (f"On {ip}, port {port} is closed. Check the connectivity to {ip} again.")` |
|   | `exit()` |
| **2** | 现在这里是`netmiko_compare_config.py`脚本的完整源代码。这个应用程序使用`getpass`模块获取密码，使用时间模块添加暂停，使用套接字模块探测开放端口，`difflib`比较配置文件，当然，`netmiko`的`ConnectHandler`通过 SSH 协议连接到两个设备。尝试在键盘上键入代码，感受一下编写 Python 代码的感觉。不可避免的是，当你在编码的时候，你不得不在你的屏幕和键盘前呆上几个小时。有关进一步的解释，请参考代码中嵌入的解释。 |
|   | `GNU nano 4.8` `/home/pynetauto/ssh_labs/netmiko_compare_config.py` |
|   | `#!/usr/bin/env python3` |
|   | `#---------------------------------------------------# Import required modules` |
|   | `import time` |
|   | `import socket` |
|   | `import difflib` |
|   | `from getpass import getpass` |
|   | `from netmiko import ConnectHandler` |
|   | `#---------------------------------------------------# Borrowed from previous labs` |
|   | `# Functions to collect credentials and IP addresses of devices` |
|   | `def get_input(prompt=''):` |
|   | `try:` |
|   | `line = input(prompt)` |
|   | `except NameError:` |
|   | `line = input(prompt)` |
|   | `return line` |
|   | `def get_credentials():` |
|   | `#Prompts for, and returns a username and password` |
|   | `username= get_input("Enter Network Admin ID     : ")` |
|   | `password = None` |
|   | `while not password:` |
|   | `password = getpass("Enter Network Admin PWD    : ")` |
|   | `password_verify = getpass("Confirm Network Admin PWD   : ")` |
|   | `if password != password_verify:` |
|   | `print("Passwords do not match. Please try again.")` |
|   | `password = None` |
|   | `return username, password` |
|   | `# For IP addresses of comparing devices` |
|   | `def get_device_ip():` |
|   | `#Prompts for, and returns a first_ip and second_ip` |
|   | `first_ip = get_input("Enter primary device IP      : ")` |
|   | `while not first_ip:` |
|   | `first_ip = get_input("* Enter primary device IP     : ")` |
|   | `second_ip = get_input("Enter secondary device IP    : ")` |
|   | `while not second_ip:` |
|   | `second_ip = get_input("* Enter secondary device IP : ")` |
|   | `return first_ip, second_ip` |
|   | `#--------------------------------------------------------------------------------` |
|   | `# Run the functions to collect credentials and ip addresses` |
|   | `print("-"*40)` |
|   | `username, password = get_credentials()` |
|   | `first_ip, second_ip = get_device_ip()` |
|   | `print("-"*40)` |
|   | `#--------------------------------------------------------------------------------` |
|   | `# Netmiko device dictionaries` |
|   | `device1 = {` `# Netmiko dictionary for device1` |
|   | `'device_type': 'cisco_ios',` |
|   | `'ip': first_ip,` |
|   | `'username': username,` |
|   | `'password': password,` |
|   | `}` |
|   | `device2 = {` `# Netmiko dictionary for device2` |
|   | `'device_type': 'cisco_ios',` |
|   | `'ip': second_ip` `,` |
|   | `'username': username,` |
|   | `'password': password,` |
|   | `}` |
|   | `devices = [device1, device2]` |
|   | `#--------------------------------------------------------------------------------` |
|   | `# Re-use port scanner as a pre-check tool for reachability verification tools.` |
|   | `# If an IP is not reachable, the application will exit due to a communication problem.` |
|   | `for device in devices:` `# Loop through   devices` |
|   | `ip = device.get("ip", "")` `# get value of the key "ip"` |
|   | `for port in range (22, 23):` `# only port 22` |
|   | `dest = (ip, port)` `# Combine ip and port number to form dest object` |
|   | `try:` |
|   | `with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:` |
|   | `sock.settimeout(3)` |
|   | `connection = sock.connect(dest)` |
|   | `print(f"on {ip}, port {port} is open!")` |
|   | `except:` |
|   | `print(f"On {ip}, port {port} is closed. Check the connectivity to {ip} again.")` |
|   | `exit()` |
|   | `# Prompt the user to make a decision to run the tool` |
|   | `response = input(f"Make a comparison of {first_ip} and {second_ip} now? [Yes/No]")` |
|   | `response = response.lower()` |
|   | `if response == 'yes':` |
|   | `print(f"* Now making a comparison : {first_ip} vs {second_ip}")` `# Informational` |
|   | `for device in devices:` `# Loop through   devices` |
|   | `ip = device.get("ip", "")` `# Get value of the key "ip"` |
|   | `try:` |
|   | `net_connect = ConnectHandler(**device)` `# Create netmiko connection object` |
|   | `net_connect.send_command("terminal length 0\n")` |
|   | `output = net_connect.send_command("show running-config\n")` `# Run show running config` |
|   | `show_run_file = open(f"{ip}_show_run.txt", "w+")` `# Create a file` |
|   | `show_run_file.write(output)` `# Write output to file` |
|   | `show_run_file.close()` `# Close-out the file` |
|   | `time.sleep(1)` |
|   | `net_connect.disconnect()` `# Disconnect SSH connection` |
|   | `except KeyboardInterrupt:` `# Keyboard Interrupt` |
|   | `print("-"*80)` |
|   | `else:` |
|   | `print("You have selected No. Exiting the application.")` `# Informational` |
|   | `exit()` |
|   | `#--------------------------------------------------------------------------------` |
|   | `# Compare the two show running config files and display it in html file format.` `# Informational` |
|   | `# Prepare for comparison of the text files` |
|   | `device1_run = f"./{first_ip}_show_run.txt"` `# Create device1_run object, ./ is present working folder` |
|   | `device2_run = f"./{second_ip}_show_run.txt"` `# Create device2_run object` |
|   | `device1_run_lines = open(device1_run).readlines()` `# Convert into strings first for comparison` |
|   | `time.sleep(1)` |
|   | `device2_run_lines = open(device2_run).readlines()` `# Convert into strings first for comparison` |
|   | `time.sleep(1)` |
|   | `# Four arguments required in HtmlDiff function` |
|   | `difference = difflib.HtmlDiff(wrapcolumn=60).make_file(device1_run_lines, device2_run_lines, device1_run, device2_run)` |
|   | `difference_report = open(first_ip + "_vs_" + second_ip + "_compared.html", "w")` `# Create html file to write the difference` |
|   | `difference_report.write(difference)` `# Writes the differences to the difference_report` |
|   | `difference_report.close()` |
|   | `print("** Device configuration comparison completed. Please Check the html file to check the differences.")` |
|   | `print("-"*80)` |
|   | `time.sleep(1)` |
|   | `^G Get Help  ^O Write Out    ^W Where Is   ^K Cut Text    ^J Justify   ^C Cur Pos` |
|   | `^X Exit      ^R Read File    ^\ Replace    ^U Paste Text  ^T To Spell  ^_ Go To Line` |
| **3** | 写完前面的脚本后，使用 Python 命令在`ssh_labs`目录下运行它。运行这个交互式应用程序后，您应该在 Linux Python 服务器的当前工作目录中自动创建了三个文件(`pwd`)。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `python netmiko_compare_config.py` |
|   | `----------------------------------------` |
|   | `Enter Network Admin ID     : pynetauto` |
|   | `Enter Network Admin PWD    :********` |
|   | `Confirm Network Admin PWD   : ********` |
|   | `Enter primary device IP       : 192.168.183.10` |
|   | `Enter secondary device IP    : 192.168.183.20` |
|   | `----------------------------------------` |
|   | `on 192.168.183.10, port 22 is open!` |
|   | `on 192.168.183.20, port 22 is open!` |
|   | `Make a comparison of 192.168.183.10 and 192.168.183.20 now? [Yes/No]yes` |
|   | `* Now making a comparison : 192.168.183.10 vs 192.168.183.20` |
|   | `** Device configuration comparison completed. Please Check the html file to check the differences.` |
|   | - |
|   | 如果您遇到错误或问题，请从我的 GitHub 库下载源代码，并仔细重新检查您的代码和设置。 |
|   | 源代码下载网址: [`https://github.com/pynetauto/apress_pynetauto`](https://github.com/pynetauto/apress_pynetauto) |
|   | 在 Python 网络自动化服务器上运行`ls`命令，您应该会在当前工作目录下找到这三个文件。 |
|   | `pynetauto@ubuntu20s1:~/ssh_labs$` `ls -lh 192.168*` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto 3.6K Jan 12 21:45 192.168.183.10_show_run.txt` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto  56K Jan 12 21:46 192.168.183.10_vs_192.168.183.20_compared.html` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto 3.7K Jan 12 21:46 192.168.183.20_show_run.txt` |
| **4** | 现在，使用 WinSCP 或 FileZilla，使用您的凭证登录到 Ubuntu Python automation 服务器，并将文件移动到您的 Windows 主机。如果您尚未安装该软件，请在登录前在此安装。我在端口 22 上使用 SCP 协议。 |
|   | URL: [`https://winscp.net/eng/download.php`](https://winscp.net/eng/download.php) |
|   | Figure [14-7](#Fig7) shows a WinSCP example with an SCP connection (port 22) to the server. Locate the three files under `/home/pynetauto/ssh_labs/` and drag and drop them to your Windows host PC folder.![../images/492721_1_En_14_Chapter/492721_1_En_14_Fig7_HTML.jpg](../images/492721_1_En_14_Chapter/492721_1_En_14_Fig7_HTML.jpg)图 14-7。Win-SCP，将比较备份和运行配置备份复制到 Windows 主机 |
| **12** | Now, go to the downloaded folder and open the `.html` file to review the script’s result. Now you can compare any similar devices using this interactive tool. This tool can be modified slightly to compare the difference between firewall rules and configuration, and one practical example is to use such a tool to compare Palo Alto firewalls. Using its simple XML API call feature, you can compare the primary to standby configurations. The same script can also be used to compare the configuration before and after a change has been performed on a device. How you want to use the tool is totally up to your imagination. See Figure [14-8](#Fig8).![../images/492721_1_En_14_Chapter/492721_1_En_14_Fig8_HTML.jpg](../images/492721_1_En_14_Chapter/492721_1_En_14_Fig8_HTML.jpg)图 14-8。Web 浏览器，打开 HTML 文件进行审阅 |

大多数新的网络设备都支持 REST/XML API。然而，许多公司投资了数百万美元购买只支持 Telnet、SSH 和 SNMP 的企业网络设备，这些设备多年来仍处于有效的技术支持之下。网络工程师通常在通过 SSH 或 Telnet 连接的黑色命令行控制台前开始他们的生活。现在将您的知识扩展到网络编程。你首先要研究不同网络工程师的行为，理解他们坐在黑暗的 CLI 屏幕前盯着屏幕的决策过程。网络自动化不是让机器人或机器人或软件努力工作。它是关于理解我们作为网络工程师的行为，并看到自动化的重要性以及作为技术人员可以帮助其他人的地方。几乎所有的企业网络设备都支持 SSH，因此能够使用 Python、Python 模块和 SSH 的强大功能来自动化工程师的日常任务在这个过渡时期仍然是一个强有力的工具。在这个新的软件定义网络(SDN)和“一切皆云”的时代，更重要的是了解为我们的托管网络增加更多弹性和稳定性的真正基础，以及 Python 等软件编程如何将我们带到下一个级别。

## 摘要

本章重点介绍了使用两个 SSH 库`paramiko`和`netmiko`的路由器和交换机的 Python 网络自动化。您已经了解了如何开发更小的工具，然后将它们合并到一个更重要的工具中，以创建能够增强您的工作和团队，并最终增强您的公司的工具。您学习了如何通过 SSH 进行配置更改，对 TFTP 服务器进行`running-config`备份，开发一个简单的套接字端口扫描工具，将其应用到您的工作中，并比较两个相似的设备来定位差异。接下来，您将学习如何安排 Python 应用程序在指定的时间运行，并尝试 Python SNMPv3。将向您介绍`cron`和 SNMP 探索实验室，让您更多地了解如何在工作中使用 Python 实现网络自动化。