# 13.Python 网络自动化实验室:基本远程登录

本章专门介绍使用 Python 的`telnetlib`库的 Telnet 实验室。您将学习如何使用一个基本的 Telnet 示例来重复您在键盘上执行的任务，并将其转换为 Python 脚本。尽管 Telnet 是一种不安全的协议，并且最佳实践是使用 SSH 协议进行远程连接，但它现在仍在许多生产环境中使用，这些环境位于一个安全的网络中，只有少数工程师可以访问该环境。在本实验结束时，您将能够使用基本的 Telnet 库执行以下操作:在 Python 解释器会话中与网络设备进行交互，使用使用循环的模板化方法配置单交换机和多交换机 VLAN，执行基本的网络工程师管理任务，例如通过外部文件源添加用户，以及将`running-config`或`startup-configs`备份到本地 Python 服务器目录。在下一章，我们将使用 Python SSH 库来扩展本章所学的思想。

![../images/492721_1_En_13_Chapter/492721_1_En_13_Figa_HTML.jpg](../images/492721_1_En_13_Chapter/492721_1_En_13_Figa_HTML.jpg)

## Python 网络自动化:Telnet 实验室

在本书中，我们投入了大量时间来使实验室体验尽可能接近真实的物理设备实验室，这样您就可以在没有硬件或担心不同连接器类型的情况下获得真实的实验室体验。在主机上的当前实验室设置下，您可以在三种不同的操作系统上编写代码:Windows 10 上的主机、CentOS 8.1 Linux server 和 Ubuntu 20.04 LTS Linux VM server。如果您想添加更多的地方来编写和测试代码，您可以克隆任何 Linux 虚拟机。在第 [2](02.html) 章中，向您介绍了 Windows 操作系统上的 Python 3，然后在第 [4](04.html) 、 [5](05.html) 和 [6](06.html) 章中，您完成了 Linux 命令行界面(CLI)上的大部分练习。公司几乎从不在 Windows 服务器上安装 Python 并在生产环境中使用它。换句话说，绝大多数 Python 应用程序运行在安全加固的 Linux 服务器上。虽然微软已经引入了 Linux 的 Windows 子系统(WSL)的概念，并且它可以在 Windows 上运行 Linux 系统，并且非常容易使用，但是在 Windows 上运行的实际虚拟机是 Linux OS。

目前网络自动化的热潮是为了更少的工程师，他们可以使用应用编程接口(API)做更多的工作，而不用打开 CLI 控制台、Telnet 或 SSH 终端窗口。跨许多较新的网络平台引入 API 支持也大大减少了网络行业中图形用户界面(GUI)的使用。然而，业内人士表示，登录网络设备并管理它们的传统方式将在未来许多年内保持不变。我们仍然使用键盘来编写 Python 代码，并调用代码中使用的 API 库，但除非我们是 API 开发人员，否则我们可能不会完全理解每个 API 的内部工作方式。归根结底，网络自动化是模仿有经验的网络工程师的思维方式。这种产品的一个很好的例子是 Red Hat 的 Ansible，它依赖于无代理的 SSH 连接，而不是 API。从这个意义上来说，API 是对这一点的重新解释，但是是为了不使用键盘和屏幕的机器对机器的交互。在本章中，您将开始编写 Python Telnet 脚本，以便与我们的基本实验拓扑中的网络设备进行交互。尽管使用 API 正在成为管理企业网络设备的新标准，但是在现在和可预见的将来，仍然会有许多设备没有 API 接口，您仍然需要使用 Telnet 或 SSH 连接来远程连接到这些设备。这意味着我们仍然可以在网络自动化中使用 Python，依赖于 Telnet 和 SSH 库。反正写 Python 代码的必备技能不变；只有访问方法和库发生了变化。见图 [13-1](#Fig1) 。

![../images/492721_1_En_13_Chapter/492721_1_En_13_Fig1_HTML.jpg](../images/492721_1_En_13_Chapter/492721_1_En_13_Fig1_HTML.jpg)

图 13-1。

CML lab-基本逻辑拓扑

在高度安全的客户端环境中，您只能从名为 *jump hosts* 的指定服务器管理核心网络和系统设备。跳转主机可以基于 Windows 或 Linux 操作系统。`cmllab-basic` GNS3 拓扑模拟这种环境，您必须在您的主机 PC 上使用 PuTTY SSH 到`ubuntu20s1` (Python 和 jump host)服务器来管理网络中的设备。`centos8s1`服务器提供我们在各种实验室场景中所依赖的 IP 服务。我们将在 Windows Notepad++中编写 Python 脚本，或者通过 SSH 会话在`ubuntu20s1`服务器的文本编辑器中直接输入脚本。对于打字又快又准的人，可以直接把 Python 脚本输入 Ubuntu 服务器。不过，如果你喜欢使用 Windows 记事本或 Notepad++中的脚本，然后剪切并粘贴到 Ubuntu 服务器上，这也是一个可以接受的方法。让我们启动`cmllab-basic`项目中的所有设备，编写一些 Python 代码，看看 Telnet Python 脚本如何与 Cisco 路由器和交换机交互。

## 远程登录实验 1:在 Python 解释器上与 Cisco 设备进行交互式远程登录会话

对于本实验，您需要启动`ubuntu20s1` Linux 服务器(192.168.183.132)】、`LAB-SW1` (192.168.183.101)和`LAB-R1` (192.168.183.10)。运行第一个脚本后，您还将启动 IOS 路由器`R1` (192.168.183.133)，检查 OSPF 邻居关系。如果您使用另一个子网连接到您的 NAT ( `VMnetwork8`)，您的 IP 地址将与本书不同，您必须更换 IP 地址。见图 [13-2](#Fig2) 。

![../images/492721_1_En_13_Chapter/492721_1_En_13_Fig2_HTML.jpg](../images/492721_1_En_13_Chapter/492721_1_En_13_Fig2_HTML.jpg)

图 13-2。

Telnet 实验 1，正在使用的设备

您将编写一个 Telnet 脚本，并运行它从`ubuntu20s1` Python 服务器远程登录到`LAB-R1`路由器，以进行配置更改。在本实验结束时，`running-config`文件中的`LAB-R1`必须具有以下配置:

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| one | 在您的主机 PC 上打开 PuTTY，并通过 SSH 进入`ubuntu20s1` (192.168.183.132)服务器。如果您分配了不同的 IP 地址，请使用您的服务器 IP 地址。如果您忘记了哪个 IP 地址分配给了`ubuntu20s1`服务器，请从 VMware Workstation 打开 Linux 控制台并登录；然后运行`ip address`命令。 |
|   | 现在用你的用户名和密码登录。 |
|   | `login as:` `pynetauto` |
|   | `pynetauto@192.168.183.132's password: *********` |
|   | `Welcome to Ubuntu 20.04.1 LTS (GNU/Linux 5.4.0-47-generic x86_64)` |
|   | `* Documentation: https://help.ubuntu.com` |
|   | `* Management: https://landscape.canonical.com` |
|   | `* Support: https://ubuntu.com/advantage` |
|   | `System information disabled due to load higher than 1.0` |
|   | `327 updates can be installed immediately.` |
|   | `142 of these updates are security updates.` |
|   | `To see these additional updates run: apt list --upgradable` |
|   | `Last login: Fri Jan  8 23:26:01 2021 from 192.168.183.1` |
|   | `pynetauto@ubuntu20s1:~$` |
| Two | 目前，要从`ubuntu20s1`运行 Python，我们必须发出`python3`命令。由于没有安装 Python 2.7，Python 3 是您在这里将要使用的唯一版本，您可以使用一个`alias`命令将`python3`缩短为`python`。按照这里的说明在 Linux 中使用别名: |
|   | `pynetauto@ubuntu20s1:~$` `users` |
|   | `pynetauto` |
|   | `pynetauto@ubuntu20s1:~$` `pwd` |
|   | `/home/pynetauto` |
|   | `pynetauto@ubuntu20s1:~$` `nano /home/pynetauto/.bashrc` |
|   | 打开`/home/user/`目录中的`.bashrc`文件后，在`.bashrc`文件中添加一个新行`alias python=python3`；这与图 [13-1](#Fig1) 类似。添加完一行后，按 Ctrl+X 保存并退出文件。 |
|   | `GNU nano 4.8                                       /home/pynetauto/.bashrc` |
|   | `# alias ADDED by pynetauto` |
|   | `alias python=python3` |
|   | `^G Get Help  ^O Write Out   ^W Where Is   ^K Cut Text     ^J Justify    ^C Cur Pos` |
|   | `^X Exit      ^R Read File   ^\ Replace    ^U Paste Text   ^T To Spell   ^_ Go To Line` |
| three | 添加别名行后，运行`source ~/.bashrc`命令重启用户的`bashrc`。您现在可以使用`python`或`python3`命令在您的`ubuntu20s1`服务器上运行 Python 3.8.2。 |
|   | `pynetauto@ubuntu20s1:~$` `source ~/.bashrc` |
|   | `pynetauto@ubuntu20s1:~$` `python` |
|   | `Python 3.8.2 (default, Jul 16 2020, 14:00:26)` |
|   | `[GCC 9.3.0] on linux` |
|   | `Type "help", "copyright", "credits" or "license" for more information.` |
|   | `>>>` |
| four | 正如我们在 IOS Telnet 实验中所做的那样，转到 [`https://docs.python.org/3/library/telnetlib.html`](https://docs.python.org/3/library/telnetlib.html) 并向下滚动到页面底部。找到一个示例 Telnet 代码。你也可以重用第 [10 章](10.html)8 的`R1` IOS 实验室的旧代码。让我们复制这段代码来制作我们的第一个 Telnet 脚本。该代码将在整个 Telnet 实验中使用，因此这里快速解释了给定 Python 脚本中每一行的作用。由于我们使用的是 Cisco 设备，所以提供了更多关于 Cisco Telnet 会话的解释。 |
|   | **远程登录示例** |
|   | A simple example illustrates the typical use :

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
&#124; `import getpass` &#124; # Getpass module for importing passwords &#124;
&#124; `import telnetlib` &#124; # Import telnet Lib module &#124;
&#124; `HOST = "localhost"` &#124; # for Telnet IP address or host name of the device to be connected &#124;
&#124; `user = input("Enter your remote account: ")` &#124; # User input &#124;
&#124; `password = getpass.getpass()` &#124; # The variable password is defined as getpass.getpass function class &#124;
&#124; `tn = telnetlib.Telnet(HOST)` &#124; # The variable tn is defined as telnetlib. Telnet type category &#124;
&#124; `tn.read_until(b"login: ")` &#124; # "log in:" appears in the telnet window, and Python will wait until "login:" On Cisco devices, the binary information expected to be returned is "user name", which needs to be updated in your script. &#124;
&#124; `tn.write(user.encode('ascii') + b"\n")` &#124; # Encode userID in ASCII and send it to telnet virtual terminal &#124;
&#124; `if password:` &#124; # If you are prompted to enter the password &#124;
&#124; `tn.read_until(b"Password: ")` &#124; # Wait for the password &#124;
&#124; `tn.write(password.encode('ascii') + b"\n")` &#124; # The password encoded in ASCII and sent to telnet virtual terminal &#124;
&#124; `tn.write(b"ls\n")` &#124; #' ls' is the Linux command list. Ls is not used in Cisco devices. Can be deleted or modified. &#124;
&#124; `tn.write(b"exit\n")` &#124; # Send "Exit" command &#124;
&#124; `print(tn.read_all().decode('ascii'))` &#124; # to telnet virtual terminal, read all commands running in this session, decode them in ASCII and print them out on the user screen. &#124;

 |
| five | 创建一个名为`telnet_labs`的目录，更改工作目录，然后使用`touch`命令创建第一个 CML Telnet 脚本。剧本名字叫`add_lo_ospf1.py`。请遵循以下步骤: |
|   | `pynetauto@ubuntu20s1:~$` `pwd` |
|   | `/home/pynetauto` |
|   | `pynetauto@ubuntu20s1:~$` `mkdir telnet_labs` |
|   | `pynetauto@ubuntu20s1:~$` `cd telnet_labs` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$ pwd` |
|   | `/home/pynetauto/telnet_labs` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `touch add_lo_ospf1.py` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `ls` |
|   | `7.2.1_add_lo_ospf1.py` |
| six | 为了加快实验速度，请使用 Linux 服务器上的 nano 文本编辑器。首先，使用`nano add_lo_ospf1.py`打开空白 Python 脚本。然后，使用右键菜单复制并粘贴 Telnet 示例。最后，修改以下源代码中突出显示的部分: |
|   | `GNU nano 4.8` `add_lo_ospf1.py` |
|   | `import getpass` |
|   | `import telnetlib` |
|   | `HOST = "192.168.183.10"` |
|   | `user = input("Enter your username: ")` |
|   | `password = getpass.getpass()` |
|   | `tn = telnetlib.Telnet(HOST)` |
|   | `tn.read_until(b"Username: ")` |
|   | `tn.write(user.encode('ascii') + b"\n")` |
|   | `if password:` |
|   | `tn.read_until(b"Password: ")` |
|   | `tn.write(password.encode('ascii') + b"\n")` |
|   | `tn.write(b"enable\n")` |
|   | `tn.write(b"cisco123\n")` |
|   | `tn.write(b"conf t\n")` |
|   | `tn.write(b"int loopback 0\n")` |
|   | `tn.write(b"ip add 2.2.2.2 255.255.255.255\n")` |
|   | `tn.write(b"int loopback 1\n")` |
|   | `tn.write(b"ip add 4.4.4.4 255.255.255.255\n")` |
|   | `tn.write(b"router ospf 1\n")` |
|   | `tn.write(b"network 0.0.0.0 255.255.255.255 area 0\n")` |
|   | `tn.write(b"end\n")` |
|   | `tn.write(b"exit\n")` |
|   | `print(tn.read_all().decode('ascii'))` |
|   | `^G Get Help  ^O Write Out   ^W Where Is   ^K Cut Text     ^J Justify    ^C Cur Pos` |
|   | `^X Exit      ^R Read File   ^\ Replace    ^U Paste Text   ^T To Spell   ^_ Go To Line` |
| seven | 在从`ubuntu20s1`服务器运行之前的脚本之前，转到`LAB-R1`并启用`debug telnet`来监控来自`LAB-R1`的 Telnet 活动。 |
|   | `LAB-R1#` `debug telnet` |
|   | `Incoming Telnet debugging is on` |
| eight | 在`ubuntu20s1`上，使用`python add_lo_ospf1.py`命令运行脚本。当提示输入用户名和密码时，输入您的路由器用户名和密码。一旦脚本成功运行，您的屏幕应该类似于以下内容: |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `python add_lo_ospf1.py` |
|   | `Enter your username:` `pynetauto` |
|   | `Password: **********` |
|   | `**************************************************************************` |
|   | `* IOSv is strictly limited to use for evaluation, demonstration and IOS  *` |
|   | `* education. IOSv is provided as-is and is not supported by Cisco's      *` |
|   | `* Technical Advisory Center. Any use or disclosure, in whole or in part, *` |
|   | `* of the IOSv Software or Documentation to any third party for any       *` |
|   | `* purposes is expressly prohibited except as otherwise authorized by     *` |
|   | `* Cisco in writing.                                                      *` |
|   | `**************************************************************************` |
|   | `LAB-R1#enable` |
|   | `LAB-R1#cisco123` |
|   | `Translating "cisco123"...domain server (192.168.183.2)` |
|   | `(192.168.183.2)` |
|   | `Translating "cisco123"...domain server (192.168.183.2)` |
|   | `% Bad IP address or host name` |
|   | `% Unknown command or computer name, or unable to find computer address` |
|   | `LAB-R1#conf t` |
|   | `Enter configuration commands, one per line.  End with CNTL/Z.` |
|   | `LAB-R1(config)#int loopback 0` |
|   | `LAB-R1(config-if)#ip add 2.2.2.2 255.255.255.255` |
|   | `LAB-R1(config-if)#int loopback 1` |
|   | `LAB-R1(config-if)#ip add 4.4.4.4 255.255.255.255` |
|   | `LAB-R1(config-if)#router ospf 1` |
|   | `LAB-R1(config-router)#network 0.0.0.0 255.255.255.255 area 0` |
|   | `LAB-R1(config-router)#end` |
|   | `LAB-R1#exit` |
| nine | 转到`LAB-R1`，现在检查控制台。您可以看到刚刚发生的 Telnet 活动。 |
|   | `LAB-R1#` |
|   | `*Jan 11 18:11:08.885: Telnet578: 1 1 251 1` |
|   | `*Jan 11 18:11:08.887: TCP578: Telnet sent WILL ECHO (1)` |
|   | `[...omitted for brevity]` |
|   | `*Jan 11 18:11:09.181: TCP578: Telnet received WONT TTY-TYPE (24)` |
|   | `*Jan 11 18:11:09.183: TCP578: Telnet received WONT WINDOW-SIZE (31)` |
|   | `LAB-R1#` |
|   | `*Jan 11 18:11:11.730: %LINEPROTO-5-UPDOWN: Line protocol on Interface Loopback0, changed state to up` |
|   | `LAB-R1#` |
|   | `*Jan 11 18:11:12.972: %LINEPROTO-5-UPDOWN: Line protocol on Interface Loopback1, changed state to up` |
|   | `*Jan 11 18:11:13.791: %SYS-5-CONFIG_I: Configured from console by pynetauto on vty0 (192.168.183.132)` |
|   | `LAB-R1#` |
| Ten | 从`LAB-R1`控制台，运行`show ip interface brief`命令检查新配置的`Loopback0`和`Loopback1`配置。 |
|   | `LAB-R1#` `show ip interface brief` |
|   | `Interface                  IP-Address      OK? Method Status                Protocol` |
|   | `GigabitEthernet0/0         192.168.183.10  YES manual up                    up` |
|   | `GigabitEthernet0/1         172.168.1.1     YES manual up                    up` |
|   | `GigabitEthernet0/2         unassigned      YES unset  administratively down down` |
|   | `GigabitEthernet0/3         unassigned      YES unset  administratively down down` |
|   | `Loopback0                  2.2.2.2         YES manual up                    up` |
|   | `Loopback1                  4.4.4.4         YES manual up                    up` |
| Eleven | 在 IOS 路由器`R1`上，打开`R1`的电源，观察`R1`和`LAB-R1`路由器之间是否正确形成 OSPF 邻居关系。一旦 OSPF 状态从`LOADING`变为`FULL, Loading Done`，运行`show ip ospf neighbor`命令检查邻居关系。在这个阶段，你应该能够从`R1`ping`LAB-R`1 的`Loopback0`(2.2.2.2)和`Loopback1`(4.4.4.4)接口。 |
|   | `R1#` |
|   | `*Mar  1 00:21:25.807: %OSPF-5-ADJCHG: Process 1, Nbr 4.4.4.4 on FastEthernet0/0 from LOADING to FULL, Loading Done` |
|   | `R1#` `show ip ospf neighbor` |
|   | `Neighbor ID     Pri   State           Dead Time   Address         Interface` |
|   | `4.4.4.4           1   FULL/DR         00:00:39    192.168.183.10  FastEthernet0/0` |
|   | `R1#` `ping 2.2.2.2` |
|   | `Type escape sequence to abort.` |
|   | `Sending 5, 100-byte ICMP Echos to 2.2.2.2, timeout is 2 seconds:` |
|   | `!!!!!` |
|   | `Success rate is 100 percent (5/5), round-trip min/avg/max = 8/11/20 ms` |
|   | `R1#` `ping 4.4.4.4` |
|   | `Type escape sequence to abort.` |
|   | `Sending 5, 100-byte ICMP Echos to 4.4.4.4, timeout is 2 seconds:` |
|   | `!!!!!` |
|   | `Success rate is 100 percent (5/5), round-trip min/avg/max = 8/13/28 ms` |
| Twelve | 在`LAB-R1`时刻，您将观察到 OSPF 状态从`LOADING`变为`FULL, Loading Done`。运行`show ip ospf neighbor`命令检查与`R1`的邻居关系。在此阶段，您应该能够 ping 通 R1 的 f0/1 接口(7.7.7.2)。运行`undebug all`命令关闭 Telnet 调试并完成您的第一个 CML-PERSONAL Telnet 实验。 |
|   | `LAB-R1#` |
|   | `*Jan 11 18:11:21.417: %OSPF-5-ADJCHG: Process 1, Nbr 192.168.183.133 on GigabitEthernet0/0 from LOADING to FULL, Loading Done` |
|   | `LAB-R1#` `show ip ospf neighbor` |
|   | `Neighbor ID     Pri   State           Dead Time   Address         Interface` |
|   | `192.168.183.133   1   FULL/BDR        00:00:39    192.168.183.133 GigabitEthernet0/0` |
|   | `LAB-R1#` `ping 7.7.7.2` |
|   | `Type escape sequence to abort.` |
|   | `Sending 5, 100-byte ICMP Echos to 7.7.7.2, timeout is 2 seconds:` |
|   | `!!!!!` |
|   | `Success rate is 100 percent (5/5), round-trip min/avg/max = 7/10/14 ms` |
|   | `LAB-R1#` `undebug all` |
|   | `All possible debugging has been turned off` |

*   IP 地址为 2.2.2.2/32 的环回 0

*   IP 地址为 4.4.4.4/32 的环回 1

*   OSPF 1 的网络 0.0.0.0 255.255.255.255 位于区域 0

所有用到的 Python 代码都可以从 [`https://github.com/pynetauto/apress_pynetauto`](https://github.com/pynetauto/apress_pynetauto) 下载。如果您喜欢第一个 Telnet 实验，现在想尝试第二个实验，让我们继续。

## Telnet 实验 2:使用 Python Telnet 模板配置单台交换机

在本实验中，您将通过 Telnet 在`LAB-SW1`上配置一些 VLANs。在本实验中，您需要启动`ubuntu20s1` Linux 服务器(192.168.183.132)和`LAB-SW1` (192.168.183.101)。为了节省时间，我们将复制第一个脚本`add_lo_ospf1.py`，并将其重命名为`add_vlans_single.py`。本实验结束时，`LAB-SW1`应如图 [13-3](#Fig3) 所示进行配置。

![../images/492721_1_En_13_Chapter/492721_1_En_13_Fig3_HTML.jpg](../images/492721_1_En_13_Chapter/492721_1_En_13_Fig3_HTML.jpg)

图 13-3。

Telnet 实验 2，正在使用的设备

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | SSH 进入`ubuntu20s1`服务器(192.168.183.132 ),继续在第一个实验的目录中工作。按照这里的说明复制第一个 Python 脚本，并将其重命名为`add_vlans_single.py`。 |
|   | `pynetauto@ubuntu20s1:~$` `cd telnet_labs` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `ls` |
|   | `7.2.1_add_lo_ospf1.py` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `cp add_lo_ospf1.py add_vlans_single.py` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `ls` |
|   | `add_lo_ospf1.py  add_vlans_single.py` |
| **2** | 用 nano 文本编辑器打开新创建的`.py`文件。按 Ctrl+K 复制/剪切代码行，按 Ctrl+U 粘贴信息。注意`LAB-SW1`的 IP 地址是 192.168.183.101。确保用这个 IP 地址更新`HOST`旁边的 IP 地址。 |
| 使用以下信息修改您的脚本。编写代码时，每个逗号和句号都很重要。`b` =字节文字量；生成`byte`类型的实例，而不是`str`类型的实例。`\n` =转到下一行的换行符。换句话说，`"[Enter] key"encode('ascii')`意味着对交换机/路由器使用 ASCII 编码。 |
|   | `GNU nano 4.8` `add_vlans_single.py` |
|   | `import getpass` |
|   | `import telnetlib` |
|   | `HOST = "``192.168.183.101`T2】 |
|   | `user = input("Enter your username: ")` |
|   | `password = getpass.getpass()` |
|   | `tn = telnetlib.Telnet(HOST)` |
|   | `tn.read_until(b"Username: ")` |
|   | `tn.write(user.encode('ascii') + b"\n")` |
|   | `if password:` |
|   | `tn.read_until(b"Password: ")` |
|   | `tn.write(password.encode('ascii') + b"\n")` |
|   | `# Get into config mode` |
|   | `tn.write(b"conf t\n")` |
|   | `# configure 4 VLANs with VLAN names` |
|   | `tn.write(b"vlan 2\n")` |
|   | `tn.write(b"name Data_vlan_2\n")` |
|   | `tn.write(b"vlan 3\n")` |
|   | `tn.write(b"name Data_vlan_3\n")` |
|   | `tn.write(b"vlan 4\n")` |
|   | `tn.write(b"name Voice_vlan_4\n")` |
|   | `tn.write(b"vlan 5\n")` |
|   | `tn.write(b"name Wireless_vlan_5\n")` |
|   | `tn.write(b"exit\n")` |
|   | `# configure Gi1/0 - Gi1/3 as access siwtchports and assign vlan 5 for wireless APs` |
|   | `tn.write(b"interface range gi1/0 - 3\n")` |
|   | `tn.write(b"switchport mode access\n")` |
|   | `tn.write(b"switchport access vlan 5\n")` |
|   | `tn.write(b"no shut\n")` |
|   | `#configure gi2/0 - gi2/3 as access switchports and assign vlan 2 for data and vlan 4 for voice` |
|   | `tn.write(b"interface range gi2/0 - 3\n")` |
|   | `tn.write(b"switchport mode access \n")` |
|   | `tn.write(b"switchport access vlan 2\n")` |
|   | `tn.write(b"switchport voice vlan 4\n")` |
|   | `tn.write(b"no shut\n")` |
|   | `tn.write(b"end\n")` |
|   | `tn.write(b"exit\n")` |
|   | `print(tn.read_all().decode('ascii'))` |
|   | `^G Get Help  ^O Write Out   ^W Where Is   ^K Cut Text     ^J Justify    ^C Cur Pos` |
|   | `^X Exit      ^R Read File   ^\ Replace    ^U Paste Text   ^T To Spell   ^_ Go To Line` |
| **3** | 从`ubuntu20s1`服务器，运行`ping 192.168.183.101 –c 4`命令来检查连接。 |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `ping 192.168.183.101 -c 3` |
|   | `PING 192.168.183.101 (192.168.183.101) 56(84) bytes of data.` |
|   | `64 bytes from 192.168.183.101: icmp_seq=1 ttl=255 time=20.3 ms` |
|   | `64 bytes from 192.168.183.101: icmp_seq=2 ttl=255 time=7.77 ms` |
|   | `64 bytes from 192.168.183.101: icmp_seq=3 ttl=255 time=17.5 ms` |
|   | `--- 192.168.183.101 ping statistics ---` |
|   | `4 packets transmitted, 4 received, 0% packet loss, time 3005ms` |
|   | `rtt min/avg/max/mdev = 7.773/14.035/20.312/5.067 ms` |
| **4** | 或者，在`LAB-SW1`上，启用`debug telnet`在脚本运行期间捕获 Telnet 活动。打开调试后，保持控制台窗口打开。 |
|   | `LAB-SW1#` `debug telnet` |
| **5** | 现在我们检查了连通性。让我们运行`python add_vlans_single.py`命令来运行脚本，添加新的 VLANs，并配置指定的交换机端口。 |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `python add_vlans_single.py` |
|   | `Enter your username:` `pynetauto` |
|   | `Password:********` |
|   | `**************************************************************************` |
|   | `* IOSv is strictly limited to use for evaluation, demonstration and IOS  *` |
|   | `* education. IOSv is provided as-is and is not supported by Cisco's      *` |
|   | `* Technical Advisory Center. Any use or disclosure, in whole or in part, *` |
|   | `* of the IOSv Software or Documentation to any third party for any       *` |
|   | `* purposes is expressly prohibited except as otherwise authorized by     *` |
|   | `* Cisco in writing.                                                      *` |
|   | `**************************************************************************` |
|   | `LAB-SW1#conf t` |
|   | `Enter configuration commands, one per line.  End with CNTL/Z.` |
|   | `LAB-SW1(config)#vlan 2` |
|   | `LAB-SW1(config-vlan)#name Data_vlan_2` |
|   | `LAB-SW1(config-vlan)#vlan 3` |
|   | `LAB-SW1(config-vlan)#name Data_vlan_3` |
|   | `LAB-SW1(config-vlan)#vlan 4` |
|   | `LAB-SW1(config-vlan)#name Voice_vlan_4` |
|   | `LAB-SW1(config-vlan)#vlan 5` |
|   | `LAB-SW1(config-vlan)#name Wireless_vlan_5` |
|   | `LAB-SW1(config-vlan)#exit` |
|   | `LAB-SW1(config)#interface range gi1/0 - 3` |
|   | `LAB-SW1(config-if-range)#switchport mode access` |
|   | `LAB-SW1(config-if-range)#switchport access vlan 5` |
|   | `LAB-SW1(config-if-range)#no shut` |
|   | `LAB-SW1(config-if-range)#interface range gi2/0 - 3` |
|   | `LAB-SW1(config-if-range)#switchport mode access` |
|   | `LAB-SW1(config-if-range)#switchport access vlan 2` |
|   | `LAB-SW1(config-if-range)#switchport voice vlan 4` |
|   | `LAB-SW1(config-if-range)#no shut` |
|   | `LAB-SW1(config-if-range)#end` |
|   | `LAB-SW1#exit` |
| **6** | 检查`LAB-SW1`控制台窗口以获取调试信息。 |
|   | `LAB-SW1#` |
|   | `*Jan 11 19:24:31.981: Telnet2: 1 1 251 1` |
|   | `*Jan 11 19:24:31.982: TCP2: Telnet sent WILL ECHO (1)` |
|   | `*Jan 11 19:24:31.982: Telnet2: 2 2 251 3` |
|   | `*Jan 11 19:24:31.984: TCP2: Telnet sent WILL SUPPRESS-GA (3)` |
|   | `*Jan 11 19:24:31.984: Telnet2: 80000 80000 253 24` |
|   | `*Jan 11 19:24:31.985: TCP2: Telnet sent DO TTY-TYPE (24)` |
|   | `*Jan 11 19:24:31.985: Telnet2: 10000000 10000000 253 31` |
|   | `*Jan 11 19:24:31.986: TCP2: Telnet sent DO WINDOW-SIZE (31)` |
|   | `*Jan 11 19:24:32.036: TCP2: Telnet received DONT ECHO (1)` |
|   | `*Jan 11 19:24:32.037: TCP2: Telnet sent WONT ECHO (1)` |
|   | `*Jan 11 19:24:32.042: TCP2: Telnet received DONT SUPPRESS-GA (3)` |
|   | `*Jan 11 19:24:32.043: TCP2: Telnet sent WONT SUPPRESS-GA (3)` |
|   | `LAB-SW1#` |
|   | `*Jan 11 19:24:32.048: TCP2: Telnet received WONT TTY-TYPE (24)` |
|   | `*Jan 11 19:24:32.050: TCP2: Telnet sent DONT TTY-TYPE (24)` |
|   | `*Jan 11 19:24:32.054: TCP2: Telnet received WONT WINDOW-SIZE (31)` |
|   | `*Jan 11 19:24:32.054: TCP2: Telnet sent DONT WINDOW-SIZE (31)` |
|   | `*Jan 11 19:24:32.186: TCP2: Telnet received DONT ECHO (1)` |
|   | `*Jan 11 19:24:32.187: TCP2: Telnet received DONT SUPPRESS-GA (3)` |
|   | `*Jan 11 19:24:32.187: TCP2: Telnet received WONT TTY-TYPE (24)` |
|   | `*Jan 11 19:24:32.189: TCP2: Telnet received WONT WINDOW-SIZE (31)` |
|   | `LAB-SW1#` |
|   | `*Jan 11 19:24:40.915: %SYS-5-CONFIG_I: Configured from console by pynetauto on vty0 (192.168.183.132)` |
| **7** | 现在检查配置的 VLANs 和`LAB-SW1`交换机上的交换机端口。使用`show vlan`、`show run`和`show ip interface brief`检查开关配置变化。这里显示的是`show vlan`的例子: |
|   | `LAB-SW1#show vlan` |
|   | `VLAN Name                             Status    Ports` |
|   | `---- -------------------------------- --------- -------------------------------` |
|   | `1    default                          active    Gi0/0, Gi0/1, Gi0/2, Gi0/3` |
|   | `Gi3/0, Gi3/1, Gi3/2, Gi3/3` |
|   | `2    Data_vlan_2                      active    Gi2/0, Gi2/1, Gi2/2, Gi2/3` |
|   | `3    Data_vlan_3                      active` |
|   | `4    Voice_vlan_4                     active    Gi2/0, Gi2/1, Gi2/2, Gi2/3` |
|   | `5    Wireless_vlan_5                  active    Gi1/0, Gi1/1, Gi1/2, Gi1/3` |
|   | `1002 fddi-default                     act/unsup` |
|   | `[...omitted for brevity]` |
|   | `------- --------- ----------------- ------------------------------------------` |

*   使用以下 VLAN 描述配置 VLANs 2 到 VLAN 5:
    *   VLAN 2， `Data_vlan_2`

    *   VLAN 3， `Data_vlan_3`

    *   VLAN 4， `Voice_vlan_4`

    *   VLAN 5， `Wireless_vlan_5`

*   用`Wireless_vlan_5`将千兆以太网 1/0 到千兆以太网 1/3 范围配置为接入交换机端口。

*   用`Data_vlan_2`(数据 VLAN)和`voice_vlan_4`(辅助 VLAN)配置千兆以太网 2/0 到千兆以太网 2/3 范围作为交换机端口。

*   用`no shut`命令调出所有已配置的接口。

您已经成功添加了四个 VLAN，并在各自的 VLAN 中配置了八个交换机端口。现在，我们来看看如何在实验 3 和实验 4 中使用环路添加多个随机 VLANs。

## Telnet 实验 3:使用 for 循环配置随机 VLANs

在上一个实验中，我们用多行代码配置了 VLANs 2 到 VLAN 5；在这里，您将练习如何使用一个`for`循环用更少的代码添加 VLANs。为了简单起见，我们在这个实验中只添加了五个随机 VLANs，但是我们使用了一个`for`循环，您可以节省时间和必须编写的代码行数。

按照步骤通过 Telnet 在`LAB-SW1`上配置随机 VLANs 101、202、303、404 和 505。在本实验中，您可以继续使用`ubuntu20s1` Linux 服务器(192.168.183.132)和`LAB-SW1` (192.168.183.101)。复制`7.2.2_add_vlans_single.py`文件，并将其重命名为`7.2.3_add_vlans_for_loop.py`，用于本实验。本实验结束时，`LAB-SW1`应如图 [13-4](#Fig4) 所示进行配置。

![../images/492721_1_En_13_Chapter/492721_1_En_13_Fig4_HTML.jpg](../images/492721_1_En_13_Chapter/492721_1_En_13_Fig4_HTML.jpg)

图 13-4。

Telnet 实验 3:使用中的设备

*   将具有以下 VLAN 描述的 VLANs 101、202、303、404 和 505 添加到`LAB-SW1`:
    *   VLAN 101， `Data_vlan_101`

    *   VLAN 202， `Data_vlan_202`

    *   VLAN 303， `Voice_vlan_303`

    *   VLAN 404， `Wireless_vlan_404`

    *   VLAN 505， `Wireless_vlan_505`

![../images/492721_1_En_13_Chapter/492721_1_En_13_Figc_HTML.jpg](../images/492721_1_En_13_Chapter/492721_1_En_13_Figc_HTML.jpg)在本实验中，试着专注于`for`循环是如何工作的，以及它在本场景中是如何使用的。循环被设计来重复执行相同的任务，现在你正在挖掘编程的真正力量。学习 Python 概念，以便将它们应用到您的工作中是您想要达到的目标。祝你好运！

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 首先，移动到`telnet_labs`目录，用`cp`命令复制`add_vlans_single.py`，重命名为`add_vlans_for_loop.py`。命令如下所示: |
|   | `pynetauto@ubuntu20s1:~$` `cd telnet_labs` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `ls` |
|   | `7.2.1_add_lo_ospf1.py  7.2.2_add_vlans_single.py` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `cp add_vlans_single.py add_vlans_for_loop.py` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `ls` |
|   | `add_lo_ospf1.py  add_vlans_single.py  add_vlans_for_loop.py` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `nano add_vlans_for_loop.py` |
| **2** | 现在，修改脚本，如下所示。再次按 Ctrl+K 剪切/复制信息，按 Ctrl+U 粘贴复制的信息。在此更改过程中，请检查您的语法和空白。每个逗号和空格都很重要，尤其是代码块的缩进或四个空格。 |
|   | `GNU nano 4.8` `add_vlans_for_loop.py` |
|   | `#!/usr/bin/env python3 # This is called the shebang line; Python ignores this line, but the Linux Operating System can read this line and knows which application to run the .py file with.` |
|   | `import getpass` |
|   | `import telnetlib` |
|   | `HOST``= "``192.168.183.101`T3】 |
|   | `user = input("Enter your username: ")` |
|   | `password = getpass.getpass()` |
|   | `tn = telnetlib.Telnet(HOST)` |
|   | `tn.read_until(b"Username: ")` |
|   | `tn.write(user.encode('ascii') + b"\n")` |
|   | `if password:` |
|   | `tn.read_until(b"Password: ")` |
|   | `tn.write(password.encode('ascii') + b"\n")` |
|   | `# Get into config mode` |
|   | `tn.write(b"conf t\n")` |
|   | `# Adds 5 vlans to the list with for loop` |
|   | `vlans = [101, 202, 303, 404, 505]` `# vlans to add in  a list` |
|   | `for i in vlans` `: # call (index) each item from list vlans` |
|   | `command_1 = "vlan " + str(i) + "\n"` `# concatenate first command` |
|   | `tn.write(command_1.encode('ascii'))` `# send command_1 with ASCII encoding` |
|   | `command_2 = "name PYTHON_VLAN_" + str(i) + "\n"` `# concatenate second command` |
|   | `tn.write(command_2.encode('ascii'))` `# send command_2 with ASCII encoding` |
|   | `tn.write(b"end\n")` |
|   | `tn.write(b"exit\n")` |
|   | `print("exiting")` |
|   | `print(tn.read_all().decode('ascii'))` |
|   | `^G Get Help  ^O Write Out   ^W Where Is   ^K Cut Text     ^J Justify    ^C Cur Pos` |
|   | `^X Exit      ^R Read File   ^\ Replace    ^U Paste Text   ^T To Spell   ^_ Go To Line` |
|   | 如你所见，`telnetlib`的编解码比较乱；这是因为`telnetlib`使用 pyNUT 与网络设备通信，pyNUT 代码使用字符串文字在内部格式化字符串。PyNUT 是为 Python 2 编写的，`telnetlib`希望大部分输入都是以字节为单位的。在 Python 2 中，`str` (string)类型是一个字节字符串，但是在 Python 3 中，它全部是 Unicode。幸运的是，SSH Python 应用程序中的编码和解码并不复杂。 |
| **3** | 使用以下 Python 命令运行脚本。您可以使用任一命令。我们添加了用户的别名`/.bashrc`,以便使用 Python3 或 Python 来运行脚本。 |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `python add_vlans_for_loop.py` |
|   | `OR` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `python3 add_vlans_for_loop.py` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `python add_vlans_for_loop.py` |
|   | `Enter your username:` `pynetauto` |
|   | `Password:********` |
|   | `exiting` |
|   | `**************************************************************************` |
|   | `* IOSv is strictly limited to use for evaluation, demonstration and IOS  *` |
|   | `* education. IOSv is provided as-is and is not supported by Cisco's      *` |
|   | `* Technical Advisory Center. Any use or disclosure, in whole or in part, *` |
|   | `* of the IOSv Software or Documentation to any third party for any       *` |
|   | `* purposes is expressly prohibited except as otherwise authorized by     *` |
|   | `* Cisco in writing.                                                      *` |
|   | `**************************************************************************` |
|   | `LAB-SW1#conf t` |
|   | `Enter configuration commands, one per line.  End with CNTL/Z.` |
|   | `LAB-SW1(config)#vlan 101` |
|   | `LAB-SW1(config-vlan)#name PYTHON_VLAN_101` |
|   | `LAB-SW1(config-vlan)#vlan 202` |
|   | `LAB-SW1(config-vlan)#name PYTHON_VLAN_202` |
|   | `LAB-SW1(config-vlan)#vlan 303` |
|   | `LAB-SW1(config-vlan)#name PYTHON_VLAN_303` |
|   | `LAB-SW1(config-vlan)#vlan 404` |
|   | `LAB-SW1(config-vlan)#name PYTHON_VLAN_404` |
|   | `LAB-SW1(config-vlan)#vlan 505` |
|   | `LAB-SW1(config-vlan)#name PYTHON_VLAN_505` |
|   | `LAB-SW1(config-vlan)#end` |
|   | `LAB-SW1#exit` |
| **4** | 在`LAB-SW1`上运行`show vlan`命令以确认新配置的 VLANs。如果您可以在交换机的 vlan 表中看到新的 VLAN，那么您的 Python 脚本使用 for 循环向交换机添加随机 VLAN。 |
|   | `LAB-SW1#` `show vlan` |
|   | `VLAN Name                             Status    Ports` |
|   | `---- -------------------------------- --------- -------------------------------` |
|   | `1    default                          active    Gi0/0, Gi0/1, Gi0/2, Gi0/3` |
|   | `Gi3/0, Gi3/1, Gi3/2, Gi3/3` |
|   | `2    Data_vlan_2                      active    Gi2/0, Gi2/1, Gi2/2, Gi2/3` |
|   | `3    Data_vlan_3                      active` |
|   | `4    Voice_vlan_4                     active    Gi2/0, Gi2/1, Gi2/2, Gi2/3` |
|   | `5    Wireless_vlan_5                  active    Gi1/0, Gi1/1, Gi1/2, Gi1/3` |
|   | `101  PYTHON_VLAN_101                  active` |
|   | `202  PYTHON_VLAN_202                  active` |
|   | `303  PYTHON_VLAN_303                  active` |
|   | `404  PYTHON_VLAN_404                  active` |
|   | `505  PYTHON_VLAN_505                  active` |
|   | `[...omitted for brevity]` |

## Telnet 实验 4:使用 while 循环配置随机 VLANs

与之前的实验一样，这次我们将通过 Telnet 在`lab-sw2`上创建相同的 VLANs 101、202、303、404、505。对于这个实验，您可以继续从`ubuntu20s1` Linux 服务器(192.168.183.132)工作，但是您还必须打开`lab-sw2` (192.168.183.102)的电源。复制`add_vlans_for_loop.py`文件并创建一个名为`add_vlans_while_loop.py`的新脚本。本实验结束时，`lab-sw2`应配置与`LAB-SW1`相同的一组 VLANs，如图 [13-5](#Fig5) 所示。

![../images/492721_1_En_13_Chapter/492721_1_En_13_Fig5_HTML.jpg](../images/492721_1_En_13_Chapter/492721_1_En_13_Fig5_HTML.jpg)

图 13-5。

Telnet 实验 4，正在使用的设备

将具有以下 VLAN 描述的 VLANs 101、202、303、404 和 505 添加到`lab-sw2`。

*   VLAN 101， `Data_vlan_101`

*   VLAN 202， `Data_vlan_202`

*   VLAN 303， `Voice_vlan_303`

*   VLAN 404， `Wireless_vlan_404`

*   VLAN 505， `Wireless_vlan_505`

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 假设你已经在`telnet_labs`目录下工作，使用`cp`命令复制`add_vlans_for_loop.py`并制作`add_vlans_while_loop.py`。按照命令创建新脚本，如下所示: |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `ls` |
|   | `add_lo_ospf1.py      add_vlans_single.py       add_vlans_for_loop.py` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$``cp      add_vlans_for_loop.py`T2】 |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `ls` |
|   | `add_lo_ospf1.py  add       vlans_single.py  add_     vlans_for_loop.py       add_vlans_while_loop.py` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `nano add_vlans_while_loop.py` |
| **2** | 现在修改您的新脚本，如下所示。该脚本使用一个`while`循环示例来添加与图 13.3 所示的`for`循环示例相同的 VLAN。同样，不要太在意您在这里使用的实际登录协议。试着理解这个示例脚本中使用的`while`循环的工作逻辑。有关更多信息，请参见嵌入式解释。 |
|   | `GNU nano 4.8` `add_vlans_while_loop.py` |
|   | `#!/usr/bin/env python3` |
|   | `import getpass` |
|   | `import telnetlib` |
|   | `HOST =``"192.168.183.102"`T2】 |
|   | `user = input("Enter your username: ")` |
|   | `password = getpass.getpass()` |
|   | `tn = telnetlib.Telnet(HOST)` |
|   | `tn.read_until(b"Username: ")` |
|   | `tn.write(user.encode('ascii') + b"\n")` |
|   | `if password:` |
|   | `tn.read_until(b"Password: ")` |
|   | `tn.write(password.encode('ascii') + b"\n")` |
|   | `# Get into to config mode` |
|   | `tn.write(b"conf t\n")` |
|   | `# Add 5 random vlans to vlans list and use  while loop to configure them to the switch` |
|   | `vlans = [101, 202, 303, 404, 505]` `# vlans to add in list` |
|   | `i = 0` `# initial index value` |
|   | `while i < len(vlans):` `# while i is smaller than the length of vlans` |
|   | `print(vlans[i])` `# print vlans item` |
|   | `command_1 = "vlan " + str(vlans[i]) + "\n"` `# concatenate first command` |
|   | `tn.write(command_1.encode('ascii'))` `# send command_1 with ASCII encoding` |
|   | `command_2 = "name PYTHON_VLAN_" + str(vlans[i]) + "\n"` `# concatenate second command` |
|   | `tn.write(command_2.encode('ascii'))` `# send command_2 with ASCII encoding` |
|   | `i +=1` `# Same as i = i + 1` |
|   | `tn.write(b"end\n")` |
|   | `tn.write(b"exit\n")` |
|   | `print("exiting")` |
|   | `print(tn.read_all().decode('ascii'))` |
|   | `^G Get Help  ^O Write Out   ^W Where Is   ^K Cut Text     ^J Justify    ^C Cur Pos` |
|   | `^X Exit      ^R Read File   ^\ Replace    ^U Paste Text   ^T To Spell   ^_ Go To Line` |
| **3** | 完成`while`循环脚本后，检查与`lab-sw2` (192.168.183.102)的连接，并使用以下命令之一运行命令: |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `python add_vlans_while_loop.py` |
|   | `OR` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `python3 add_vlans_while_loop.py` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `ping 192.168.183.102 -c 3` |
|   | `PING 192.168.183.102 (192.168.183.102) 56(84) bytes of data.` |
|   | `64 bytes from 192.168.183.102: icmp_seq=1 ttl=255 time=41.1 ms` |
|   | `64 bytes from 192.168.183.102: icmp_seq=2 ttl=255 time=27.3 ms` |
|   | `64 bytes from 192.168.183.102: icmp_seq=3 ttl=255 time=22.5 ms` |
|   | `--- 192.168.183.102 ping statistics ---` |
|   | `3 packets transmitted, 3 received, 0% packet loss, time 2003ms` |
|   | `rtt min/avg/max/mdev = 22.537/30.294/41.086/7.870 ms` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `python add_vlans_while_loop.py` |
|   | `Enter your username:` `pynetauto` |
|   | `Password:********` |
|   | `101` |
|   | `202` |
|   | `303` |
|   | `404` |
|   | `505` |
|   | `exiting` |
|   | `**************************************************************************` |
|   | `* IOSv is strictly limited to use for evaluation, demonstration and IOS  *` |
|   | `* education. IOSv is provided as-is and is not supported by Cisco's      *` |
|   | `* Technical Advisory Center. Any use or disclosure, in whole or in part, *` |
|   | `* of the IOSv Software or Documentation to any third party for any       *` |
|   | `* purposes is expressly prohibited except as otherwise authorized by     *` |
|   | `* Cisco in writing.                                                      *` |
|   | `**************************************************************************` |
|   | `lab-sw2#conf t` |
|   | `Enter configuration commands, one per line.  End with CNTL/Z.` |
|   | `lab-sw2(config)#vlan 101` |
|   | `lab-sw2(config-vlan)#name PYTHON_VLAN_101` |
|   | `lab-sw2(config-vlan)#vlan 202` |
|   | `lab-sw2(config-vlan)#name PYTHON_VLAN_202` |
|   | `lab-sw2(config-vlan)#vlan 303` |
|   | `lab-sw2(config-vlan)#name PYTHON_VLAN_303` |
|   | `lab-sw2(config-vlan)#vlan 404` |
|   | `lab-sw2(config-vlan)#name PYTHON_VLAN_404` |
|   | `lab-sw2(config-vlan)#vlan 505` |
|   | `lab-sw2(config-vlan)#name PYTHON_VLAN_505` |
|   | `lab-sw2(config-vlan)#end` |
|   | `lab-sw2#exit` |
| **4** | 从`lab-sw2`运行`show vlan`命令，检查新配置的 VLANs。如果您看到这里添加了 VLAN，那么您已经使用`while`环路成功地在交换机上配置了随机 VLAN。 |
|   | `lab-sw2#` `show vlan` |
|   | `VLAN Name                             Status    Ports` |
|   | `---- -------------------------------- --------- -------------------------------` |
|   | `1    default                          active    Gi0/0, Gi0/1, Gi0/2, Gi0/3` |
|   | `Gi1/0, Gi1/1, Gi1/2, Gi1/3` |
|   | `Gi2/0, Gi2/1, Gi2/2, Gi2/3` |
|   | `Gi3/0, Gi3/1, Gi3/2, Gi3/3` |
|   | `101  PYTHON_VLAN_101                  active` |
|   | `202  PYTHON_VLAN_202                  active` |
|   | `303  PYTHON_VLAN_303                  active` |
|   | `404  PYTHON_VLAN_404                  active` |
|   | `505  PYTHON_VLAN_505                  active` |
|   | `[...omitted for brevity]` |

## Telnet 实验 5:使用 for ~ in range 环路方法配置 100 个 VLANs

在本实验中，您将在`LAB-SW1` (192.168.183.101)和`lab-sw2` (192.168.183.102)交换机上使用`for ~ in range`环路方法创建 100 个 VLANs。您将从同一个 Python 服务器,`ubuntu20s1` Linux 服务器(192.168.183.132)创建脚本。复制`add_vlans_while_loop.py`文件并创建一个名为`add_vlans_for_range.py`的新脚本。在本实验结束时，`LAB-SW1`和`lab-sw2`都应该配置有 VLANs 700 到 799。参见图 [13-6](#Fig6) 。

![../images/492721_1_En_13_Chapter/492721_1_En_13_Fig6_HTML.jpg](../images/492721_1_En_13_Chapter/492721_1_En_13_Fig6_HTML.jpg)

图 13-6。

Telnet 实验 5，正在使用的设备

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 使用 PuTTY SSH 到`ubuntu20s1` (192.168.183.132)来复制之前的 Telnet 脚本并创建`7.2.5_add_100_vlans.py`文件。 |
|   | `pynetauto@ubuntu20s1:~$` `cd telnet_labs` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$ ls` |
|   | `add_lo_ospf1.py      add_vlans_for_loop.py      add_vlans_single.py  add_vlans_while_loop.py` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$``cp add_vlans_while_loop.py add_100_vlans.py``pynetauto@ubuntu20s1:~/telnet_labs$`T3】 |
| **2** | 这次您将使用一个脚本在两台交换机上配置 100 个 VLANs。您必须非常小心这个脚本的前导空格和代码块。与空白和脚本的代码块保持一致。修改脚本时，请参考嵌入的解释。使用`#`或`""" """`添加任意多的评论。在修改结束时，您的 Python 脚本应该类似于以下代码。 |
|   | 该脚本可以下载，但是您应该尝试在 Linux 的 nano 文本编辑器上修改该脚本，以便熟悉 Linux 上的文本编辑。 |
|   | `GNU nano 4.8` `add_100_vlans.py` |
|   | `#!/usr/bin/env python3.8` |
|   | `import getpass` |
|   | `import telnetlib` |
|   | `# HOSTS is a list with IP addresses of two switches` |
|   | `HOSTS = ["192.168.183.101", "192.168.183.102"]` `# Create a list called HOSTS with two IPs` |
|   | `user = input("Enter your username: ")` |
|   | `password = getpass.getpass()` |
|   | `# Use for loop to loop through the switch IPs` |
|   | `# The rest of the script have been indented  to run under this block` |
|   | `for HOST in HOSTS:` `# To loop through list, HOSTS` |
|   | `print("SWITCH IP : " + HOST)` `# Marker to print out device IP` |
|   | `tn = telnetlib.Telnet(HOST)` |
|   | `tn.read_until(b"Username: ")` |
|   | `tn.write(user.encode('ascii') + b"\n")` |
|   | `if password:` |
|   | `tn.read_until(b"Password: ")` |
|   | `tn.write(password.encode('ascii') + b"\n")` |
|   | `# Configure 100 VLANs with names using 'for ~ in range' loop` `# comment` |
|   | `tn.write(b"conf t\n")` |
|   | `# Use for n in range (starting vlan, ending vlan, (optional-stepping not used))` `# comment` |
|   | `for n in range (700, 800):` `# vlan range to add, 700 – 799, the last number is not counted` |
|   | `tn.write(b"vlan " + str(n).encode('UTF-8') + b"\n")` `# Now part of vlan for loop` |
|   | `tn.write(b"name PYTHON_VLAN_" + str(n).encode('UTF-8') + b"\n")` `# Now part of vlan for loop` |
|   | `tn.write(b"end\n")` |
|   | `tn.write(b"exit\n")` |
|   | `print(tn.read_all().decode('ascii'))` |
|   | `^G Get Help  ^O Write Out   ^W Where Is   ^K Cut Text     ^J Justify    ^C Cur Pos` |
|   | `^X Exit      ^R Read File   ^\ Replace    ^U Paste Text   ^T To Spell   ^_ Go To Line` |
| **3** | 您的 Python 服务器需要从 Ubuntu Python 服务器到两个交换机的良好网络连接；检查开关的通信。仅当您的服务器可以访问这两个 IP 地址时，才运行脚本。如果您有任何通信问题，您必须先解决问题，然后才能继续下一步。 |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `ping 192.168.183.101 -c 3` |
|   | `PING 192.168.183.101 (192.168.183.101) 56(84) bytes of data.` |
|   | `64 bytes from 192.168.183.101: icmp_seq=1 ttl=255 time=5.15 ms` |
|   | `64 bytes from 192.168.183.101: icmp_seq=2 ttl=255 time=5.02 ms` |
|   | `64 bytes from 192.168.183.101: icmp_seq=3 ttl=255 time=5.42 ms` |
|   | `--- 192.168.183.101 ping statistics ---` |
|   | `4 packets transmitted, 4 received, 0% packet loss, time 3005ms` |
|   | `rtt min/avg/max/mdev = 5.019/5.208/5.419/0.145 ms` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `ping 192.168.183.102 -c 3` |
|   | `PING 192.168.183.102 (192.168.183.102) 56(84) bytes of data.` |
|   | `64 bytes from 192.168.183.102: icmp_seq=1 ttl=255 time=9.91 ms` |
|   | `64 bytes from 192.168.183.102: icmp_seq=2 ttl=255 time=9.60 ms` |
|   | `64 bytes from 192.168.183.102: icmp_seq=3 ttl=255 time=9.55 ms` |
|   | `--- 192.168.183.102 ping statistics ---` |
|   | `4 packets transmitted, 4 received, 0% packet loss, time 3006ms` |
|   | `rtt min/avg/max/mdev = 9.549/9.726/9.909/0.154 ms` |
| **4** | 网络连接似乎没问题。现在，让我们运行`add_100_vlans.py`脚本，在两台交换机上添加 100 个 VLANs。该脚本将远程登录到第一台交换机以添加 100 个 VLAN，然后远程登录到第二台交换机以添加另外 100 个 VLAN。这个脚本可能需要几分钟才能完成，请耐心等待。此外，如果你的实验室配置是在像我这样的旧电脑上，考虑将`range`的数量从 100 减少到 10，这样你就可以加快这个过程。 |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `python add_100_vlans.py` |
|   | `Enter your username:` `pynetauto` |
|   | `Password:*******` |
|   | `SWITCH IP : 192.168.183.101` |
|   | `**************************************************************************` |
|   | `* IOSv is strictly limited to use for evaluation, demonstration and IOS  *` |
|   | `* education. IOSv is provided as-is and is not supported by Cisco's      *` |
|   | `* Technical Advisory Center. Any use or disclosure, in whole or in part, *` |
|   | `* of the IOSv Software or Documentation to any third party for any       *` |
|   | `* purposes is expressly prohibited except as otherwise authorized by     *` |
|   | `* Cisco in writing.                                                      *` |
|   | `**************************************************************************` |
|   | `LAB-SW1#conf t` |
|   | `Enter configuration commands, one per line.  End with CNTL/Z.` |
|   | `LAB-SW1(config)#vlan 700` |
|   | `LAB-SW1(config-vlan)#name PYTHON_VLAN_700` |
|   | `LAB-SW1(config-vlan)#vlan 701` |
|   | `[...omitted for brevity]` |
|   | `LAB-SW1(config-vlan)#vlan 799` |
|   | `LAB-SW1(config-vlan)#name PYTHON_VLAN_799` |
|   | `LAB-SW1(config-vlan)#end` |
|   | `LAB-SW1#exit` |
|   | `lab-sw2#` |
|   | `Enter configuration commands, one per line.  End with CNTL/Z.` |
|   | `[...omitted for brevity]` |
| **5** | 给脚本一点时间来完成其任务，并使用`show vlan`检查两个交换机的配置更改。您应该会在两台交换机上看到新配置的 VLAN 700 到 799。 |
|   | `Config message and check added vlans on LAB-SW1` |
|   | `LAB-SW1#` |
|   | `*Jan 11 21:38:00.558: %SYS-5-CONFIG_I: Configured from console by pynetauto on vty0 (192.168.183.132)` |
|   | `LAB-SW1#` `show vlan` |
|   | `[...omitted for brevity]` |
|   | `700  PYTHON_VLAN_700                  active` |
|   | `701  PYTHON_VLAN_701                  active` |
|   | `...` |
|   | `798  PYTHON_VLAN_798                  active` |
|   | `799  PYTHON_VLAN_799                  active` |
|   | `[...omitted for brevity]` |
|   | `Config message and check added vlans on lab-sw2` |
|   | `lab-sw2#` |
|   | `*Jan 11 21:47:09.432: %SYS-5-CONFIG_I: Configured from console by pynetauto on vty0 (192.168.183.132)` |
|   | `lab-sw2#` `show vlan` |
|   | `[...omitted for brevity]` |
|   | `700  PYTHON_VLAN_700                  active` |
|   | `701  PYTHON_VLAN_701                  active` |
|   | `...` |
|   | `798  PYTHON_VLAN_798                  active` |
|   | `799  PYTHON_VLAN_799                  active` |
|   | `[...omitted for brevity]` |
| **6** | (可选任务)要从交换机中删除(反转)100 个 VLANs，您只需修改原始脚本中的两行代码。以下示例将复制原始脚本，并将其重命名为`reverse_100_vlans.py`。在运行脚本之前，打开这个新文件并修改两行代码，如下所示。 |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `cp add_100_vlans.py  reverse_100_vlans.py` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `nano reverse_100_vlans.py` |
|   | `Original code to update:...` |
|   | `for n in range (700, 800):` |
|   | `tn.write(b"vlan " + str(n).encode('UTF-8') + b"\n")` |
|   | `tn.write(b"name PYTHON_VLAN_" + str(n).encode('UTF-8') + b"\n")` |
|   | 更新的反向代码: |
|   | `...` |
|   | `for n in range (700, 800):` |
|   | `tn.write(b"``no`T2】 |
|   | `#` `tn.write(b"name PYTHON_VLAN_" + str(n).encode('UTF-8') + b"\n")` |
|   | 在您的服务器上，运行`python reverse_100_vlans.py`来完全删除 vlans。 |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `python reverse_100_vlans.py` |
|   | `Enter your username:` `pynetauto` |
|   | `Password: ********` |

*   使用以下 VLAN 描述配置 VLAN 700–799:
    *   VLAN 700–799(即`PYTHON_VLAN_700`到`PYTHON_VLAN_799`)

## Telnet 实验 6:使用外部文件中的 IP 地址在多台设备上添加权限为 3 的用户

在本实验中，您将为新用户配置网络中所有路由器和交换机的有限权限，因此您必须打开图 [13-7](#Fig7) 所示设备的电源。您必须创建一个包含 IP 地址的单独文件，以便您的脚本可以从该文件中读取 IP 地址，并按顺序配置每个设备。

![../images/492721_1_En_13_Chapter/492721_1_En_13_Fig7_HTML.jpg](../images/492721_1_En_13_Chapter/492721_1_En_13_Fig7_HTML.jpg)

图 13-7。

Telnet 实验 6，正在使用的设备

新用户应该被授予初级网络管理员权限来运行`show`命令。您将为该新用户分配权限 3，并允许该用户查看网络设备的运行配置和接口状态。此外，将文件模式更改为可执行文件来运行您的脚本，而无需键入`python`或`python3`。

在本实验结束时，您将在每台设备上创建一个本地帐户，以便新用户可以运行`show running-config view full`、`show ip interface brief`和其他`show`命令。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 在`ubuntu20s1` Python 服务器上，创建一个包含所有网络设备 IP 地址的文本文件。用换行符分隔 IP 地址，这样每行包含每台设备的单个 IP 地址。要创建并保存该文件，请遵循以下说明: |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `touch ip_addresses.txt` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `nano ip_addresses.txt` |
|   | GNU nano 4.8 `ip_addresses.txt` |
|   | `192.168.183.10` |
|   | `192.168.183.20` |
|   | `192.168.183.101` |
|   | `192.168.183.102` |
|   | `192.168.183.133` |
|   | `^G Get Help  ^O Write Out    ^W Where Is   ^K Cut Text    ^J Justify   ^C Cur Pos` |
|   | `^X Exit      ^R Read File    ^\ Replace    ^U Paste Text  ^T To Spell  ^_ Go To Line` |
|   | *注意:`ip_addresses.txt`文件必须与`add_junioradmin.py`文件在同一个目录中。 |
| **2** | 与前面的步骤一样，让我们重用旧脚本来创建一个新脚本。复制实验 5 中的脚本，并创建一个名为`add_junioradmin.py`的新脚本。 |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `cp add_100_vlans.py add_junioradmin.py` |
|   | `GNU nano 4.8` `add_junioradmin.py` |
|   | `#!/usr/bin/env python3` |
|   | `import getpass` |
|   | `import telnetlib` |
|   | `import time  # imports time module` |
|   | `user = input("Enter your username: ")` |
|   | `password = getpass.getpass()` |
|   | `# Open ip_addresses.txt to read IP addresses` |
|   | `file = open("ip_addresses.txt")` `# Open and read an external file` |
|   | `for ip in file:` `# loop through read information` |
|   | `print("Now configuring : " + ip)` `# Task beginning statement` |
|   | `HOST = (ip.strip())` `# Strips any white spaces` |
|   | `tn = telnetlib.Telnet(HOST)` `# Use read IP to log into a single device` |
|   | `tn.read_until(b"Username: ")` |
|   | `tn.write(user.encode('ascii') + b"\n")` |
|   | `if password:` |
|   | `tn.read_until(b"Password: ")` |
|   | `tn.write(password.encode('ascii') + b"\n")` |
|   | `time.sleep(1)` `# Adds 1 second pause for device to respond` |
|   | `# Configure a new user with privilege 3, allow show running-config` `# comment` |
|   | `tn.write(b"conf t\n") # Enter configuration mode` |
|   | `tn.write(b"username junioradmin privilege 3 password cisco321\n")` `# Configure new pri 3 user` |
|   | `tn.write(b"privilege exec all level 3 show running-config\n")` `# Allow show running-config command` |
|   | `print("Added a new privilege 3 user")` `# Task ending statement` |
|   | `tn.write(b"end\n")` |
|   | `tn.write(b"exit\n")` |
|   | `print(tn.read_all().decode('ascii'))` |
|   | `^G Get Help  ^O Write Out    ^W Where Is   ^K Cut Text    ^J Justify   ^C Cur Pos` |
|   | `^X Exit      ^R Read File    ^\ Replace    ^U Paste Text  ^T To Spell  ^_ Go To Line` |
| **3** | 在运行脚本之前，请确认 IP 地址和脚本文件都在 Linux 服务器上的同一个目录中。 |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$ ls` |
|   | `add_lo_ospf1.py        add_vlans_while_loop.py   ip_addresses.txt     add_vlans_single.py    add_100_vlans.py      add_vlans_for_loop.py       add_junioradmin.py` |
| **4** | 从`ubuntu20s1`服务器，检查网络中所有网络设备的连接。我们可以在 Linux 上使用`fping`通过一个命令行安装和 ping 多个设备。如图所示进行安装，并 ping 我们拓扑中的所有五台设备。 |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `sudo apt install fping` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `fping 192.168.183.10 192.168.183.20 192.168.183.101 192.168.183.102 192.168.183.133` |
|   | `192.168.183.10 is alive` |
|   | `192.168.183.133 is alive` |
|   | `192.168.183.20 is alive` |
|   | `192.168.183.102 is alive` |
|   | `192.168.183.101 is alive` |
|   | 要了解如何使用`fping`，请访问以下网址。 |
|   | URL: [`https://www.2daygeek.com/how-to-use-ping-fping-gping-in-linux/`](https://www.2daygeek.com/how-to-use-ping-fping-gping-in-linux/) |
| **5** | 我们已经在开头添加了`#!/usr/bin/env python3.8`,正如所解释的，使用这一行是为了让 Linux 系统能够识别这个脚本或应用程序需要从 Python 3 运行。要使用这一行，我们首先必须使我们的脚本可执行。如果您列出我们刚刚创建并准备运行的文件，您会看到文件中缺少了`x`(可执行文件)选项。 |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `ls -l add_junior*` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto 1298 Jan 12 01:16 add_junioradmin.py` |
|   | 为了能够在不使用`python`命令的情况下运行该脚本，我们可以使用`chmod +x`命令更改该文件的模式，如下所示: |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `chmod +x ./ add_junioradmin.py` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$ ls -l add_junior*` |
|   | `-rwxrwxr-x 1 pynetauto pynetauto 1298 Jan 12 01:16 add_junioradmin.py` |
|   | 此时，您可以使用`./add_junioradmin.py`命令运行您的 Python 脚本。 |
|   | 如果您想更进一步，并且想只使用脚本文件名运行脚本，那么您可以将下面的`PATH`变量添加到您的 Linux 服务器中。当您登录到会话中时，此命令只是临时的或会话性的。有一些方法可以永久地设置它，但这不在本书讨论范围之内。在此阶段，您可以仅使用脚本名称运行 Python 脚本。 |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `PATH="$(pwd):$PATH"` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `add_junioradmin.py` |
|   | `Enter your username: ^Z` |
|   | `[2]+  Stopped                 add_junioradmin.py` |
|   | 如果希望以后运行该脚本，请按 Ctrl+Z 退出；如果没有，继续运行步骤 6 中的脚本。 |
| **6** | 让我们使用文件名运行脚本。该脚本会将初级管理员添加到所有五台设备中，如下所示: |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `add_junioradmin.py` |
|   | `Enter your username:` `pynetauto` |
|   | `Password:********` |
|   | `Now configuring : 192.168.183.10` |
|   | `Added a new privilege 3 user` |
|   | `**************************************************************************` |
|   | `* IOSv is strictly limited to use for evaluation, demonstration and IOS  *` |
|   | `* education. IOSv is provided as-is and is not supported by Cisco's      *` |
|   | `* Technical Advisory Center. Any use or disclosure, in whole or in part, *` |
|   | `* of the IOSv Software or Documentation to any third party for any       *` |
|   | `* purposes is expressly prohibited except as otherwise authorized by     *` |
|   | `* Cisco in writing.                                                      *` |
|   | `**************************************************************************` |
|   | `LAB-R1#conf t` |
|   | `Enter configuration commands, one per line.  End with CNTL/Z.` |
|   | `LAB-R1(config)#username junioradmin privilege 3 password cisco321` |
|   | `LAB-R1(config)#privilege exec all level 3 show running-config` |
|   | `LAB-R1(config)#file privilege 3` |
|   | `LAB-R1(config)#end` |
|   | `LAB-R1#exit` |
|   | `Now configuring : 192.168.183.20` |
|   | `Added a new privilege 3 user` |
|   | `[...omitted for brevity]` |
|   | `lab-sw2#conf t` |
|   | `Enter configuration commands, one per line.  End with CNTL/Z.` |
|   | `lab-sw2(config)#username junioradmin privilege 3 password cisco321` |
|   | `lab-sw2(config)#privilege exec all level 3 show running-config` |
|   | `lab-sw2(config)#end` |
|   | `lab-sw2#exit` |
|   | `Now configuring : 192.168.183.133` |
|   | `Added a new privilege 3 user` |
|   | `R1#conf t` |
|   | `Enter configuration commands, one per line.  End with CNTL/Z.` |
|   | `R1(config)#username junioradmin privilege 3 password cisco321` |
|   | `R1(config)#privilege exec all level 3 show running-config` |
|   | `R1(config)#end` |
|   | `R1#exit` |
| **7** | 登录每个设备，检查用户配置以及`privilege exec level 3`命令。 |
|   | `LAB-SW1#` `show run &#124; in username junioradmin` |
|   | `username junioradmin privilege 3 password 0 cisco321` |
|   | `LAB-SW1#` `show run &#124; in level 3` |
|   | `privilege exec all level 3 show running-config` |
|   | `privilege exec level 3 show` |
| **8** | 现在从你的 Windows 主机 PC 使用 PuTTY 以`junioradmin`用户和密码`cisco321`登录并运行`show ip interface brief`或`show running-config view full`命令。如果您想从 Ubuntu 服务器登录设备，您可以使用 Telnet 192.168.183.X，其中 X 是您想登录的设备的最后一个八位字节。 |
|   | 以下示例显示了从`LAB-SW1`交换机和`lab-r2`路由器运行的登录和命令。 |
|   | 从您的主机上，使用 PuTTY 通过 Telnet 登录到`LAB-SW1` (192.168.183.101)并使用密码`cisco321`作为`junioradmin`用户登录。 |
|   | `LAB-SW1#` |
|   | `[...omitted for brevity]` |
|   | `User Access Verification` |
|   | `Username:` `junioradmin` |
|   | `Password:cisco321` |
|   | `[...omitted for brevity]` |
|   | `LAB-SW1#` `show ip interface brief` |
|   | `Interface              IP-Address      OK? Method Status                Protocol` |
|   | `GigabitEthernet0/0     unassigned      YES unset  up                    up` |
|   | `GigabitEthernet0/1     unassigned      YES unset  up                    up` |
|   | `GigabitEthernet0/2     unassigned      YES unset  up                    up` |
|   | `GigabitEthernet0/3     unassigned      YES unset  down                  down` |
|   | `[...omitted for brevity]` |
|   | 从您的主机上，使用 PuTTY 通过 Telnet 登录到`lab-r2` (192.168.183.20)并使用密码`cisco321`作为`junioradmin`用户登录。 |
|   | `lab-r2#` |
|   | `[...omitted for brevity]` |
|   | `User Access Verification` |
|   | `Username:` `junioradmin` |
|   | `Password:cisco321` |
|   | `[...omitted for brevity]` |
|   | `lab-r2#` `show running-config view full` |
|   | `Building configuration...` |
|   | `Current configuration : 3625 bytes` |
|   | `!` |
|   | `! Last configuration change at 23:21:58 UTC Mon Jan 11 2021` |
|   | `!` |
|   | `version 15.6` |
|   | `service timestamps debug datetime msec` |
|   | `[...omitted for brevity]` |

*   *新用户名* : `junioradmin`

*   *密码* : `cisco321`

*   *特权等级* : `3`

*   *命令 1* : `privilege exec all level 3 show running-config`

*   *命令 2* : `file privilege 3`

您已经使用从外部文件读取的 IP 地址在多台设备上成功创建了初级管理员用户帐户。请注意，IP 地址不必是连续的；如果使用列表或外部文件，它们可以是随机的 IP 地址。您从这些 Telnet 实验中学到的东西也可以在 SSH 实验中使用，只需稍加修改。

## Telnet 实验 7:将运行配置(或启动配置)备份到本地服务器存储

在 Telnet 实验 7 中，您将复制并修改之前的 Telnet 脚本，以捕获网络中每台设备的当前运行配置。备份的`running-config`文件将保存在本地驱动器上。在本实验中，您将使用`datetime`模块获取时间戳，并添加带有该时间戳的文件名，以便了解备份的时间。您需要打开所有路由器和交换机的电源，如实验 6 所示。见图 [13-8](#Fig8) 。

![../images/492721_1_En_13_Chapter/492721_1_En_13_Fig8_HTML.jpg](../images/492721_1_En_13_Chapter/492721_1_En_13_Fig8_HTML.jpg)

图 13-8。

Telnet 实验 7，正在使用的设备

在本实验结束时，您将在 Python 服务器的本地存储上备份每台设备的运行配置和时间戳。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

#

 | 

工作

 |
| --- | --- |
| **1** | 同样，让我们从复制上一个实验的脚本开始实验。这里给出的文件名是`take_backups.py`，但是你不必遵循这个命名约定；请为该文件取一个更有意义的名称，以便于记忆。 |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `cp add_junior_user.py take_backups.py` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `nano take_backups.py` |
| **2** | 现在，在 nano(或 vi)文本编辑器中打开该文件，并在以下源代码中进行突出显示的修改: |
|   | `GNU nano 4.8` `take_backups.py` |
|   | `#!/usr/bin/env python3` |
|   | `import getpass` |
|   | `import telnetlib` |
|   | `from datetime import datetime` `# Import datetime module from datetime library` |
|   | `saved_time = datetime.now().strftime("%Y%m%d_%H%M%S")` `# Change the \` |
|   | `# format of current time into a string` |
|   | `user = input("Enter your username: ") # Ask for username and password` |
|   | `password = getpass.getpass()` |
|   | `file = open("ip_addresses.txt") # Open ip_addresses.txt to read IP addresses` |
|   | `# Telnets into Devices & runs show running-config and \` |
|   | `# save it to a file with a timestamp` |
|   | `for ip in file:` |
|   | `print ("``Getting running-config from`T2】 |
|   | `HOST = ip.strip()` |
|   | `tn = telnetlib.Telnet(HOST)` |
|   | `tn.read_until(b"Username: ")` |
|   | `tn.write(user.encode('ascii') + b"\n")` |
|   | `if password:` |
|   | `tn.read_until(b"Password: ")` |
|   | `tn.write(password.encode('ascii') + b"\n")` |
|   | `#Makes Term length to 0, run shows commands & reads all output,` `\` |
|   | `# then saves files with time stamp` `# Comment` |
|   | `tn.write(("terminal length 0\n").encode('ascii'))` `# Change terminal length to 0` |
|   | `tn.write(("show clock\n").encode('ascii'))` `# Disply time` |
|   | `tn.write(("show running-config\n").encode('ascii'))` `# Show running-configuration` |
|   | `tn.write(("exit\n").encode('ascii'))` `# Exit session` |
|   | `readoutput = tn.read_all()` `# Read output` |
|   | `saveoutput = open(str(saved_time) + "_running_config_" + HOST, "wb")` `# saved_time is the time the file was saved, HOST is the IP address of the device.` |
|   | `saveoutput.write(readoutput) # Write the output to the file` |
|   | `saveoutput.close` `# Save and close the file` |
|   | `^G Get Help  ^O Write Out    ^W Where Is   ^K Cut Text    ^J Justify   ^C Cur Pos` |
|   | `^X Exit      ^R Read File    ^\ Replace    ^U Paste Text  ^T To Spell  ^_ Go To Line` |
| **3** | 再次使用 Linux `fping`命令来检查您网络上的网络连接。如果有任何节点(网络设备)不可访问，您必须首先解决连接问题。 |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `sudo apt install fping` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `fping 192.168.183.10 192.168.183.20 192.168.183.101 192.168.183.102 192.168.183.133` |
|   | `192.168.183.10 is alive` |
|   | `192.168.183.133 is alive` |
|   | `192.168.183.20 is alive` |
|   | `192.168.183.102 is alive` |
|   | `192.168.183.101 is alive` |
| **4** | 现在，从您的`ubuntu20s1`服务器使用`./take_backup.py`命令运行脚本。如果您从上一个实验中复制了脚本，那么文件属性应该被保留，并且您的新脚本应该已经是一个可执行文件了。是时候在本章中最后一次运行代码了。 |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `ls -l take*` |
|   | `-rwxrwxr-x 1 pynetauto pynetauto 1574 Jan 12 10:50 take_backups.py` |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `./take_backups.py` |
|   | `Enter your username:` `pynetauto` |
|   | `Password:` `********` |
|   | `Getting running-config from 192.168.183.10` |
|   | `Getting running-config from 192.168.183.20` |
|   | `Getting running-config from 192.168.183.101` |
|   | `Getting running-config from 192.168.183.102` |
|   | `Getting running-config from 192.168.183.133` |
| **4** | 在脚本成功运行之后，您可以运行`ls –lh` Linux 命令来检查您的设备的本地目录的备份`running-config`文件。文件应该以年、月、日开头，后面是备份的时间。 |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `ls -lh 2021*` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto 4.3K Jan 12 10:53 20210112_105318_running_config_192.168.183.10` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto 5.4K Jan 12 10:53 20210112_105318_running_config_192.168.183.101` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto 4.8K Jan 12 10:54 20210112_105318_running_config_192.168.183.102` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto 1.7K Jan 12 10:54 20210112_105318_running_config_192.168.183.133` |
|   | `-rw-rw-r-- 1 pynetauto pynetauto 4.5K Jan 12 10:53 20210112_105318_running_config_192.168.183.20` |
| **5** | 使用`cat`命令检查是否捕捉到了正确的信息。 |
|   | `pynetauto@ubuntu20s1:~/telnet_labs$` `cat 20210112_105318_running_config_192.168.183.10` |
|   | `**************************************************************************` |
|   | `* IOSv is strictly limited to use for evaluation, demonstration and IOS  *` |
|   | `* education. IOSv is provided as-is and is not supported by Cisco's      *` |
|   | `* Technical Advisory Center. Any use or disclosure, in whole or in part, *` |
|   | `* of the IOSv Software or Documentation to any third party for any       *` |
|   | `* purposes is expressly prohibited except as otherwise authorized by     *` |
|   | `* Cisco in writing.                                                      *` |
|   | `**************************************************************************` |
|   | `LAB-R1#terminal length 0` |
|   | `LAB-R1#show clock` |
|   | `*08:01:50.307 UTC Tue Jan 12 2021` |
|   | `LAB-R1#show running-config` |
|   | `Building configuration...``Current configuration : 3418 bytes` |
|   | `!` |
|   | `version 15.6` |
|   | `service timestamps debug datetime msec` |
|   | `service timestamps log datetime msec` |
|   | `no service password-encryption` |
|   | `!` |
|   | `hostname LAB-R1` |
|   | `!` |
|   | `boot-start-marker` |
|   | `boot-end-marker` |
|   | `!` |
|   | `!` |
|   | `enable password cisco123` |
|   | `!` |
|   | `no aaa new-model` |
|   | `[...omitted for brevity]` |

您已经登录到每台设备，并成功地将路由器和交换机的当前运行配置备份到本地目录。将正在运行的配置备份到 S/FTP 服务器甚至更容易，但本实验是为 SSH 实验保留的。此时，尝试修改您的脚本并运行`write memory`或`copy running-config startup-config`来保存所有的配置更改。接下来，您将尝试使用`paramiko`和`netmiko`库做一些 SSH 实验。

## 摘要

在本章中，我们重点介绍了七个简单的 Telnet 实验，以利用我们在前面章节中获得的知识。您已经学会了如何使用`fping`和`datetime`模块。您还首先交互地执行了简单的配置更改，然后通过使用 Python 脚本，利用循环和`range`命令的力量进行了更改。此外，您还学习了从外部文件读取 IP 地址，并在脚本中使用这些信息。在最后的实验中，您使用 Python `telnetlib`对所有五台网络设备进行了配置备份，每个文件名都带有时间戳。在第 [14](14.html) 章中，您将继续使用`paramiko`和`netmiko` SSH 库通过 SSH 连接探索 Python 网络自动化。