# 让我们用 Python 写一个 Game Boy 模拟器

> 原文：<https://www.inspiredpython.com/course/game-boy-emulator/let-s-write-a-game-boy-emulator-in-python>

Author [Mickey Petersen](https://www.inspiredpython.com/author/mickey-petersen)

对于 20 世纪 80 年代和 90 年代古板、陈旧的游戏平台，有很多东西值得一提。其中最主要的是怀旧——如果你足够大，还记得它们的话——以及对游戏和计算机硬件都更简单、更容易理解的时代的喜爱。

<figure class="w-[15rem] md:mx-5 mx-auto my-0 md:float-left" id="id4">[![alt](img/9a2dbc46004a6541878ad07a1e62a968.png)](https://www.inspiredpython.com/static/courses/game-boy-emulator/Game-Boy-DMG.jpg)

<figcaption>The 4.194304 MHz monochrome Game Boy released in 1989.</figcaption>

</figure>

但对于那些不知道的人来说，Game Boy 是一款标志性的便携式游戏设备，旨在使用你插入设备背面的墨盒来玩电脑游戏。最初的 Game Boy 是单色显示器；一个 8 位 Z80 风格的 CPU，4.194304 MHz 高达 8 KiB 的工作内存和 8 KiB 的视频内存；和 4 个立体声声道。它还有一个液晶显示屏、一个方向游戏手柄和几个按键。热门游戏包括超级马里奥、俄罗斯方块，当然还有神奇宝贝。

在这门课中，我将教你如何用 Python 写一个 Game Boy 模拟器。

## 什么是模拟器？

先简单说一下什么是仿真器*什么是*。在我们的例子中，我们将编写的 Game Boy *模拟器*将模仿我们需要的组成 Game Boy 的许多组件，以使其工作。但是，这句话有很多模糊的上下文:模仿某事*是什么意思？你是如何模拟 LCD 的复杂性的——你甚至尝试过或者仅仅满足于在屏幕上画图吗？CPU，内存和物理按钮呢？那保存游戏的*墨盒*呢？*

决定什么是好的或坏的模拟器归结为仔细的权衡。将源系统的所有硬件缺陷或软件缺陷完美地呈现给主机系统并不总是可行的(或有用的)。还有其他的考虑，比如主机系统是否能够准确地模拟它。

因此，一个模拟器编写者的工作是选择你的战斗，并承认有些事情(在我们的例子中是某些游戏)如果没有不成比例的工作量*对*的投资回报，就无法工作。不同的硬件如何相互作用的复杂性，以及程序员为保证每个周期的性能所经历的极端长度，意味着如果你*真的*想要一个*周期精确的仿真器*，你必须实现大量晦涩难懂的行为。现在，随着教育的“投资回报”急剧下降，我将不再努力追求那种水平的竞争。

 一个*周期精确的*仿真器试图模仿原始系统的特性，使得仿真系统的时序尽可能接近真实系统。某些游戏和应用程序需要实现这种级别的模拟，但并非所有游戏和应用程序都需要。 

但话说回来，这些错综复杂的组件如何交互绝对是我们会遇到的事情:有许多边缘情况和设计怪癖，我们必须权衡试图准确反映真实系统的好处，而不是简单地宣布它“足够好”并继续前进。

因为这是一门教育课程，所以主要的重点是教授一些概念，这些概念会产生一个能够运行一些 Game Boy 卡盒的尚可的仿真器。因此，即使你表面上对 Game Boy 不感兴趣，你从课程中学到的东西也会让你对软件和系统编程有深刻的理解。

## 目标受众

你不需要成为 Python 或系统编程方面的专家，也可以尝试一下。整个课程旨在温和地介绍你将要学习的每个概念。这并不意味着你会坐下来，在一个周末就把它完成，即使你是；这是一项相当大的任务，但值得庆幸的是，回报是构建模拟器的体验。

## 你会学到什么

CPU Design and CPU Architecture

Z80 风格的 CPU 与现代英特尔 CPU 可以追溯到的基础 8080 CPU 设计非常相似。虽然 Z80 与 Game Boy 中的 CPU 相似，但并不完全相同:它很可能是一款名为 *LR35902* 的英特尔 8080 风格的夏普 CPU，但我将使用 Z80 这个术语，尽管它不是 100%真实的。原因是除了提到 Game Boy 之外，互联网上关于 Sharp CPU 的文档很少。Z80——尽管它在许多方面与夏普不同——相当相似，并且有大量在线文档。

当然，现代的 CPU 非常复杂；但是旧的 Z80 不是，这使得它非常适合理解 CPU *如何实际工作*的基本原理。

您将使用 Python 编写一个完整的“CPU ”,包括寄存器、标志、内存控制器、指令执行等等。

Assembly Language Programming

您将很好地理解 Z80 汇编语言(以及至今仍在使用的一般概念)以及它是如何支撑我们今天所做的一切的。基于寄存器的 CPU 很可能是你正在阅读的计算机的动力，并且对汇编语言有足够的了解，可以令人信服地推理出 CPU 如何*机器码*被*解码*并执行，这将很好地为你服务。

How to write a Disassembler

如果汇编程序将汇编语言转换成 CPU 可以理解的机器代码，反汇编程序则相反:它将机器代码转换回汇编语言。作为模拟器工作的一部分，当你有条不紊地研究 CPU 规范或调试开发过程中会出现的问题时，你需要这样做。

Interrupt Handling

问问你自己，当你按下 Game Boy 游戏手柄上的键时会发生什么？对于忙于执行组成电脑游戏的代码的 CPU 来说，物理按钮的按下是如何表现为可操作的事情的？这个问题(以及许多其他事件)的答案是*中断处理程序*，这是系统编程的另一个核心部分，它允许在完全没有并发性的 CPU 中处理事件。

Interactive Debugger

您将编写一个交互式调试器，能够单步执行每条机器代码指令；评估简单的表达式，如查看内存或寄存器；当到达代码的特定部分时放置断点；还有更多。

Bit manipulation (or “bit twiddling”)

问问你自己，一台只理解 0 和 1 的计算机如何理解数字 2？它*是如何把*加到那个数上的，一个 CPU 只能对 *8 位*或者 *16 位*数进行运算是什么意思？课程结束时，你将对二进制数有一个坚实的理解；CPU 如何加减和表示有符号和无符号数；如何对二进制数进行“位操作”,例如在位域中设置或重置标志；以及《格列佛游记》和《CPU 字节序》令人费解的词源。

Vertical Blanking, Blitting, Scrolling and Sprites

将东西画到屏幕上是 CPU、内存、显示器及其显示控制器之间精心编排的芭蕾舞。在真正的硬件上出错，你只会打印垃圾，甚至损坏它！幸运的是，这在模拟器中并不重要，但是你仍然需要理解屏幕空白；向屏幕发送信息；以及 Game Boy 如何滚动屏幕并显示移动图形。

Performance Profiling and Code Optimization

Python 是…不快的。您可能会惊讶地听到，即使半精确地模拟一个不起眼的 4.19 MHz CPU 也会对您的 CPU 造成影响！所以一旦该说的都说了，该做的都做了，你就会学到一些加快速度的技巧。

Python

如果我不包括这一点，我将是失职。在整个课程中，我打算向你展示我将如何在考虑到可测试性和良好设计的情况下开发仿真器的关键部分。我将使用 Python 3.10 的 [匹配案例模式匹配](https://www.inspiredpython.com/course/pattern-matching/mastering-structural-pattern-matching) ，因为它有许多诱人的用例，并且这里有很多关于关注点分离的内容——当你必须开发一个复杂的组件网络，但仍然必须独立编写和测试时，这是一个关键的概念。

## 目标和非目标

让我们来谈谈目标和非目标。目标是一个正常运行的 Game Boy 模拟器和一个调试套件来帮助进一步开发它；但是旅程比目的地更重要。在这个过程中，你会学到很多非常酷的概念和技术。完成一个项目感觉*很好*，但是这是一项任务，超过 70-80%的每一个百分点的增量都将花费越来越多的时间，因为你将不得不获得许多复杂的时间安排和设计怪癖来取得进展。那么， *me* 的最终目标就是尽我们所能，并从中获取乐趣和学习，这远远达不到*的周期精度*。但这不应该让你气馁:一旦你很好地理解了 Game Boy 仿真的机制，你就应该拥有自己进一步发展所需的工具和知识。

所以，简而言之:

Emphasis on Readability over Performance

我写的代码将强调可读性，而不是性能。当您还不了解瓶颈可能在哪里或在什么地方时，很容易陷入不必要的性能优化。

## 课程计划

如果你想写一个 Game Boy 模拟器，有相当多的必读材料，但是关于这个主题的主流文档——虽然非常好——确实假设了系统编程的流利程度，我当然会首先解释。

所以计划大致如下:

1.  简介(*这就是你现在正在读的东西*

    1.  什么是游戏机，什么是模拟器

    2.  建议和要求的资源

    3.  从操作码 JSON 中读取操作码

2.  理解操作码和操作数

    1.  如何读取和实现操作码和操作数

    2.  编写一个基本的反汇编程序(和我们未来的解码器)

    3.  什么是盒式只读存储器？

    4.  从盒式磁带中读取元数据

3.  编写 Z-80 CPU 的 Python 框架

    1.  程序计数器

    2.  寄存器和标志

    3.  钻头旋转基础

4.  存储体和存储控制器

5.  编写交互式调试器

6.  实现一些基本的 CPU 操作码

7.  比特旋转和操作数字

8.  ALU 和算术操作码

9.  中断处理

10.  图形、平铺地图、背景和显示

11.  游戏手柄和内存条切换

12.  性能优化

13.  声音

## 建议和要求的资源

你不能在真空中编写游戏模拟器。这条路线站在巨人的肩膀上。有大量的发烧友为游戏男孩的各种化身制作的文档。Game Boy 经过了很多很多年的艰苦逆向工程，已经成为我们可以利用的文档和资源的集合。

也有许多其他的游戏机模拟器，如果你被卡住了，看看他们是怎么做的也没什么不好意思的。你会被卡住的。一旦你更进一步，你就不会有任何问题去推测这些模拟器是如何工作的，并且你可以很快检查你的理解是否正确。

我将包括与我们进展到的每个阶段的进展水平大致匹配的代码示例，但有一点需要注意的是，像所有半成品一样，它当然不会是 100%正确的参考实现——您只有在最后才真正到达那个阶段——但它应该很好地作为 *you* 的参考或起点。随着我们对 Game Boy 及其内部的理解不断加深，每一次进步都会带来变化、修正和改变。

### 所需资源

我应该先列出 [Game Boy 开发社区](https://gbdev.io/),因为这是一个关于 Game Boy 几乎每个部分的精彩网站。你在下面看到的很多信息也可以在上面的 GBDC 链接中找到。

#### 技术参考

《潘文档》是游戏男孩各方面的优秀技术参考。这是我们将使用的两个主要文档来源之一。我会经常提到这一点。

 我强烈建议你浏览一下，感受一下内容是如何编排的，以及编写一个 Game Boy 模拟器需要什么。但是，不要让大量的概念、术语和你需要做的事情使你气馁，尽管我们将一步一步地循序渐进。 

另一个很棒的参考手册是 [Game Boy CPU 手册](http://marc.rawer.de/Gameboy/Docs/GBCPUman.pdf)。它包含更详细的描述，特别是 CPU 操作码和系统的各个方面如何相互作用。你应该阅读并收藏这两本。因为后者是没有超链接的 PDF，我建议你打印出来。不过，请注意，文档中有一些不准确的地方；鼓励您将信息与*完整技术参考*进行交叉参考。

[Game Boy:完整的技术参考](https://gekkio.fi/files/gb-docs/gbctr.pdf)是另一个资源，它也非常好，特别关注内存库(暂时不用担心)和 CPU 指令。

尽管作者声称这本书“陈旧且无人维护”,但实际上它仍然是一本有用且相关的参考手册。

#### 操作码引用

有一个 Game Boy CPU 指令周期表,这是一种有趣的显示信息的方式，你可以在我上面列出的技术参考中找到相同的信息。非常有用的*是同样的 [JSON 下载](https://gbdev.io/gb-opcodes/Opcodes.json)；稍后我将使用它来自动化编写反汇编程序的许多繁琐工作。*

#### 盒式 ROMS

优秀的[自制中心](https://gbhh.avivace.com/)充满了游戏、演示和各种各样的酷 rom 供你尝试。不言而喻，我不能告诉你如何下载你以前玩过的 game boy 盒式光盘，因为这当然侵犯了版权；但是仍然有大量的免费 rom 供你尝试。

#### 模拟器

有许多针对 Game Boy 的仿真器，具有不同的硬件精度和特性。为了开发一个 Game Boy 模拟器，我推荐你看看 BGB，因为它有一个优秀的调试器。我可以确定它在 Windows 上运行得很好，在 Linux 上运行 WINE 也很好。

### 可选但有用的资源

#### 汇编程序和操作码手册

如果你想让*为游戏男孩编写*汇编语言 rom，RGBASM 文档和 [Rednex 游戏男孩开发系统](https://github.com/gbdev/rgbds)是很有用的。如果你想用一个真正的 ROM 测试某些 CPU 指令，你可以。该文档是 Game Boy 汇编语言编程的入门读物。

#### 精灵和瓷砖

游戏男孩图形渲染器很有用，在很久以后，如果你想检查你的 sprite 和 tile 图形实现是否正确。你可以给它输入一串字节，它会告诉你它的图形。

## 读取和解析操作码和操作数

### 操作码和操作数

一个*操作码*是 CPU 必须对操作码的*操作数*执行的动作，如果有的话。因此，如果`1 + 2`是人类的指令，那么*操作码*将是 CPU 的`+`，而`1`和`2`是操作码的*操作数*。

你写的所有代码都会以这样或那样的方式，把自己简化成一组你运行代码的 CPU 能够理解的指令。需要多少步骤取决于你使用的语言和工具:写汇编语言，差距很小；写 Python 是一个巨大的鸿沟。在许多方面，像 Python 这样的*解释的*语言类似于 CPU，因为解释器模仿了组成计算机的大部分架构，以便提供一个“统一的”环境，在那里你可以编写一次代码，并合理地假设它将在解释器运行的地方运行。

因此，解释型语言的好处是，如果你能编写解释器并使它在深奥的计算机硬件上工作，那么你就能期望为解释器编写的大量工作也能运行。具体来说，Python 是在一个*虚拟机*上运行的，我认为这很能说明问题。

考虑以下代码片段:

```py
>>>  def  add(a, b):   return a + b >>>  import dis >>> dis.dis(add)   2  0 LOAD_FAST 0  (a) 2 LOAD_FAST 1  (b) 4 BINARY_ADD 6 RETURN_VALUE ^--- Mnemonic ^^^^^ Argument ^--- Offset
```

使用`dis`模块，我可以通过它的`dis.dis()`函数运行任何对象，并且*将对象分解*成它的组成指令。尽管 Python 使用的术语与 Z80 CPU 看待事物的方式并不完全一一对应，但我认为这是一个合理的复制。我建议你用 Python 反汇编一些东西，感受一下 Python 的 VM 如何理解你的代码。注意，`dis.dis`函数没有显示操作码，但是`dis.get_instructions()`显示了。

同样，您可以要求 Python 为您提供我们的函数`add`的字节编译代码:

```py
>>> add.__code__.co_code b'|\x00|\x01\x17\x00S\x00'
```

By the way …

类似于 T1，我必须指出 Python 的字节码在实现中有各种各样的余量来支持 Python 的动态特性。这意味着具体化的字节码不是源代码的 100%镜像。不过，这不是 Z80 的问题。

字节码是我们代码  的浓缩表示，Game Boy 卡带 rom 也是如此。盒式只读存储器也存储数据——图形、音乐等等——你不一定能以原始字节形式区分代码和数据。

如果你从 rom 中挑选出一个值为`144`的字节，你怎么知道它是代码还是一段音乐的一个小片段呢？

### 获取操作码元数据

我们将要模拟的 Z80 有大约 500 条指令。这听起来可能很多，但大多数都是彼此的变体，我们可以通过一些巧妙的思考一次敲出几把。

好，我们需要一个完整的操作码列表。你在上面看到的反汇编代码是这些东西如何被写出供人使用的一个相当典型的代表。它通常看起来有点像这样:

```py
<addr> <opcode> <mnemonic> [<operand> ...] [; commentary ]
```

`addr`是指令所在的内存地址——我们现在可以忽略它——还有你现在知道的`opcode`和`mnemonic`;`operand`条目的列表是可选的，因为不是所有的操作码都有它们，但是如果它们在那里，我们会显示它们。最后是一个带有`;`的评论，表示一个评论。

我建议你从[操作码表](https://gbdev.io/gb-opcodes/optables/)下载 [JSON](https://gbdev.io/gb-opcodes/Opcodes.json) 并使用它。你没有*有*去:你当然可以复制你在表格或参考手册中看到的说明。

操作码 JSON 分为两个主要部分:`cbprefixed`和`unprefixed`。现在，我建议您将每一个都视为不同的操作码段。有一个很好的理由，我们将详细讨论 ROM 中操作码的结构以及如何读取它们。目前，惟一的目标是获取这个结构化的 JSON 文件，并将其转换成可以用 Python 轻松查询的内容。

任何一个键本身都是一个`{ opcode_1: details_1, ..., opcode_n: details_n }`的字典，就像这样:

```py
"0xFF":  {   "flags":  { "C":  "-", "H":  "-", "N":  "-", "Z":  "-" }, "immediate": true, "operands":  [ { "immediate": true, "name":  "38H" } ], "cycles":  [ 16 ], "bytes":  1, "mnemonic":  "RST" }
```

这是一条带有助记符`RST`的指令。您能使用我之前编写的模板挑选出编写人类可读表单所需的信息吗？

 #### 指令和操作数数据类

解析这个文件应该是一个 zinch。格式绝对可以保持原样；它足够详细，使人类可读。

但是，我更喜欢数据类:

```py
from dataclasses import dataclass from typing import Literal   @dataclass(frozen=True) class  Operand:   immediate:  bool name:  str bytes:  int value:  int  |  None adjust: Literal["+",  "-"]  |  None   def  create(self, value): return Operand(immediate=self.immediate, name=self.name, bytes=self.bytes, value=value, adjust=self.adjust)   @dataclass class  Instruction:   opcode:  int immediate:  bool operands:  list[Operand] cycles:  list[int] bytes:  int mnemonic:  str comment:  str  =  ""   def  create(self, operands): return Instruction(opcode=self.opcode, immediate=self.immediate, operands=operands, cycles=self.cycles, bytes=self.bytes, mnemonic=self.mnemonic)
```

#### Python 中的十六进制

不熟悉十六进制？没问题。快速速成课程。(稍后我们还将讨论二进制，因为它更重要！)

您可能已经看到操作码字典中的键是这样的字符串:`"0xFF"`。十六进制使用的基数*为 16，而不是十进制(基数为 10)或二进制(基数为 2)。在二进制中，你用`0`和`1`计数；十进制用`0`通至`9`；而十六进制是`0`到`9`，然后`A`到`F`产生一个“数”的序列像这样:`0123456789ABCDEF`。*

十六进制通常以`0x`(或 Z80 行话中的`$`，但 Python 不识别该符号)为前缀，二进制以`0b`为前缀。在 Python 中尝试一下:

```py
>>>  0xFF 255 >>>  0b1111_1111 255 >>>  hex(255) '0xff' >>>  bin(255) '0b11111111'
```

一个字节可以代表`0-255`，与`0x0-0xFF`相同。每个字节为 8 位，通常分为两个各 4 位的*半字节*:

```py
>>>  0b0000_1111 15 >>>  hex(15) '0xf' >>>  0xF 15
```

 是的，你可以把`_`塞进数字里，*包括*十六进制和二进制符号，作为一种视觉辅助。很酷吧。 

这两个半字节通常被称为“高”和“低”。哪一个是*高*或*低*——左侧或右侧——归结为 CPU 的*字节序*，这个话题我们将在稍后认真讨论二进制数时讨论。

具有讽刺意味的是，除了让人类更容易推理出*二进制数*之外，没有理由使用十六进制数，因为十六进制数、字节、位和半字节都是 2 的幂:2、4、8、16。

现在，因为 Z80 是一个 8 位的 CPU(16 位支持算术和寻址),你需要一次处理半字节、位和(最多)2 个字节。十六进制使它更容易，但如果你喜欢，你可以自由使用小数！

#### 解析操作码

所以回到操作码解析器。我们已经看到，操作码有十六进制值的字符串表示。但是我们需要先对它们进行解析。幸运的是 Python 可以为我们做到这一点:

```py
>>>  int("0xFF", base=16) 255
```

`int()`函数接受一个可选的基，它也能够理解自己的符号:

```py
>>>  int("0b0110111", base=2) 55
```

所以这应该能解决问题。

说到底，我现在有两本词典，包含每一套独特的说明:

```py
>>> instructions[0xFF] Instruction(opcode=255, immediate=True, operands=[   Operand(immediate=True, name='38H',  bytes=None, value=None, adjust=None) ], cycles=[16],  bytes=1, mnemonic='RST', comment='')
```

有了它，我可以很快得到一个独特的列表，里面列出了每种字典的所有助记符:

```py
>>>  {inst.mnemonic for inst in instructions.values()} {'ADC',   'ADD', 'AND', 'CALL', # ... etc ... 'SUB', 'XOR'}
```

这样，你就有了一个操作码的工作列表。我建议您为指令和操作数编写一个漂亮的打印机，这样您就可以看到类似于我之前展示的模板的文本表示。

## 结论和下一步措施

Opcodes and operands is the machine code that powers your computer

我们已经简要地介绍了 CPU 是什么，它做什么——以后还会有更多的介绍——以及操作码和操作数的作用。它是你的 CPU 的编程语言。但是正如我所展示的，像 Python 这样的高级语言及其解释语言；编译时发出的字节码；它用来*运行*字节码的虚拟机，与 CPU 的角色没有什么不同。

Hexadecimals, Binary and Numbers writ large

十六进制是程序员的助手。除了帮助我们推理二进制数之外，它们与计算没有什么关系，这是一个我还没有涉及到的话题，因为要真正理解它们需要深入研究。可以说，二进制数是 CPU 的命脉。

Emulation is the act of replicating the conditions that allow code to run unmodified on a different host

但是要注意的是，并不是所有的东西都那么容易被复制！让事情*变得恰到好处*既是一门艺术，也是一门科学。我们的目标是编写一个 Game Boy 模拟器，但要围绕*、周期准确度*和性能进行权衡。

The Game Boy CPU is a hybrid of multiple different CPU types

我将它称为 Z80，因为它相当接近 CPU，但它并不完全相同。这是一款夏普 LR35902，它的灵感绝对来自英特尔 8080 和 Z80。但是在线上没有关于该模型的官方参考文档，您可以找到的大多数文档都将您引回到 Game Boy 模拟器。

如果你想阅读 Z80，记住夏普有一个不同的指令集(但有很多重叠)；它缺少一些寄存器和标志。

### 后续步骤

在下一部分，我们将看看如何编写一个反汇编程序，并使用我们刚刚读到的操作码。知道如何表示 CPU 将要执行的代码是一个重要的调试助手。